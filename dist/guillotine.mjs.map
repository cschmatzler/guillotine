{
  "version": 3,
  "sources": ["../assets/node_modules/@zag-js/anatomy/src/create-anatomy.ts", "../assets/node_modules/@zag-js/dom-query/src/attrs.ts", "../assets/node_modules/@zag-js/dom-query/src/constants.ts", "../assets/node_modules/@zag-js/dom-query/src/is.ts", "../assets/node_modules/@zag-js/dom-query/src/contains.ts", "../assets/node_modules/@zag-js/dom-query/src/env.ts", "../assets/node_modules/@zag-js/dom-query/src/platform.ts", "../assets/node_modules/@zag-js/dom-query/src/event.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-id.ts", "../assets/node_modules/@zag-js/dom-query/src/sanitize.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-text.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-typeahead.ts", "../assets/node_modules/@zag-js/dom-query/src/get-computed-style.ts", "../assets/node_modules/@zag-js/dom-query/src/get-parent-node.ts", "../assets/node_modules/@zag-js/dom-query/src/get-scroll-position.ts", "../assets/node_modules/@zag-js/dom-query/src/tabbable.ts", "../assets/node_modules/@zag-js/dom-query/src/initial-focus.ts", "../assets/node_modules/@zag-js/dom-query/src/is-editable-element.ts", "../assets/node_modules/@zag-js/dom-query/src/is-hidden-element.ts", "../assets/node_modules/@zag-js/dom-query/src/is-overflow-element.ts", "../assets/node_modules/@zag-js/dom-query/src/raf.ts", "../assets/node_modules/@zag-js/dom-query/src/observe-attributes.ts", "../assets/node_modules/@zag-js/dom-query/src/observe-children.ts", "../assets/node_modules/@zag-js/dom-query/src/overflow.ts", "../assets/node_modules/@zag-js/dom-query/src/proxy-tab-focus.ts", "../assets/node_modules/@zag-js/dom-query/src/query.ts", "../assets/node_modules/@zag-js/dom-query/src/scope.ts", "../assets/node_modules/@zag-js/dom-query/src/scroll-into-view.ts", "../assets/node_modules/@zag-js/dom-query/src/set.ts", "../assets/node_modules/@zag-js/dom-query/src/visually-hidden.ts", "../assets/node_modules/@zag-js/dom-query/src/wait-for.ts", "../assets/node_modules/@zag-js/dom-event/src/add-dom-event.ts", "../assets/node_modules/@zag-js/dom-event/src/assertion.ts", "../assets/node_modules/@zag-js/dom-event/src/click-link.ts", "../assets/node_modules/@zag-js/dom-event/src/queue-before-event.ts", "../assets/node_modules/@zag-js/dom-event/src/fire-event.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-key.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-point.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-step.ts", "../assets/node_modules/@zag-js/dom-event/src/get-native-event.ts", "../assets/node_modules/@zag-js/dom-event/src/get-point-value.ts", "../assets/node_modules/@zag-js/dom-event/src/request-pointer-lock.ts", "../assets/node_modules/@zag-js/dom-event/src/track-focus-visible.ts", "../assets/node_modules/@zag-js/dom-event/src/pipe.ts", "../assets/node_modules/@zag-js/dom-event/src/track-pointer-move.ts", "../assets/node_modules/@zag-js/dom-event/src/track-press.ts", "../assets/node_modules/@zag-js/dom-event/src/track-visual-viewport.ts", "../assets/node_modules/@zag-js/utils/src/array.ts", "../assets/node_modules/@zag-js/utils/src/equal.ts", "../assets/node_modules/@zag-js/utils/src/functions.ts", "../assets/node_modules/@zag-js/utils/src/guard.ts", "../assets/node_modules/@zag-js/utils/src/object.ts", "../assets/node_modules/@zag-js/utils/src/split-props.ts", "../assets/node_modules/@zag-js/utils/src/warning.ts", "../assets/node_modules/proxy-compare/dist/index.js", "../assets/node_modules/@zag-js/store/src/global.ts", "../assets/node_modules/@zag-js/store/src/proxy.ts", "../assets/node_modules/@zag-js/store/src/proxy-computed.ts", "../assets/node_modules/klona/full/index.mjs", "../assets/node_modules/@zag-js/core/src/index.ts", "../assets/node_modules/@zag-js/utilities/core/src/array.ts", "../assets/node_modules/@zag-js/utilities/core/src/functions.ts", "../assets/node_modules/@zag-js/utilities/core/src/guard.ts", "../assets/node_modules/@zag-js/utilities/core/src/object.ts", "../assets/node_modules/@zag-js/utilities/core/src/warning.ts", "../assets/node_modules/@zag-js/core/src/deep-merge.ts", "../assets/node_modules/@zag-js/core/src/utils.ts", "../assets/node_modules/@zag-js/core/src/guard-utils.ts", "../assets/node_modules/@zag-js/core/src/machine.ts", "../assets/node_modules/@zag-js/core/src/create-proxy.ts", "../assets/node_modules/@zag-js/core/src/delay-utils.ts", "../assets/node_modules/@zag-js/core/src/transition-utils.ts", "../assets/node_modules/@zag-js/core/src/merge-props.ts", "../assets/node_modules/@zag-js/types/src/prop-types.ts", "../assets/node_modules/@zag-js/types/src/create-props.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.anatomy.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.connect.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.dom.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.machine.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.props.ts", "../assets/js/normalize-props.js", "../assets/js/spread-props.js", "../assets/js/accordion.js", "../assets/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../assets/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../assets/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../assets/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../assets/node_modules/@zag-js/popper/src/get-placement.ts", "../assets/node_modules/@zag-js/popper/src/get-anchor.ts", "../assets/node_modules/@zag-js/popper/src/middleware.ts", "../assets/node_modules/@zag-js/popper/src/placement.ts", "../assets/node_modules/@zag-js/popper/src/get-styles.ts", "../assets/node_modules/@zag-js/interact-outside/src/index.ts", "../assets/node_modules/@zag-js/interact-outside/src/get-window-frames.ts", "../assets/node_modules/@zag-js/dismissable/src/dismissable-layer.ts", "../assets/node_modules/@zag-js/dismissable/src/escape-keydown.ts", "../assets/node_modules/@zag-js/dismissable/src/layer-stack.ts", "../assets/node_modules/@zag-js/dismissable/src/pointer-event-outside.ts", "../assets/node_modules/@zag-js/rect-utils/src/affine-transform.ts", "../assets/node_modules/@zag-js/rect-utils/src/align.ts", "../assets/node_modules/@zag-js/rect-utils/src/clamp.ts", "../assets/node_modules/@zag-js/rect-utils/src/rect.ts", "../assets/node_modules/@zag-js/rect-utils/src/intersection.ts", "../assets/node_modules/@zag-js/rect-utils/src/distance.ts", "../assets/node_modules/@zag-js/rect-utils/src/closest.ts", "../assets/node_modules/@zag-js/rect-utils/src/constrain.ts", "../assets/node_modules/@zag-js/rect-utils/src/contains.ts", "../assets/node_modules/@zag-js/rect-utils/src/equality.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-element.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-points.ts", "../assets/node_modules/@zag-js/rect-utils/src/union.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-range.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-rotation.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-window.ts", "../assets/node_modules/@zag-js/rect-utils/src/operations.ts", "../assets/node_modules/@zag-js/rect-utils/src/polygon.ts", "../assets/node_modules/@zag-js/rect-utils/src/compass.ts", "../assets/node_modules/@zag-js/rect-utils/src/resize.ts", "../assets/node_modules/@zag-js/menu/src/menu.anatomy.ts", "../assets/node_modules/@zag-js/menu/src/menu.connect.ts", "../assets/node_modules/@zag-js/menu/src/menu.dom.ts", "../assets/node_modules/@zag-js/menu/src/menu.machine.ts", "../assets/node_modules/@zag-js/menu/src/menu.props.ts", "../assets/js/menu.js", "../assets/js/index.js"],
  "sourcesContent": ["export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n", "import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n", "export const MAX_Z_INDEX = 2147483647\n", "export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => el != null && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  el != null && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n", "import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n", "import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n", "export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n", "import { contains } from \"./contains\"\nimport { isApple } from \"./platform\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nexport function getEventTarget<T extends EventTarget>(event: Pick<UIEvent, \"target\" | \"composedPath\">): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n\nexport const isSelfTarget = (event: Pick<UIEvent, \"currentTarget\" | \"target\" | \"composedPath\">) => {\n  return contains(event.currentTarget as Node, getEventTarget(event))\n}\n\nexport function isOpeningInNewTab(event: Pick<MouseEvent, \"currentTarget\" | \"metaKey\" | \"ctrlKey\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const isAppleDevice = isApple()\n  if (isAppleDevice && !event.metaKey) return false\n  if (!isAppleDevice && !event.ctrlKey) return false\n\n  const localName = element.localName\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isDownloadingEvent(event: Pick<MouseEvent, \"altKey\" | \"currentTarget\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const localName = element.localName\n  if (!event.altKey) return false\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n", "export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n", "export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n", "import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n", "import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n", "import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n", "import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n", "import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n", "const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nconst isFrame = (element: any): element is HTMLIFrameElement => isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nfunction isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\ntype IncludeContainerType = boolean | \"if-empty\"\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nconst focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n\n/**\n * Returns the focusable elements within the element\n */\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n\n/**\n * Whether this element is focusable\n */\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): [HTMLElement, HTMLElement] | [null, null] {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n", "import { getFirstTabbable, getTabbableEdges } from \"./tabbable\"\n\nexport function getInitialFocus(\n  container: HTMLElement | null,\n  getInitialEl?: () => HTMLElement | null,\n): HTMLElement | undefined {\n  let node: HTMLElement | null | undefined = null\n  node ||= typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl\n  node ||= container?.querySelector<HTMLElement>(\"[data-autofocus],[autofocus]\")\n  node ||= getFirstTabbable(container)\n  return node || container || undefined\n}\n\nexport function isValidTabEvent(event: Pick<KeyboardEvent, \"shiftKey\" | \"currentTarget\">): boolean {\n  const container = event.currentTarget as HTMLElement | null\n  if (!container) return false\n\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container)\n  const doc = container.ownerDocument || document\n\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false\n  if (!firstTabbable && !lastTabbable) return false\n\n  return true\n}\n", "import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n", "export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n", "import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n", "export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveAttributeOptions {\n  attributes: string[]\n  callback(record: MutationRecord): void\n  defer?: boolean\n}\n\nfunction observeAttributesImpl(node: MaybeElement, options: ObserveAttributeOptions) {\n  if (!node) return\n  const { attributes, callback: fn } = options\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n  return () => obs.disconnect()\n}\n\nexport function observeAttributes(nodeOrFn: NodeOrFn, options: ObserveAttributeOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeAttributesImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveChildrenOptions {\n  callback: MutationCallback\n  defer?: boolean\n}\n\nfunction observeChildrenImpl(node: MaybeElement, options: ObserveChildrenOptions) {\n  const { callback: fn } = options\n  if (!node) return\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n  return () => obs.disconnect()\n}\n\nexport function observeChildren(nodeOrFn: NodeOrFn, options: ObserveChildrenOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeChildrenImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n", "import { raf } from \"./raf\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus)\n    } else {\n      elementToFocus.focus()\n    }\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n", "import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === screen.getActiveElement(ctx),\n    getById: <T extends HTMLElement = HTMLElement>(ctx: ScopeContext, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...screen, ...methods }\n}\n", "import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n", "const cleanups = new WeakMap<Element, Map<string, () => void>>()\n\nexport function set(element: Element, key: string, setup: () => () => void) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, new Map())\n  }\n\n  const elementCleanups = cleanups.get(element)!\n  const prevCleanup = elementCleanups.get(key)\n\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup())\n    return () => {\n      elementCleanups.get(key)?.()\n      elementCleanups.delete(key)\n    }\n  }\n\n  const cleanup = setup()\n\n  const nextCleanup = () => {\n    cleanup()\n    prevCleanup()\n    elementCleanups.delete(key)\n  }\n\n  elementCleanups.set(key, nextCleanup)\n\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup\n    if (!isCurrent) return\n    cleanup()\n    elementCleanups.set(key, prevCleanup)\n  }\n}\n\nexport function setAttribute(element: Element, attr: string, value: string) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr)\n    element.setAttribute(attr, value)\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr)\n      } else {\n        element.setAttribute(attr, previousValue)\n      }\n    }\n  }\n\n  return set(element, attr, setup)\n}\n\nexport function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]) {\n  const setup = () => {\n    const exists = property in element\n    const previousValue = element[property]\n    element[property] = value\n    return () => {\n      if (!exists) {\n        delete element[property]\n      } else {\n        element[property] = previousValue\n      }\n    }\n  }\n\n  return set(element, property, setup)\n}\n\nexport function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!element) return () => {}\n\n  const setup = () => {\n    const prevStyle = element.style.cssText\n    Object.assign(element.style, style)\n    return () => {\n      element.style.cssText = prevStyle\n    }\n  }\n\n  return set(element, \"style\", setup)\n}\n", "export const visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\",\n} as const\n", "import { isHTMLElement } from \"./is\"\n\ntype ElementGetter = () => Element | null\n\nconst fps = 1000 / 60\n\nexport function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void) {\n  const el = query()\n\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el)\n    return () => void 0\n  } else {\n    const timerId = setInterval(() => {\n      const el = query()\n      if (isHTMLElement(el) && el.isConnected) {\n        cb(el)\n        clearInterval(timerId)\n      }\n    }, fps)\n\n    return () => clearInterval(timerId)\n  }\n}\n\nexport function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void) {\n  const cleanups: VoidFunction[] = []\n\n  queries?.forEach((query) => {\n    const clean = waitForElement(query, cb)\n    cleanups.push(clean)\n  })\n\n  return () => {\n    cleanups.forEach((fn) => fn())\n  }\n}\n", "interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n", "import { isMac } from \"@zag-js/dom-query\"\n\nexport function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isMac() && e.ctrlKey && e.button === 0)\n}\n\nexport const isModifierKey = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n", "import { isFirefox } from \"@zag-js/dom-query\"\nimport { queueBeforeEvent } from \"./queue-before-event\"\n\nfunction isLinkElement(element: HTMLElement | null | undefined) {\n  return element?.matches(\"a[href]\") ?? false\n}\n\nexport function clickIfLink(element: HTMLElement | null | undefined) {\n  if (!isLinkElement(element)) return\n  const click = () => element!.click()\n  if (isFirefox()) {\n    queueBeforeEvent(element!, \"keyup\", click)\n  } else {\n    queueMicrotask(click)\n  }\n}\n", "export function queueBeforeEvent(element: Element, type: string, cb: () => void) {\n  const createTimer = (callback: () => void) => {\n    const timerId = requestAnimationFrame(callback)\n    return () => cancelAnimationFrame(timerId)\n  }\n\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true)\n    cb()\n  })\n  const callSync = () => {\n    cancelTimer()\n    cb()\n  }\n\n  element.addEventListener(type, callSync, { once: true, capture: true })\n  return cancelTimer\n}\n", "export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n", "import type { EventKeyOptions } from \"./types\"\n\nconst keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n", "type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: AnyPointerEvent, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n", "const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n", "import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> =\n  JSX.ChangeEvent<any> extends E ? InputEvent : E extends JSX.SyntheticEvent<any, infer T> ? T : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n", "function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n", "import { getWindow, isMac } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { pipe } from \"./pipe\"\n\nexport interface TrackFocusOptions {\n  /**\n   * Callback to be called when the element receives focus and is focus-visible.\n   */\n  onFocus?(e: FocusEvent): void\n  /**\n   * Callback to be called when the element loses focus.\n   */\n  onBlur?(e: FocusEvent): void\n}\n\nconst isValidKey = (e: KeyboardEvent) => {\n  return !(\n    e.metaKey ||\n    (!isMac() && e.altKey) ||\n    e.ctrlKey ||\n    e.key === \"Control\" ||\n    e.key === \"Shift\" ||\n    e.key === \"Meta\"\n  )\n}\n\nexport function trackFocusVisible(node: Element | null, options: TrackFocusOptions) {\n  if (!node) return\n  const { onFocus, onBlur } = options\n\n  const win = getWindow(node)\n\n  let focused = false\n\n  const handleFocus = (e: FocusEvent) => {\n    let isFocusVisible = false\n\n    try {\n      isFocusVisible = node.matches(\":focus-visible\")\n    } catch {\n      isFocusVisible = true\n    }\n\n    if (!isFocusVisible) return\n\n    focused = true\n    onFocus?.(e)\n  }\n\n  const handleBlur = (e: FocusEvent) => {\n    if (!focused) return\n    focused = false\n    onBlur?.(e)\n  }\n\n  const handleKeydown = (e: KeyboardEvent) => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return\n    focused = true\n    const evt = new win.FocusEvent(\"focus\")\n    onFocus?.(evt)\n  }\n\n  return pipe(\n    addDomEvent(node, \"focusin\", handleFocus),\n    addDomEvent(node, \"focusout\", handleBlur),\n    addDomEvent(node, \"keydown\", handleKeydown, true),\n  )\n}\n", "export const pipe =\n  <T>(...fns: Array<(arg: T) => T>) =>\n  (arg: T) =>\n    fns.reduce((acc, fn) => fn(acc), arg)\n\nexport const noop = () => void 0\n", "import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TimestampedPoint extends Point {\n  /**\n   * The time when the point was recorded.\n   */\n  timestamp: number\n}\n\nexport interface PointerMoveDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n  /**\n   * The velocity of the pointer on the x and y axis.\n   */\n  velocity: Point\n}\n\nexport interface PointerMoveHandlers {\n  /**\n   * Called when the pointer is released.\n   */\n  onPointerUp: VoidFunction\n  /**\n   * Called when the pointer moves.\n   */\n  onPointerMove: (details: PointerMoveDetails) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const history: TimestampedPoint[] = []\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n    history.push({ ...point, timestamp: performance.now() })\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n    history.length = 0\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nfunction ms(seconds: number): number {\n  return seconds * 1000\n}\n\nfunction sec(milliseconds: number): number {\n  return milliseconds / 1000\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp)\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y),\n  }\n}\n", "import { contains, getDocument, getEventTarget, getWindow } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\nimport { noop, pipe } from \"./pipe\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TapDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n}\n\nexport interface TrackPressOptions {\n  /**\n   * The element that will be used to track the pointer events.\n   */\n  pointerNode: Element | null\n  /**\n   * The element that will be used to track the keyboard focus events.\n   */\n  keyboardNode?: Element | null\n  /**\n   * A function that determines if the key is valid for the press event.\n   */\n  isValidKey?(event: KeyboardEvent): boolean\n  /**\n   * A function that will be called when the pointer is pressed.\n   */\n  onPress?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed down.\n   */\n  onPressStart?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed up or cancelled.\n   */\n  onPressEnd?(details: TapDetails): void\n}\n\nexport function trackPress(options: TrackPressOptions) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\",\n  } = options\n\n  if (!pointerNode) return noop\n\n  const win = getWindow(pointerNode)\n  const doc = getDocument(pointerNode)\n\n  let removeStartListeners: VoidFunction = noop\n  let removeEndListeners: VoidFunction = noop\n  let removeAccessibleListeners: VoidFunction = noop\n\n  const getInfo = (event: PointerEvent): TapDetails => ({\n    point: getEventPoint(event),\n    event,\n  })\n\n  function startPress(event: PointerEvent) {\n    onPressStart?.(getInfo(event))\n  }\n\n  function cancelPress(event: PointerEvent) {\n    onPressEnd?.(getInfo(event))\n  }\n\n  const startPointerPress = (startEvent: PointerEvent) => {\n    removeEndListeners()\n\n    const endPointerPress = (endEvent: PointerEvent) => {\n      const target = getEventTarget<Element>(endEvent)\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent))\n      } else {\n        onPressEnd?.(getInfo(endEvent))\n      }\n    }\n\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress })\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, { passive: !onPressEnd })\n\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener)\n\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault()\n    }\n\n    startPress(startEvent)\n  }\n\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart })\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress)\n\n  removeStartListeners = pipe(removePointerListener, removeFocusListener)\n\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent: KeyboardEvent) => {\n      if (!isValidKey(keydownEvent)) return\n\n      const handleKeyup = (keyupEvent: KeyboardEvent) => {\n        if (!isValidKey(keyupEvent)) return\n        const evt = new win.PointerEvent(\"pointerup\")\n        const info = getInfo(evt)\n        onPress?.(info)\n        onPressEnd?.(info)\n      }\n\n      removeEndListeners()\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup)\n\n      const evt = new win.PointerEvent(\"pointerdown\")\n      startPress(evt)\n    }\n\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\")\n      cancelPress(evt)\n    }\n\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown)\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur)\n\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener)\n  }\n\n  return function () {\n    removeStartListeners()\n    removeEndListeners()\n    removeAccessibleListeners()\n  }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\nexport interface ViewportSize {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "const isArrayLike = (value: any) => value?.constructor.name === \"Array\"\n\nexport const isEqual = (a: any, b: any): boolean => {\n  if (Object.is(a, b)) return true\n\n  if ((a == null && b != null) || (a != null && b == null)) return false\n\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b)\n  }\n\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString()\n  }\n\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return Array.from(a).toString() === Array.from(b).toString()\n  }\n\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false\n\n  const keys = Object.keys(b ?? Object.create(null))\n  const length = keys.length\n\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i])\n    if (!hasKey) return false\n  }\n\n  for (let i = 0; i < length; i++) {\n    const key = keys[i]\n    if (!isEqual(a[key], b[key])) return false\n  }\n\n  return true\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n", "type Dict = Record<string, any>\n\nexport function splitProps<T extends Dict>(props: T, keys: (keyof T)[]) {\n  const rest: Dict = {}\n  const result: Dict = {}\n\n  const keySet = new Set(keys)\n\n  for (const key in props) {\n    if (keySet.has(key)) {\n      result[key] = props[key]\n    } else {\n      rest[key] = props[key]\n    }\n  }\n\n  return [result, rest]\n}\n\nexport const createSplitProps = <T extends Dict>(keys: (keyof T)[]) => {\n  return function split<Props extends T>(props: Props) {\n    return splitProps(props, keys) as [T, Omit<Props, keyof T>]\n  }\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nexport const isChanged = (prevObj, nextObj, affected, cache, isEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n            return hit[CHANGED_PROPERTY];\n        }\n        // for object with cycles\n        cache.set(prevObj, {\n            [NEXT_OBJECT_PROPERTY]: nextObj,\n            [CHANGED_PROPERTY]: false,\n        });\n    }\n    let changed = null;\n    try {\n        for (const key of used[HAS_KEY_PROPERTY] || []) {\n            changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n            if (changed)\n                return changed;\n        }\n        if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n            changed = isAllOwnKeysChanged(prevObj, nextObj);\n            if (changed)\n                return changed;\n        }\n        else {\n            for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n                const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n                const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n                changed = hasPrev !== hasNext;\n                if (changed)\n                    return changed;\n            }\n        }\n        for (const key of used[KEYS_PROPERTY] || []) {\n            changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n            if (changed)\n                return changed;\n        }\n        if (changed === null)\n            changed = true;\n        return changed;\n    }\n    finally {\n        if (cache) {\n            cache.set(prevObj, {\n                [NEXT_OBJECT_PROPERTY]: nextObj,\n                [CHANGED_PROPERTY]: changed,\n            });\n        }\n    }\n};\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n", "function getGlobal(): any {\n  if (typeof globalThis !== \"undefined\") return globalThis\n  if (typeof self !== \"undefined\") return self\n  if (typeof window !== \"undefined\") return window\n  if (typeof global !== \"undefined\") return global\n}\n\nexport function makeGlobal<T>(key: string, value: () => T): T {\n  const g = getGlobal()\n  if (!g) return value()\n  g[key] ||= value()\n  return g[key]\n}\n", "// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\nimport { makeGlobal } from \"./global\"\n\nconst isDev = process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\n\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\n\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n    ? T\n    : T extends Promise<any>\n      ? Awaited<T>\n      : {\n          readonly [K in keyof T]: Snapshot<T[K]>\n        }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => new WeakMap<ProxyObject, ProxyState>())\nconst refSet = makeGlobal(\"__zag__refSet\", () => new WeakSet())\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              Object.assign(value, { status: \"fulfilled\", value: v })\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              Object.assign(value, { status: \"rejected\", reason: e })\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): Ref<T> {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n\nexport type Ref<T> = T & AsRef\n", "import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n", "function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n", "export { proxy, ref, snapshot, subscribe, type Ref } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n", "import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n", "import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n", "import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  public get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  public _created = () => {\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n\nexport const isMachine = (value: any): value is AnyMachine => {\n  return value instanceof Machine || value?.type === MachineType.Machine\n}\n", "import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n", "import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n", "import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n", "import { callAll, isString } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g\n\nconst serialize = (style: string): Record<string, string> => {\n  const res: Record<string, string> = {}\n  let match: RegExpExecArray | null\n  while ((match = CSS_REGEX.exec(style))) {\n    res[match[1]!] = match[2]!\n  }\n  return res\n}\n\nconst css = (\n  a: Record<string, string> | string | undefined,\n  b: Record<string, string> | string | undefined,\n): Record<string, string> | string => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`\n    a = serialize(a)\n  } else if (isString(b)) {\n    b = serialize(b)\n  }\n  return Object.assign({}, a ?? {}, b ?? {})\n}\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nconst eventRegex = /^on[A-Z]/\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (eventRegex.test(key) && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key])\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n", "import type { JSX } from \"./jsx\"\n\ntype Dict<T = any> = Record<string, T>\n\ntype DataAttr = {\n  \"data-selected\"?: any\n  \"data-expanded\"?: any\n  \"data-highlighted\"?: any\n  \"data-readonly\"?: any\n  \"data-indeterminate\"?: any\n  \"data-invalid\"?: any\n  \"data-hover\"?: any\n  \"data-active\"?: any\n  \"data-focus\"?: any\n  \"data-disabled\"?: any\n  \"data-open\"?: any\n  \"data-checked\"?: any\n  \"data-pressed\"?: any\n  \"data-complete\"?: any\n  \"data-side\"?: any\n  \"data-align\"?: any\n  \"data-empty\"?: any\n  \"data-placeholder-shown\"?: any\n  \"data-half\"?: any\n  \"data-scope\"?: string\n  \"data-uid\"?: string\n  \"data-name\"?: string\n  \"data-ownedby\"?: string\n  \"data-type\"?: string\n  \"data-valuetext\"?: string\n  \"data-placement\"?: string\n  \"data-controls\"?: string\n  \"data-part\"?: string\n  \"data-label\"?: string\n  \"data-state\"?: string | null\n  \"data-value\"?: string | number\n  \"data-orientation\"?: \"horizontal\" | \"vertical\"\n  \"data-count\"?: number\n  \"data-index\"?: number\n} & {\n  [key in `data-${string}`]?: any\n}\n\nexport type PropTypes<T = Dict> = Record<\n  | \"button\"\n  | \"label\"\n  | \"input\"\n  | \"textarea\"\n  | \"img\"\n  | \"output\"\n  | \"element\"\n  | \"select\"\n  | \"style\"\n  | \"circle\"\n  | \"svg\"\n  | \"path\",\n  T\n>\n\nexport type NormalizeProps<T extends PropTypes> = {\n  [K in keyof T]: (props: K extends keyof JSX.IntrinsicElements ? DataAttr & JSX.IntrinsicElements[K] : never) => T[K]\n} & {\n  element(props: DataAttr & JSX.HTMLAttributes<HTMLElement> & Record<string, any>): T[\"element\"]\n  style: JSX.CSSProperties\n}\n\nexport function createNormalizer<T extends PropTypes>(fn: (props: Dict) => Dict): NormalizeProps<T> {\n  return new Proxy({} as any, {\n    get() {\n      return fn\n    },\n  })\n}\n", "type StrictKeys<K extends (keyof T)[], T> = K extends (keyof T)[]\n  ? [keyof T] extends [K[number]]\n    ? unknown\n    : `Missing required keys: ${Exclude<keyof T, K[number]>}`\n  : never\n\nexport const createProps =\n  <T extends Record<never, never>>() =>\n  <K extends (keyof T)[]>(props: K & StrictKeys<K, T>) =>\n    Array.from(new Set(props))\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"accordion\").parts(\"root\", \"item\", \"itemTrigger\", \"itemContent\", \"itemIndicator\")\nexport const parts = anatomy.build()\n", "import { getEventKey, type EventKeyMap } from \"@zag-js/dom-event\"\nimport { dataAttr, isSafari } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./accordion.anatomy\"\nimport { dom } from \"./accordion.dom\"\nimport type { ItemProps, ItemState, MachineApi, Send, State } from \"./accordion.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const focusedValue = state.context.focusedValue\n  const value = state.context.value\n  const multiple = state.context.multiple\n\n  function setValue(value: string[]) {\n    let nextValue = value\n    if (multiple && nextValue.length > 1) {\n      nextValue = [nextValue[0]]\n    }\n    send({ type: \"VALUE.SET\", value: nextValue })\n  }\n\n  function getItemState(props: ItemProps): ItemState {\n    return {\n      expanded: value.includes(props.value),\n      focused: focusedValue === props.value,\n      disabled: Boolean(props.disabled ?? state.context.disabled),\n    }\n  }\n\n  return {\n    focusedValue,\n    value,\n    setValue,\n    getItemState,\n\n    rootProps: normalize.element({\n      ...parts.root.attrs,\n      dir: state.context.dir,\n      id: dom.getRootId(state.context),\n      \"data-orientation\": state.context.orientation,\n    }),\n\n    getItemProps(props: ItemProps) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, props.value),\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemContentProps(props: ItemProps) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.itemContent.attrs,\n        dir: state.context.dir,\n        role: \"region\",\n        id: dom.getItemContentId(state.context, props.value),\n        \"aria-labelledby\": dom.getItemTriggerId(state.context, props.value),\n        hidden: !itemState.expanded,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemIndicatorProps(props) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"aria-hidden\": true,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemTriggerProps(props: ItemProps) {\n      const { value } = props\n      const itemState = getItemState(props)\n\n      return normalize.button({\n        ...parts.itemTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        id: dom.getItemTriggerId(state.context, value),\n        \"aria-controls\": dom.getItemContentId(state.context, value),\n        \"aria-expanded\": itemState.expanded,\n        disabled: itemState.disabled,\n        \"data-orientation\": state.context.orientation,\n        \"aria-disabled\": itemState.disabled,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-ownedby\": dom.getRootId(state.context),\n        onFocus() {\n          if (itemState.disabled) return\n          send({ type: \"TRIGGER.FOCUS\", value })\n        },\n        onBlur() {\n          if (itemState.disabled) return\n          send(\"TRIGGER.BLUR\")\n        },\n        onClick(event) {\n          if (itemState.disabled) return\n          if (isSafari()) {\n            event.currentTarget.focus()\n          }\n          send({ type: \"TRIGGER.CLICK\", value })\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (itemState.disabled) return\n\n          const keyMap: EventKeyMap = {\n            ArrowDown() {\n              if (state.context.isHorizontal) return\n              send({ type: \"GOTO.NEXT\", value })\n            },\n            ArrowUp() {\n              if (state.context.isHorizontal) return\n              send({ type: \"GOTO.PREV\", value })\n            },\n            ArrowRight() {\n              if (!state.context.isHorizontal) return\n              send({ type: \"GOTO.NEXT\", value })\n            },\n            ArrowLeft() {\n              if (!state.context.isHorizontal) return\n              send({ type: \"GOTO.PREV\", value })\n            },\n            Home() {\n              send({ type: \"GOTO.FIRST\", value })\n            },\n            End() {\n              send({ type: \"GOTO.LAST\", value })\n            },\n          }\n\n          const key = getEventKey(event, {\n            dir: state.context.dir,\n            orientation: state.context.orientation,\n          })\n\n          const exec = keyMap[key]\n\n          if (exec) {\n            exec(event)\n            event.preventDefault()\n          }\n        },\n      })\n    },\n  }\n}\n", "import { nextById, prevById, queryAll, createScope } from \"@zag-js/dom-query\"\nimport { first, last } from \"@zag-js/utils\"\nimport type { MachineContext as Ctx } from \"./accordion.types\"\n\nexport const dom = createScope({\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`,\n  getItemId: (ctx: Ctx, value: string) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,\n  getItemContentId: (ctx: Ctx, value: string) => ctx.ids?.content?.(value) ?? `accordion:${ctx.id}:content:${value}`,\n  getItemTriggerId: (ctx: Ctx, value: string) => ctx.ids?.trigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,\n\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getTriggers: (ctx: Ctx) => {\n    const ownerId = CSS.escape(dom.getRootId(ctx))\n    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`\n    return queryAll(dom.getRootEl(ctx), selector)\n  },\n\n  getFirstTriggerEl: (ctx: Ctx) => first(dom.getTriggers(ctx)),\n  getLastTriggerEl: (ctx: Ctx) => last(dom.getTriggers(ctx)),\n  getNextTriggerEl: (ctx: Ctx, id: string) => nextById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id)),\n  getPrevTriggerEl: (ctx: Ctx, id: string) => prevById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id)),\n})\n", "import { createMachine, guards } from \"@zag-js/core\"\nimport { add, compact, isEqual, remove, warn } from \"@zag-js/utils\"\nimport { dom } from \"./accordion.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./accordion.types\"\n\nconst { and, not } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"accordion\",\n      initial: \"idle\",\n\n      context: {\n        focusedValue: null,\n        value: [],\n        collapsible: false,\n        multiple: false,\n        orientation: \"vertical\",\n        ...ctx,\n      },\n\n      watch: {\n        value: \"coarseValue\",\n        multiple: \"coarseValue\",\n      },\n\n      created: \"coarseValue\",\n\n      computed: {\n        isHorizontal: (ctx) => ctx.orientation === \"horizontal\",\n      },\n\n      on: {\n        \"VALUE.SET\": {\n          actions: [\"setValue\"],\n        },\n      },\n\n      states: {\n        idle: {\n          on: {\n            \"TRIGGER.FOCUS\": {\n              target: \"focused\",\n              actions: \"setFocusedValue\",\n            },\n          },\n        },\n        focused: {\n          on: {\n            \"GOTO.NEXT\": {\n              actions: \"focusNextTrigger\",\n            },\n            \"GOTO.PREV\": {\n              actions: \"focusPrevTrigger\",\n            },\n            \"TRIGGER.CLICK\": [\n              {\n                guard: and(\"isExpanded\", \"canToggle\"),\n                actions: [\"collapse\"],\n              },\n              {\n                guard: not(\"isExpanded\"),\n                actions: [\"expand\"],\n              },\n            ],\n            \"GOTO.FIRST\": {\n              actions: \"focusFirstTrigger\",\n            },\n            \"GOTO.LAST\": {\n              actions: \"focusLastTrigger\",\n            },\n            \"TRIGGER.BLUR\": {\n              target: \"idle\",\n              actions: \"clearFocusedValue\",\n            },\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        canToggle: (ctx) => !!ctx.collapsible || !!ctx.multiple,\n        isExpanded: (ctx, evt) => ctx.value.includes(evt.value),\n      },\n      actions: {\n        collapse(ctx, evt) {\n          const next = ctx.multiple ? remove(ctx.value, evt.value) : []\n          set.value(ctx, ctx.multiple ? next : [])\n        },\n        expand(ctx, evt) {\n          const next = ctx.multiple ? add(ctx.value, evt.value) : [evt.value]\n          set.value(ctx, next)\n        },\n        focusFirstTrigger(ctx) {\n          dom.getFirstTriggerEl(ctx)?.focus()\n        },\n        focusLastTrigger(ctx) {\n          dom.getLastTriggerEl(ctx)?.focus()\n        },\n        focusNextTrigger(ctx) {\n          if (!ctx.focusedValue) return\n          const triggerEl = dom.getNextTriggerEl(ctx, ctx.focusedValue)\n          triggerEl?.focus()\n        },\n        focusPrevTrigger(ctx) {\n          if (!ctx.focusedValue) return\n          const triggerEl = dom.getPrevTriggerEl(ctx, ctx.focusedValue)\n          triggerEl?.focus()\n        },\n        setFocusedValue(ctx, evt) {\n          set.focusedValue(ctx, evt.value)\n        },\n        clearFocusedValue(ctx) {\n          set.focusedValue(ctx, null)\n        },\n        setValue(ctx, evt) {\n          set.value(ctx, evt.value)\n        },\n        coarseValue(ctx) {\n          if (!ctx.multiple && ctx.value.length > 1) {\n            warn(`The value of accordion should be a single value when multiple is false.`)\n            ctx.value = [ctx.value[0]]\n          }\n        },\n      },\n    },\n  )\n}\n\nconst invoke = {\n  change(ctx: MachineContext) {\n    ctx.onValueChange?.({ value: Array.from(ctx.value) })\n  },\n  focusChange(ctx: MachineContext) {\n    ctx.onFocusChange?.({ value: ctx.focusedValue })\n  },\n}\n\nconst set = {\n  value(ctx: MachineContext, value: string[]) {\n    if (isEqual(ctx.value, value)) return\n    ctx.value = value\n    invoke.change(ctx)\n  },\n  focusedValue(ctx: MachineContext, value: string | null) {\n    if (isEqual(ctx.focusedValue, value)) return\n    ctx.focusedValue = value\n    invoke.focusChange(ctx)\n  },\n}\n", "import { createProps } from \"@zag-js/types\"\nimport type { ItemProps, UserDefinedContext } from \"./accordion.types\"\nimport { createSplitProps } from \"@zag-js/utils\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"collapsible\",\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"multiple\",\n  \"onFocusChange\",\n  \"onValueChange\",\n  \"orientation\",\n  \"value\",\n])\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const itemProps = createProps<ItemProps>()([\"value\", \"disabled\"])\nexport const splitItemProps = createSplitProps<ItemProps>(itemProps)\n", "import { createNormalizer } from \"@zag-js/types\";\n\nexport const propMap = {\n  onFocus: \"onFocusin\",\n  onBlur: \"onFocusout\",\n  onChange: \"onInput\",\n  onDoubleClick: \"onDblclick\",\n  htmlFor: \"for\",\n  className: \"class\",\n  defaultValue: \"value\",\n  defaultChecked: \"checked\",\n};\n\nconst toStyleString = (style) => {\n  let string = \"\";\n  for (let key in style) {\n    const value = style[key];\n    if (value === null || value === undefined) continue;\n    if (!key.startsWith(\"--\")) key = key.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n    string += `${key}:${value};`;\n  }\n  return string;\n};\n\nexport const normalizeProps = createNormalizer((props) => {\n  return Object.entries(props).reduce((acc, [key, value]) => {\n    if (value === undefined) return acc;\n\n    if (key in propMap) {\n      key = propMap[key];\n    }\n\n    if (key === \"style\" && typeof value === \"object\") {\n      acc.style = toStyleString(value);\n      return acc;\n    }\n\n    acc[key.toLowerCase()] = value;\n\n    return acc;\n  }, {});\n});\n", "const prevAttrsMap = new WeakMap();\n\nexport function spreadProps(node, attrs) {\n  const oldAttrs = prevAttrsMap.get(node) || {};\n  const attrKeys = Object.keys(attrs);\n\n  const addEvent = (e, f) => {\n    node.addEventListener(e.toLowerCase(), f);\n  };\n\n  const removeEvent = (e, f) => {\n    node.removeEventListener(e.toLowerCase(), f);\n  };\n\n  const onEvents = (attr) => attr.startsWith(\"on\");\n  const others = (attr) => !attr.startsWith(\"on\");\n\n  const setup = (attr) => addEvent(attr.substring(2), attrs[attr]);\n  const teardown = (attr) => removeEvent(attr.substring(2), attrs[attr]);\n\n  const apply = (attrName) => {\n    let value = attrs[attrName];\n\n    const oldValue = oldAttrs[attrName];\n    if (value === oldValue) return;\n\n    if (typeof value === \"boolean\") {\n      value = value || undefined;\n    }\n\n    if (value != null) {\n      if ([\"value\", \"checked\", \"htmlFor\"].includes(attrName)) {\n        node[attrName] = value;\n      } else {\n        node.setAttribute(attrName.toLowerCase(), value);\n      }\n      return;\n    }\n\n    node.removeAttribute(attrName.toLowerCase());\n  };\n\n  for (const key in oldAttrs) {\n    if (attrs[key] == null) {\n      node.removeAttribute(key.toLowerCase());\n    }\n  }\n\n  const oldEvents = Object.keys(oldAttrs).filter(onEvents);\n  oldEvents.forEach((evt) => {\n    removeEvent(evt.substring(2), oldAttrs[evt]);\n  });\n\n  attrKeys.filter(onEvents).forEach(setup);\n  attrKeys.filter(others).forEach(apply);\n\n  prevAttrsMap.set(node, attrs);\n\n  return function cleanup() {\n    attrKeys.filter(onEvents).forEach(teardown);\n  };\n}\n", "import * as accordion from \"@zag-js/accordion\";\nimport { normalizeProps } from \"./normalize-props\";\nimport { spreadProps } from \"./spread-props\";\n\nexport const Accordion = {\n  mounted() {\n    this.context = { id: this.el.id };\n\n    this.service = accordion.machine(this.context);\n    this.api = accordion.connect(this.service.state, this.service.send, normalizeProps);\n\n    this.init();\n  },\n\n  beforeDestroy() {\n    this.service.stop();\n  },\n\n  init() {\n    const service = this.service;\n\n    this.render();\n    service.subscribe(() => {\n      this.api = accordion.connect(service.state, service.send, normalizeProps);\n      this.render();\n    });\n\n    service.start();\n  },\n\n  items() {\n    return Array.from(this.el.querySelectorAll(\"[data-element='item']\"));\n  },\n\n  render() {\n    spreadProps(this.el, this.api.rootProps);\n\n    this.items().forEach((item) => {\n      this.renderItem(item);\n    });\n  },\n\n  renderItem(item) {\n    const index = item.dataset.index;\n    if (!index) throw new Error(\"Expected index to be defined\");\n\n    const trigger = item.querySelector(\"[data-element='trigger']\");\n    const content = item.querySelector(\"[data-element='content']\");\n\n    if (!trigger) throw new Error(\"Expected trigger to be defined\");\n    if (!content) throw new Error(\"Expected content to be defined\");\n\n    spreadProps(item, this.api.getItemProps({ value: index }));\n    spreadProps(trigger, this.api.getItemTriggerProps({ value: index }));\n    spreadProps(content, this.api.getItemContentProps({ value: index }));\n  },\n};\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import type { AutoUpdateOptions, Middleware } from \"@floating-ui/dom\"\nimport { arrow, autoUpdate, computePosition, flip, limitShift, offset, shift, size } from \"@floating-ui/dom\"\nimport { getWindow, raf } from \"@zag-js/dom-query\"\nimport { compact, isNull, noop, runIfFn } from \"@zag-js/utils\"\nimport { getAnchorElement } from \"./get-anchor\"\nimport { rectMiddleware, shiftArrowMiddleware, transformOriginMiddleware } from \"./middleware\"\nimport { getPlacementDetails } from \"./placement\"\nimport type { MaybeElement, MaybeFn, MaybeRectElement, PositioningOptions } from \"./types\"\n\nconst defaultOptions: PositioningOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4,\n}\n\nfunction roundByDpr(win: Window, value: number) {\n  const dpr = win.devicePixelRatio || 1\n  return Math.round(value * dpr) / dpr\n}\n\nfunction getBoundaryMiddleware(opts: PositioningOptions) {\n  return runIfFn(opts.boundary)\n}\n\nfunction getArrowMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (!arrowElement) return\n  return arrow({\n    element: arrowElement,\n    padding: opts.arrowPadding,\n  })\n}\n\nfunction getOffsetMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (isNull(opts.offset ?? opts.gutter)) return\n  return offset(({ placement }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2\n\n    const gutter = opts.offset?.mainAxis ?? opts.gutter\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset\n\n    const { hasAlign } = getPlacementDetails(placement)\n    const shift = !hasAlign ? opts.shift : undefined\n    const crossAxis = opts.offset?.crossAxis ?? shift\n\n    return compact({\n      crossAxis: crossAxis,\n      mainAxis: mainAxis,\n      alignmentAxis: opts.shift,\n    })\n  })\n}\n\nfunction getFlipMiddleware(opts: PositioningOptions) {\n  if (!opts.flip) return\n  return flip({\n    boundary: getBoundaryMiddleware(opts),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? undefined : opts.flip,\n  })\n}\n\nfunction getShiftMiddleware(opts: PositioningOptions) {\n  if (!opts.slide && !opts.overlap) return\n  return shift({\n    boundary: getBoundaryMiddleware(opts),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift(),\n  })\n}\n\nfunction getSizeMiddleware(opts: PositioningOptions) {\n  return size({\n    padding: opts.overflowPadding,\n    apply({ elements, rects, availableHeight, availableWidth }) {\n      const floating = elements.floating\n\n      const referenceWidth = Math.round(rects.reference.width)\n      availableWidth = Math.floor(availableWidth)\n      availableHeight = Math.floor(availableHeight)\n\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`)\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`)\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`)\n    },\n  })\n}\n\nfunction getAutoUpdateOptions(opts?: boolean | AutoUpdateOptions): AutoUpdateOptions {\n  if (!opts) return {}\n  if (opts === true) {\n    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true }\n  }\n  return opts\n}\n\nfunction getPlacementImpl(referenceOrVirtual: MaybeRectElement, floating: MaybeElement, opts: PositioningOptions = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect)\n  if (!floating || !reference) return\n  const options = Object.assign({}, defaultOptions, opts)\n\n  /* -----------------------------------------------------------------------------\n   * The middleware stack\n   * -----------------------------------------------------------------------------*/\n\n  const arrowEl = floating.querySelector<HTMLElement>(\"[data-part=arrow]\")\n\n  const middleware: (Middleware | undefined)[] = [\n    getOffsetMiddleware(arrowEl, options),\n    getFlipMiddleware(options),\n    getShiftMiddleware(options),\n    getArrowMiddleware(arrowEl, options),\n    shiftArrowMiddleware(arrowEl),\n    transformOriginMiddleware,\n    getSizeMiddleware(options),\n    rectMiddleware,\n  ]\n\n  /* -----------------------------------------------------------------------------\n   * The actual positioning function\n   * -----------------------------------------------------------------------------*/\n\n  const { placement, strategy, onComplete, onPositioned } = options\n\n  const updatePosition = async () => {\n    if (!reference || !floating) return\n\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy,\n    })\n\n    onComplete?.(pos)\n    onPositioned?.({ placed: true })\n\n    const win = getWindow(floating)\n    const x = roundByDpr(win, pos.x)\n    const y = roundByDpr(win, pos.y)\n\n    floating.style.setProperty(\"--x\", `${x}px`)\n    floating.style.setProperty(\"--y\", `${y}px`)\n\n    const contentEl = floating.firstElementChild\n\n    if (contentEl) {\n      const zIndex = win.getComputedStyle(contentEl).zIndex\n      floating.style.setProperty(\"--z-index\", zIndex)\n    }\n  }\n\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({ updatePosition })\n      onPositioned?.({ placed: true })\n    } else {\n      await updatePosition()\n    }\n  }\n\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners)\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop\n\n  update()\n\n  return () => {\n    cancelAutoUpdate?.()\n    onPositioned?.({ placed: false })\n  }\n}\n\nexport function getPlacement(\n  referenceOrFn: MaybeFn<MaybeRectElement>,\n  floatingOrFn: MaybeFn<MaybeElement>,\n  opts: PositioningOptions & { defer?: boolean } = {},\n) {\n  const { defer, ...options } = opts\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn\n      cleanups.push(getPlacementImpl(reference, floating, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { isHTMLElement } from \"@zag-js/dom-query\"\nimport type { AnchorRect, MaybeRectElement } from \"./types\"\n\nexport function createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height)\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n  }\n  return { ...rect, toJSON: () => rect }\n}\n\nfunction getDOMRect(anchorRect?: AnchorRect | null) {\n  if (!anchorRect) return createDOMRect()\n  const { x, y, width, height } = anchorRect\n  return createDOMRect(x, y, width, height)\n}\n\nexport function getAnchorElement(\n  anchorElement: MaybeRectElement,\n  getAnchorRect?: (anchor: MaybeRectElement) => AnchorRect | null,\n) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : undefined,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement\n      const anchorRect = getAnchorRect?.(anchor)\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect)\n      }\n      return anchor.getBoundingClientRect()\n    },\n  }\n}\n", "import type { Coords, Middleware } from \"@floating-ui/dom\"\nimport type { PlacementSide } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Shared middleware utils\n * -----------------------------------------------------------------------------*/\n\nconst toVar = (value: string) => ({ variable: value, reference: `var(${value})` })\n\nexport const cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\"),\n}\n\n/* -----------------------------------------------------------------------------\n * Transform Origin Middleware\n * -----------------------------------------------------------------------------*/\n\nconst getTransformOrigin = (arrow?: Partial<Coords>) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow ? `${arrow.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow ? `${arrow.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow ? `${arrow.x}px top` : \"top left\",\n  \"bottom-end\": arrow ? `${arrow.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow ? `right ${arrow.y}px` : \"right top\",\n  \"left-end\": arrow ? `right ${arrow.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow ? `left ${arrow.y}px` : \"left top\",\n  \"right-end\": arrow ? `left ${arrow.y}px` : \"left bottom\",\n})\n\nexport const transformOriginMiddleware: Middleware = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow } = middlewareData\n    const transformOrigin = getTransformOrigin(arrow)[placement]\n\n    const { floating } = elements\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin)\n\n    return {\n      data: { transformOrigin },\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Rect Middleware (to expose the rect data)\n * -----------------------------------------------------------------------------*/\n\nexport const rectMiddleware: Middleware = {\n  name: \"rects\",\n  fn({ rects }) {\n    return {\n      data: rects,\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Arrow Middleware\n * -----------------------------------------------------------------------------*/\n\nexport const shiftArrowMiddleware = (arrowEl: HTMLElement | null): Middleware | undefined => {\n  if (!arrowEl) return\n  return {\n    name: \"shiftArrow\",\n    fn({ placement, middlewareData }) {\n      if (!middlewareData.arrow) return {}\n      const { x, y } = middlewareData.arrow\n      const dir = placement.split(\"-\")[0] as PlacementSide\n\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`,\n      })\n\n      return {}\n    },\n  }\n}\n", "import type { Placement } from \"@floating-ui/dom\"\nimport type { PlacementAlign, PlacementSide } from \"./types\"\n\nexport function isValidPlacement(v: string): v is Placement {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v)\n}\n\nexport function getPlacementDetails(placement: Placement) {\n  const [side, align] = placement.split(\"-\") as [PlacementSide, PlacementAlign | undefined]\n  return { side, align, hasAlign: align != null }\n}\n\nexport function getPlacementSide(placement: Placement): PlacementSide {\n  return placement.split(\"-\")[0] as PlacementSide\n}\n", "import type { Placement } from \"@floating-ui/dom\"\nimport { cssVars } from \"./middleware\"\nimport type { PositioningOptions } from \"./types\"\n\nexport interface GetPlacementStylesOptions {\n  placement?: Placement\n}\n\nconst ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\",\n} as const\n\nexport function getPlacementStyles(\n  options: Pick<PositioningOptions, \"placement\" | \"sameWidth\" | \"fitViewport\" | \"strategy\"> = {},\n) {\n  const { placement, sameWidth, fitViewport, strategy = \"absolute\" } = options\n\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`,\n    } as const,\n\n    arrowTip: {\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : undefined,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\",\n    } as const,\n\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? undefined : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : undefined,\n      maxWidth: fitViewport ? \"var(--available-width)\" : undefined,\n      maxHeight: fitViewport ? \"var(--available-height)\" : undefined,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\",\n    } as const,\n  }\n}\n", "import { addDomEvent, fireCustomEvent, isContextMenuEvent } from \"@zag-js/dom-event\"\nimport { contains, getDocument, getEventTarget, getWindow, isFocusable, isHTMLElement, raf } from \"@zag-js/dom-query\"\nimport { callAll } from \"@zag-js/utils\"\nimport { getWindowFrames } from \"./get-window-frames\"\n\nexport interface InteractOutsideHandlers {\n  /**\n   * Function called when the pointer is pressed down outside the component\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void\n  /**\n   * Function called when the focus is moved outside the component\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void\n  /**\n   * Function called when an interaction happens outside the component\n   */\n  onInteractOutside?: (event: InteractOutsideEvent) => void\n}\n\nexport interface InteractOutsideOptions extends InteractOutsideHandlers {\n  exclude?: (target: HTMLElement) => boolean\n  defer?: boolean\n}\n\nexport interface EventDetails<T> {\n  originalEvent: T\n  contextmenu: boolean\n  focusable: boolean\n}\n\nconst POINTER_OUTSIDE_EVENT = \"pointerdown.outside\"\nconst FOCUS_OUTSIDE_EVENT = \"focus.outside\"\n\nexport type PointerDownOutsideEvent = CustomEvent<EventDetails<PointerEvent>>\n\nexport type FocusOutsideEvent = CustomEvent<EventDetails<FocusEvent>>\n\nexport type InteractOutsideEvent = PointerDownOutsideEvent | FocusOutsideEvent\n\nexport type MaybeElement = HTMLElement | null | undefined\nexport type NodeOrFn = MaybeElement | (() => MaybeElement)\n\nfunction isComposedPathFocusable(composedPath: EventTarget[]) {\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node)) return true\n  }\n  return false\n}\n\nconst isPointerEvent = (event: Event): event is PointerEvent => \"clientY\" in event\n\nfunction isEventPointWithin(node: MaybeElement, event: Event) {\n  if (!isPointerEvent(event) || !node) return false\n\n  const rect = node.getBoundingClientRect()\n  if (rect.width === 0 || rect.height === 0) return false\n\n  return (\n    rect.top <= event.clientY &&\n    event.clientY <= rect.top + rect.height &&\n    rect.left <= event.clientX &&\n    event.clientX <= rect.left + rect.width\n  )\n}\n\nfunction isEventWithinScrollbar(event: Event): boolean {\n  const target = getEventTarget<HTMLElement>(event)\n  if (!target || !isPointerEvent(event)) return false\n\n  const isScrollableY = target.scrollHeight > target.clientHeight\n  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth\n\n  const isScrollableX = target.scrollWidth > target.clientWidth\n  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight\n\n  return onScrollbarY || onScrollbarX\n}\n\nfunction trackInteractOutsideImpl(node: MaybeElement, options: InteractOutsideOptions) {\n  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options\n\n  if (!node) return\n\n  const doc = getDocument(node)\n  const win = getWindow(node)\n  const frames = getWindowFrames(win)\n\n  function isEventOutside(event: Event): boolean {\n    const target = getEventTarget(event)\n    if (!isHTMLElement(target)) return false\n    if (contains(node, target)) return false\n    if (isEventPointWithin(node, event)) return false\n    if (isEventWithinScrollbar(event)) return false\n    return !exclude?.(target)\n  }\n\n  let clickHandler: VoidFunction\n\n  function onPointerDown(event: PointerEvent) {\n    //\n    function handler() {\n      const func = defer ? raf : (v: any) => v()\n      const composedPath = event.composedPath?.() ?? [event.target]\n      func(() => {\n        if (!node || !isEventOutside(event)) return\n\n        if (onPointerDownOutside || onInteractOutside) {\n          const handler = callAll(onPointerDownOutside, onInteractOutside) as EventListener\n          node.addEventListener(POINTER_OUTSIDE_EVENT, handler, { once: true })\n        }\n\n        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n          bubbles: false,\n          cancelable: true,\n          detail: {\n            originalEvent: event,\n            contextmenu: isContextMenuEvent(event),\n            focusable: isComposedPathFocusable(composedPath),\n          },\n        })\n      })\n    }\n\n    if (event.pointerType === \"touch\") {\n      frames.removeEventListener(\"click\", handler)\n      doc.removeEventListener(\"click\", handler)\n\n      clickHandler = handler\n\n      doc.addEventListener(\"click\", handler, { once: true })\n      frames.addEventListener(\"click\", handler, { once: true })\n    } else {\n      handler()\n    }\n  }\n  const cleanups = new Set<VoidFunction>()\n\n  const timer = setTimeout(() => {\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true))\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true))\n  }, 0)\n\n  function onFocusin(event: FocusEvent) {\n    //\n    const func = defer ? raf : (v: any) => v()\n    func(() => {\n      if (!node || !isEventOutside(event)) return\n\n      if (onFocusOutside || onInteractOutside) {\n        const handler = callAll(onFocusOutside, onInteractOutside) as EventListener\n        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true })\n      }\n\n      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: false,\n          focusable: isFocusable(getEventTarget(event)),\n        },\n      })\n    })\n  }\n\n  cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true))\n  cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true))\n\n  return () => {\n    clearTimeout(timer)\n    if (clickHandler) {\n      frames.removeEventListener(\"click\", clickHandler)\n      doc.removeEventListener(\"click\", clickHandler)\n    }\n    cleanups.forEach((fn) => fn())\n  }\n}\n\nexport function trackInteractOutside(nodeOrFn: NodeOrFn, options: InteractOutsideOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(trackInteractOutsideImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "export function getWindowFrames(win: Window) {\n  const frames = {\n    each(cb: (win: Window) => void) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i]\n        if (frame) cb(frame)\n      }\n    },\n    addEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.addEventListener(event, listener, options)\n        } catch {}\n      })\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options)\n        } catch {}\n      }\n    },\n    removeEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.removeEventListener(event, listener, options)\n        } catch {}\n      })\n    },\n  }\n  return frames\n}\n", "import { contains, getEventTarget, isHTMLElement, raf } from \"@zag-js/dom-query\"\nimport {\n  trackInteractOutside,\n  type FocusOutsideEvent,\n  type InteractOutsideHandlers,\n  type PointerDownOutsideEvent,\n} from \"@zag-js/interact-outside\"\nimport { isFunction, warn, type MaybeFunction } from \"@zag-js/utils\"\nimport { trackEscapeKeydown } from \"./escape-keydown\"\nimport { layerStack, type Layer } from \"./layer-stack\"\nimport { assignPointerEventToLayers, clearPointerEvent, disablePointerEventsOutside } from \"./pointer-event-outside\"\n\ntype MaybeElement = HTMLElement | null\ntype Container = MaybeElement | Array<MaybeElement>\ntype NodeOrFn = MaybeFunction<MaybeElement>\n\nexport interface DismissableElementHandlers extends InteractOutsideHandlers {\n  /**\n   * Function called when the escape key is pressed\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void\n}\n\nexport interface PersistentElementOptions {\n  /**\n   * Returns the persistent elements that:\n   * - should not have pointer-events disabled\n   * - should not trigger the dismiss event\n   */\n  persistentElements?: Array<() => Element | null>\n}\n\nexport interface DismissableElementOptions extends DismissableElementHandlers, PersistentElementOptions {\n  /**\n   * Whether to log debug information\n   */\n  debug?: boolean\n  /**\n   * Whether to block pointer events outside the dismissable element\n   */\n  pointerBlocking?: boolean\n  /**\n   * Function called when the dismissable element is dismissed\n   */\n  onDismiss: VoidFunction\n  /**\n   * Exclude containers from the interact outside event\n   */\n  exclude?: MaybeFunction<Container>\n  /**\n   * Defer the interact outside event to the next frame\n   */\n  defer?: boolean\n}\n\nfunction trackDismissableElementImpl(node: MaybeElement, options: DismissableElementOptions) {\n  if (!node) {\n    warn(\"[@zag-js/dismissable] node is `null` or `undefined`\")\n    return\n  }\n\n  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options\n\n  const layer: Layer = { dismiss: onDismiss, node, pointerBlocking }\n\n  layerStack.add(layer)\n  assignPointerEventToLayers()\n\n  function onPointerDownOutside(event: PointerDownOutsideEvent) {\n    const target = getEventTarget(event.detail.originalEvent)\n    if (layerStack.isBelowPointerBlockingLayer(node!) || layerStack.isInBranch(target)) return\n    options.onPointerDownOutside?.(event)\n    options.onInteractOutside?.(event)\n    if (event.defaultPrevented) return\n    if (debug) {\n      console.log(\"onPointerDownOutside:\", event.detail.originalEvent)\n    }\n    onDismiss?.()\n  }\n\n  function onFocusOutside(event: FocusOutsideEvent) {\n    const target = getEventTarget(event.detail.originalEvent)\n    if (layerStack.isInBranch(target)) return\n    options.onFocusOutside?.(event)\n    options.onInteractOutside?.(event)\n    if (event.defaultPrevented) return\n    if (debug) {\n      console.log(\"onFocusOutside:\", event.detail.originalEvent)\n    }\n    onDismiss?.()\n  }\n\n  function onEscapeKeyDown(event: KeyboardEvent) {\n    if (!layerStack.isTopMost(node!)) return\n    options.onEscapeKeyDown?.(event)\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault()\n      onDismiss()\n    }\n  }\n\n  function exclude(target: Element) {\n    if (!node) return false\n    const containers = typeof excludeContainers === \"function\" ? excludeContainers() : excludeContainers\n    const _containers = Array.isArray(containers) ? containers : [containers]\n    const persistentElements = options.persistentElements?.map((fn) => fn()).filter(isHTMLElement)\n    if (persistentElements) _containers.push(...persistentElements)\n    return _containers.some((node) => contains(node, target)) || layerStack.isInNestedLayer(node, target)\n  }\n\n  const cleanups = [\n    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : undefined,\n    trackEscapeKeydown(node, onEscapeKeyDown),\n    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer }),\n  ]\n\n  return () => {\n    layerStack.remove(node!)\n    // re-assign pointer event to remaining layers\n    assignPointerEventToLayers()\n    // remove pointer event from removed layer\n    clearPointerEvent(node!)\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n\nexport function trackDismissableElement(nodeOrFn: NodeOrFn, options: DismissableElementOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn\n      cleanups.push(trackDismissableElementImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n\nexport function trackDismissableBranch(nodeOrFn: NodeOrFn, options: { defer?: boolean } = {}) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n\n  cleanups.push(\n    func(() => {\n      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn\n      if (!node) {\n        warn(\"[@zag-js/dismissable] branch node is `null` or `undefined`\")\n        return\n      }\n      layerStack.addBranch(node)\n      cleanups.push(() => {\n        layerStack.removeBranch(node)\n      })\n    }),\n  )\n\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { addDomEvent } from \"@zag-js/dom-event\"\nimport { getDocument } from \"@zag-js/dom-query\"\n\nexport function trackEscapeKeydown(node: HTMLElement, fn?: (event: KeyboardEvent) => void) {\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (event.key !== \"Escape\") return\n    if (event.isComposing) return\n    fn?.(event)\n  }\n\n  return addDomEvent(getDocument(node), \"keydown\", handleKeyDown, { capture: true })\n}\n", "import { contains } from \"@zag-js/dom-query\"\n\nexport interface Layer {\n  dismiss: VoidFunction\n  node: HTMLElement\n  pointerBlocking?: boolean\n}\n\nexport const layerStack = {\n  layers: [] as Layer[],\n  branches: [] as HTMLElement[],\n  count(): number {\n    return this.layers.length\n  },\n  pointerBlockingLayers(): Layer[] {\n    return this.layers.filter((layer) => layer.pointerBlocking)\n  },\n  topMostPointerBlockingLayer(): Layer | undefined {\n    return [...this.pointerBlockingLayers()].slice(-1)[0]\n  },\n  hasPointerBlockingLayer(): boolean {\n    return this.pointerBlockingLayers().length > 0\n  },\n  isBelowPointerBlockingLayer(node: HTMLElement) {\n    const index = this.indexOf(node)\n    const highestBlockingIndex = this.topMostPointerBlockingLayer()\n      ? this.indexOf(this.topMostPointerBlockingLayer()?.node)\n      : -1\n    return index < highestBlockingIndex\n  },\n  isTopMost(node: HTMLElement | null) {\n    const layer = this.layers[this.count() - 1]\n    return layer?.node === node\n  },\n  getNestedLayers(node: HTMLElement) {\n    return Array.from(this.layers).slice(this.indexOf(node) + 1)\n  },\n  isInNestedLayer(node: HTMLElement, target: HTMLElement | EventTarget | null) {\n    return this.getNestedLayers(node).some((layer) => contains(layer.node, target))\n  },\n  isInBranch(target: HTMLElement | EventTarget | null) {\n    return Array.from(this.branches).some((branch) => contains(branch, target))\n  },\n  add(layer: Layer) {\n    const num = this.layers.push(layer)\n    layer.node.style.setProperty(\"--layer-index\", `${num}`)\n  },\n  addBranch(node: HTMLElement) {\n    this.branches.push(node)\n  },\n  remove(node: HTMLElement) {\n    const index = this.indexOf(node)\n    if (index < 0) return\n\n    // dismiss nested layers\n    if (index < this.count() - 1) {\n      const _layers = this.getNestedLayers(node)\n      _layers.forEach((layer) => layer.dismiss())\n    }\n    // remove this layer\n    this.layers.splice(index, 1)\n    node.style.removeProperty(\"--layer-index\")\n  },\n  removeBranch(node: HTMLElement) {\n    const index = this.branches.indexOf(node)\n    if (index >= 0) this.branches.splice(index, 1)\n  },\n  indexOf(node: HTMLElement | undefined) {\n    return this.layers.findIndex((layer) => layer.node === node)\n  },\n  dismiss(node: HTMLElement) {\n    this.layers[this.indexOf(node)]?.dismiss()\n  },\n  clear() {\n    this.remove(this.layers[0].node)\n  },\n}\n", "import { getDocument, setStyle, waitForElements } from \"@zag-js/dom-query\"\nimport { layerStack } from \"./layer-stack\"\n\nlet originalBodyPointerEvents: string\n\nexport function assignPointerEventToLayers() {\n  layerStack.layers.forEach(({ node }) => {\n    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? \"none\" : \"auto\"\n  })\n}\n\nexport function clearPointerEvent(node: HTMLElement) {\n  node.style.pointerEvents = \"\"\n}\n\nexport function disablePointerEventsOutside(node: HTMLElement, peristentElements?: Array<() => Element | null>) {\n  const doc = getDocument(node)\n\n  const cleanups: VoidFunction[] = []\n\n  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute(\"data-inert\")) {\n    originalBodyPointerEvents = document.body.style.pointerEvents\n    queueMicrotask(() => {\n      doc.body.style.pointerEvents = \"none\"\n      doc.body.setAttribute(\"data-inert\", \"\")\n    })\n  }\n\n  if (peristentElements) {\n    const persistedCleanup = waitForElements(peristentElements, (el) => {\n      cleanups.push(setStyle(el, { pointerEvents: \"auto\" }))\n    })\n    cleanups.push(persistedCleanup)\n  }\n\n  return () => {\n    if (layerStack.hasPointerBlockingLayer()) return\n    queueMicrotask(() => {\n      doc.body.style.pointerEvents = originalBodyPointerEvents\n      doc.body.removeAttribute(\"data-inert\")\n      if (doc.body.style.length === 0) doc.body.removeAttribute(\"style\")\n    })\n    cleanups.forEach((fn) => fn())\n  }\n}\n", "import type { Point } from \"./types\"\n\nexport class AffineTransform {\n  m00: number\n  m01: number\n  m02: number\n  m10: number\n  m11: number\n  m12: number\n\n  constructor([m00, m01, m02, m10, m11, m12]: Iterable<number> = [0, 0, 0, 0, 0, 0]) {\n    this.m00 = m00\n    this.m01 = m01\n    this.m02 = m02\n    this.m10 = m10\n    this.m11 = m11\n    this.m12 = m12\n  }\n\n  applyTo(point: Point): Point {\n    const { x, y } = point\n    const { m00, m01, m02, m10, m11, m12 } = this\n\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12,\n    }\n  }\n\n  prepend(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10, // m00\n      this.m00 * other.m01 + this.m01 * other.m11, // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02, // m02\n      this.m10 * other.m00 + this.m11 * other.m10, // m10\n      this.m10 * other.m01 + this.m11 * other.m11, // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12, // m12\n    ])\n  }\n\n  append(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10, // m00\n      other.m00 * this.m01 + other.m01 * this.m11, // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02, // m02\n      other.m10 * this.m00 + other.m11 * this.m10, // m10\n      other.m10 * this.m01 + other.m11 * this.m11, // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12, // m12\n    ])\n  }\n\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10\n  }\n\n  get isInvertible() {\n    const det = this.determinant\n\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0\n  }\n\n  invert() {\n    const det = this.determinant\n\n    return new AffineTransform([\n      this.m11 / det, // m00\n      -this.m01 / det, // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det, // m02\n      -this.m10 / det, // m10\n      this.m00 / det, // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det, // m12\n    ])\n  }\n\n  get array(): number[] {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1]\n  }\n\n  get float32Array(): Float32Array {\n    return new Float32Array(this.array)\n  }\n\n  // Static\n\n  static get identity(): AffineTransform {\n    return new AffineTransform([1, 0, 0, 0, 1, 0])\n  }\n\n  static rotate(theta: number, origin?: Point): AffineTransform {\n    const rotation = new AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0])\n\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return rotation\n  }\n\n  rotate: (typeof AffineTransform)[\"rotate\"] = (...args) => {\n    return this.prepend(AffineTransform.rotate(...args))\n  }\n\n  static scale(sx: number, sy: number = sx, origin: Point = { x: 0, y: 0 }): AffineTransform {\n    const scale = new AffineTransform([sx, 0, 0, 0, sy, 0])\n\n    if (origin.x !== 0 || origin.y !== 0) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        scale,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return scale\n  }\n\n  scale: (typeof AffineTransform)[\"scale\"] = (...args) => {\n    return this.prepend(AffineTransform.scale(...args))\n  }\n\n  static translate(tx: number, ty: number): AffineTransform {\n    return new AffineTransform([1, 0, tx, 0, 1, ty])\n  }\n\n  translate: (typeof AffineTransform)[\"translate\"] = (...args) => {\n    return this.prepend(AffineTransform.translate(...args))\n  }\n\n  static multiply(...[first, ...rest]: AffineTransform[]): AffineTransform {\n    if (!first) return AffineTransform.identity\n    return rest.reduce((result, item) => result.prepend(item), first)\n  }\n\n  get a() {\n    return this.m00\n  }\n\n  get b() {\n    return this.m10\n  }\n\n  get c() {\n    return this.m01\n  }\n\n  get d() {\n    return this.m11\n  }\n\n  get tx() {\n    return this.m02\n  }\n\n  get ty() {\n    return this.m12\n  }\n\n  get scaleComponents(): Point {\n    return { x: this.a, y: this.d }\n  }\n\n  get translationComponents(): Point {\n    return { x: this.tx, y: this.ty }\n  }\n\n  get skewComponents(): Point {\n    return { x: this.c, y: this.b }\n  }\n\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`\n  }\n}\n", "import type { AlignOptions, HAlign, Rect, VAlign } from \"./types\"\n\nfunction hAlign(a: Rect, ref: Rect, h: HAlign): Rect {\n  let x = ref.minX\n  if (h === \"left-inside\") x = ref.minX\n  if (h === \"left-outside\") x = ref.minX - ref.width\n  if (h === \"right-inside\") x = ref.maxX - ref.width\n  if (h === \"right-outside\") x = ref.maxX\n  if (h === \"center\") x = ref.midX - ref.width / 2\n  return { ...a, x }\n}\n\nfunction vAlign(a: Rect, ref: Rect, v: VAlign): Rect {\n  let y = ref.minY\n  if (v === \"top-inside\") y = ref.minY\n  if (v === \"top-outside\") y = ref.minY - a.height\n  if (v === \"bottom-inside\") y = ref.maxY - a.height\n  if (v === \"bottom-outside\") y = ref.maxY\n  if (v === \"center\") y = ref.midY - a.height / 2\n  return { ...a, y }\n}\n\nexport function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect {\n  const { h, v } = options\n  return vAlign(hAlign(a, ref, h), ref, v)\n}\n", "import type { Point, RectInit, Size } from \"./types\"\n\nconst clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max)\n\nexport const clampPoint = (position: Point, size: Size, boundaryRect: RectInit) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width)\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height)\n  return { x, y }\n}\n\nconst defaultMinSize: Size = {\n  width: 0,\n  height: 0,\n}\n\nconst defaultMaxSize: Size = {\n  width: Infinity,\n  height: Infinity,\n}\n\nexport const clampSize = (size: Size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize!.width), maxSize!.width),\n    height: Math.min(Math.max(size.height, minSize!.height), maxSize!.height),\n  }\n}\n", "import type { Point, Rect, RectEdge, RectInit } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Point\n * -----------------------------------------------------------------------------*/\n\nexport const createPoint = (x: number, y: number) => ({ x, y })\n\nexport const subtractPoints = (a: Point, b: Point) => createPoint(a.x - b.x, a.y - b.y)\nexport const addPoints = (a: Point, b: Point) => createPoint(a.x + b.x, a.y + b.y)\n\nexport function isPoint(v: any): v is Point {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\")\n}\n\n/* -----------------------------------------------------------------------------\n * Rect\n * -----------------------------------------------------------------------------*/\n\nexport function createRect(r: RectInit): Rect {\n  const { x, y, width, height } = r\n  const midX = x + width / 2\n  const midY = y + height / 2\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY),\n  }\n}\n\nexport function isRect(v: any): v is Rect {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\")\n}\n\nexport function getRectCenters(v: Rect) {\n  const top = createPoint(v.midX, v.minY)\n  const right = createPoint(v.maxX, v.midY)\n  const bottom = createPoint(v.midX, v.maxY)\n  const left = createPoint(v.minX, v.midY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectCorners(v: Rect) {\n  const top = createPoint(v.minX, v.minY)\n  const right = createPoint(v.maxX, v.minY)\n  const bottom = createPoint(v.maxX, v.maxY)\n  const left = createPoint(v.minX, v.maxY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectEdges(v: Rect) {\n  const c = getRectCorners(v)\n  const top: RectEdge = [c.top, c.right]\n  const right: RectEdge = [c.right, c.bottom]\n  const bottom: RectEdge = [c.left, c.bottom]\n  const left: RectEdge = [c.top, c.left]\n  return { top, right, bottom, left }\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect, RectSide } from \"./types\"\n\n/**\n * Checks if a Rect intersects another Rect\n */\nexport function intersects(a: Rect, b: Rect): boolean {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y\n}\n\n/**\n * Returns a new Rect that represents the intersection between two Rects\n */\nexport function intersection(a: Rect, b: Rect): Rect {\n  const x = Math.max(a.x, b.x)\n  const y = Math.max(a.y, b.y)\n  const x2 = Math.min(a.x + a.width, b.x + b.width)\n  const y2 = Math.min(a.y + a.height, b.y + b.height)\n  return createRect({ x, y, width: x2 - x, height: y2 - y })\n}\n\n/**\n * Returns whether two rects collide along each edge\n */\nexport function collisions(a: Rect, b: Rect): Record<RectSide, boolean> {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX,\n  }\n}\n", "import { intersects } from \"./intersection\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport interface DistanceValue extends Point {\n  value: number\n}\n\nexport function distance(a: Point, b: Point = { x: 0, y: 0 }): number {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nexport function distanceFromPoint(r: Rect, p: Point): DistanceValue {\n  let x = 0\n  let y = 0\n\n  if (p.x < r.x) x = r.x - p.x\n  else if (p.x > r.maxX) x = p.x - r.maxX\n\n  if (p.y < r.y) y = r.y - p.y\n  else if (p.y > r.maxY) y = p.y - r.maxY\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceFromRect(a: Rect, b: Rect): DistanceValue {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 }\n  const left = a.x < b.x ? a : b\n  const right = b.x < a.x ? a : b\n  const upper = a.y < b.y ? a : b\n  const lower = b.y < a.y ? a : b\n  let x = left.x === right.x ? 0 : right.x - left.maxX\n  x = Math.max(0, x)\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY\n  y = Math.max(0, y)\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number> {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY,\n  }\n}\n", "import { distance } from \"./distance\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport function closest(...pts: Point[]) {\n  return (a: Point): Point => {\n    const ds = pts.map((b) => distance(b, a))\n    const c = Math.min.apply(Math, ds)\n    return pts[ds.indexOf(c)]\n  }\n}\n\nexport function closestSideToRect(ref: Rect, r: Rect): RectSide {\n  if (r.maxX <= ref.minX) return \"left\"\n  if (r.minX >= ref.maxX) return \"right\"\n  if (r.maxY <= ref.minY) return \"top\"\n  if (r.minY >= ref.maxY) return \"bottom\"\n  return \"left\"\n}\n\nexport function closestSideToPoint(ref: Rect, p: Point): RectSide {\n  const { x, y } = p\n\n  const dl = x - ref.minX\n  const dr = ref.maxX - x\n  const dt = y - ref.minY\n  const db = ref.maxY - y\n\n  let closest = dl\n  let side: RectSide = \"left\"\n\n  if (dr < closest) {\n    closest = dr\n    side = \"right\"\n  }\n  if (dt < closest) {\n    closest = dt\n    side = \"top\"\n  }\n  if (db < closest) {\n    side = \"bottom\"\n  }\n\n  return side\n}\n", "import type { RectInit } from \"./types\"\n\n// given a rect and a boundary, return a new rect that is constrained within the boundary\n// resize or reposition the rect so that it fits within the boundary\nexport const constrainRect = (rect: RectInit, boundary: RectInit): RectInit => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width))\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height))\n\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height),\n  }\n}\n", "import { getRectCorners, isRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function containsPoint(r: Rect, p: Point): boolean {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY\n}\n\nexport function containsRect(a: Rect, b: Rect): boolean {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c))\n}\n\nexport function contains(r: Rect, v: Rect | Point): boolean {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v)\n}\n", "import type { Point, RectInit, Size } from \"./types\"\n\nexport const isSizeEqual = (a: Size, b: Size) => {\n  return a.width === b.width && a.height === b.height\n}\n\nexport const isPointEqual = (a: Point, b: Point) => {\n  return a.x === b.x && a.y === b.y\n}\n\nexport const isRectEqual = (a: RectInit, b: RectInit) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b)\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nfunction getCacheComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n\nexport function getElementRect(el: HTMLElement, opts: ElementRectOptions = {}): Rect {\n  return createRect(getClientRect(el, opts))\n}\n\nexport type ElementRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n  /**\n   * Whether to exclude the element's borders from the calculation.\n   */\n  excludeBorders?: boolean\n}\n\nfunction getClientRect(el: HTMLElement, opts: ElementRectOptions = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts\n\n  const { x, y, width, height } = el.getBoundingClientRect()\n  const r = { x, y, width, height }\n\n  const style = getCacheComputedStyle(el)\n\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style\n\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth)\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth)\n\n  if (excludeBorders) {\n    r.width -= borderXWidth\n    r.height -= borderYWidth\n    r.x += px(borderLeftWidth)\n    r.y += px(borderTopWidth)\n  }\n\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth\n    r.width -= scrollbarWidth\n    r.height -= scrollbarHeight\n  }\n\n  return r\n}\n\nconst px = (v: string) => parseFloat(v.replace(\"px\", \"\"))\n\nconst sum = (...vals: string[]) => vals.reduce((sum, v) => sum + (v ? px(v) : 0), 0)\n", "import { createRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function getRectFromPoints(...pts: Point[]): Rect {\n  const xs = pts.map((p) => p.x)\n  const ys = pts.map((p) => p.y)\n\n  const x = Math.min(...xs)\n  const y = Math.min(...ys)\n\n  const width = Math.max(...xs) - x\n  const height = Math.max(...ys) - y\n\n  return createRect({ x, y, width, height })\n}\n", "import { getRectFromPoints } from \"./from-points\"\nimport type { Rect } from \"./types\"\n\nconst { min, max } = Math\n\nexport function union(...rs: Rect[]): Rect {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY)),\n  }\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY)),\n  }\n  return getRectFromPoints(pMin, pMax)\n}\n", "import { createRect } from \"./rect\"\nimport { getElementRect } from \"./from-element\"\nimport { union } from \"./union\"\nimport type { Rect } from \"./types\"\n\nexport function fromRange(range: Range): Rect {\n  let rs: Rect[] = []\n  const rects = Array.from(range.getClientRects())\n\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect))\n    return union.apply(undefined, rs)\n  }\n\n  let start: Node | ParentNode | null = range.startContainer\n\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode\n  }\n\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start)\n    rs.push({ ...r, x: r.maxX, width: 0 })\n  }\n\n  return union.apply(undefined, rs)\n}\n", "import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function toRad(d: number) {\n  return ((d % 360) * Math.PI) / 180\n}\n\nexport function rotate(a: Point, d: number, c: Point): Point {\n  const r = toRad(d)\n\n  const sin = Math.sin(r)\n  const cos = Math.cos(r)\n\n  const x = a.x - c.x\n  const y = a.y - c.y\n\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos,\n  }\n}\n\nexport function getRotationRect(r: Rect, deg: number): Rect {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center))\n\n  const xs = rr.map((p) => p.x)\n  const ys = rr.map((p) => p.y)\n\n  const minX = Math.min(...xs)\n  const minY = Math.min(...ys)\n\n  const maxX = Math.max(...xs)\n  const maxY = Math.max(...ys)\n\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  })\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nexport type WindowRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n}\n\n/**\n * Creates a rectange from window object\n */\nexport function getWindowRect(win: Window, opts: WindowRectOptions = {}): Rect {\n  return createRect(getViewportRect(win, opts))\n}\n\n/**\n * Get the rect of the window with the option to exclude the scrollbar\n */\nexport function getViewportRect(win: Window, opts: WindowRectOptions) {\n  const { excludeScrollbar = false } = opts\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win\n  const width = visualViewport?.width || innerWidth\n  const height = visualViewport?.height || innerHeight\n  const rect = { x: 0, y: 0, width, height }\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight\n    rect.width -= scrollbarWidth\n    rect.height -= scrollbarHeight\n  }\n  return rect\n}\n", "import { createRect } from \"./rect\"\nimport type { Point, Rect, RectInset, SymmetricRectInset } from \"./types\"\n\nexport const isSymmetric = (v: any): v is SymmetricRectInset => \"dx\" in v || \"dy\" in v\n\nexport function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom,\n  })\n}\n\nexport function expand(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shrink(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shift(r: Rect, o: Partial<Point>): Rect {\n  const { x = 0, y = 0 } = o\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height,\n  })\n}\n", "import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, RectInit } from \"./types\"\n\nexport function getElementPolygon(rectValue: RectInit, placement: string) {\n  const rect = createRect(rectValue)\n  const { top, right, left, bottom } = getRectCorners(rect)\n  const [base] = placement.split(\"-\")\n\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom],\n  }[base]\n}\n\nexport function isPointInPolygon(polygon: Point[], point: Point) {\n  const { x, y } = point\n  let c = false\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      c = !c\n    }\n  }\n  return c\n}\n\nfunction createPolygonElement() {\n  const id = \"debug-polygon\"\n  const existingPolygon = document.getElementById(id)\n  if (existingPolygon) {\n    return existingPolygon\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\",\n  })\n\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\")\n  polygon.setAttribute(\"id\", id)\n  polygon.setAttribute(\"points\", \"0,0 0,0\")\n  svg.appendChild(polygon)\n  document.body.appendChild(svg)\n  return polygon\n}\n\nexport function debugPolygon(polygon: Point[]) {\n  const el = createPolygonElement()\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \")\n  el.setAttribute(\"points\", points)\n  return () => {\n    el.remove()\n  }\n}\n", "import type { Point } from \"./types\"\n\nexport type CompassDirection = \"n\" | \"ne\" | \"e\" | \"se\" | \"s\" | \"sw\" | \"w\" | \"nw\"\n\nexport const compassDirectionMap: Record<CompassDirection, Point> = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 },\n}\n\nexport const oppositeDirectionMap: Record<CompassDirection, CompassDirection> = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\",\n}\n", "import { AffineTransform } from \"./affine-transform\"\nimport { compassDirectionMap, oppositeDirectionMap, type CompassDirection } from \"./compass\"\nimport type { Point, Rect, RectInit, ScalingOptions } from \"./types\"\n\nconst { sign, abs, min } = Math\n\nfunction getRectExtentPoint(rect: Rect, direction: CompassDirection) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY\n  return { x, y }\n}\n\nfunction getOppositeDirection(direction: CompassDirection) {\n  return oppositeDirectionMap[direction]\n}\n\nexport function resizeRect(rect: Rect, offset: Point, direction: CompassDirection, opts: ScalingOptions) {\n  const { scalingOriginMode, lockAspectRatio } = opts\n\n  const extent = getRectExtentPoint(rect, direction)\n\n  const oppositeDirection = getOppositeDirection(direction)\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection)\n\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 }\n  }\n\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y,\n  }\n\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1,\n  }\n\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y,\n  }\n\n  const scaleX = (multiplier.x * newSize.width) / rect.width\n  const scaleY = (multiplier.y * newSize.height) / rect.height\n\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY\n\n  const scale = lockAspectRatio\n    ? { x: largestMagnitude, y: largestMagnitude }\n    : {\n        x: extent.x === oppositeExtent.x ? 1 : scaleX,\n        y: extent.y === oppositeExtent.y ? 1 : scaleY,\n      }\n\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y)\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1\n  }\n\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x)\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1\n  }\n\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false)\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY,\n        }),\n        false,\n      )\n  }\n}\n\nfunction createRectFromPoints(initialPoint: Point, finalPoint: Point, normalized: boolean = true): RectInit {\n  if (normalized) {\n    return {\n      x: min(finalPoint.x, initialPoint.x),\n      y: min(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y),\n    }\n  }\n\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y,\n  }\n}\n\nfunction transformRect(rect: Rect, transform: AffineTransform, normalized = true): RectInit {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY })\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY })\n  return createRectFromPoints(p1, p2, normalized)\n}\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"menu\").parts(\n  \"arrow\",\n  \"arrowTip\",\n  \"content\",\n  \"contextTrigger\",\n  \"indicator\",\n  \"item\",\n  \"itemGroup\",\n  \"itemGroupLabel\",\n  \"itemIndicator\",\n  \"itemText\",\n  \"positioner\",\n  \"separator\",\n  \"trigger\",\n  \"triggerItem\",\n)\nexport const parts = anatomy.build()\n", "import { mergeProps } from \"@zag-js/core\"\nimport {\n  clickIfLink,\n  getEventKey,\n  getEventPoint,\n  getNativeEvent,\n  isContextMenuEvent,\n  isLeftClick,\n  isModifierKey,\n  isPrintableKey,\n  type EventKeyMap,\n} from \"@zag-js/dom-event\"\nimport {\n  dataAttr,\n  getEventTarget,\n  isDownloadingEvent,\n  isEditableElement,\n  isOpeningInNewTab,\n  isSelfTarget,\n  isValidTabEvent,\n} from \"@zag-js/dom-query\"\nimport { getPlacementStyles } from \"@zag-js/popper\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./menu.anatomy\"\nimport { dom } from \"./menu.dom\"\nimport type { ItemProps, ItemState, MachineApi, OptionItemProps, OptionItemState, Send, State } from \"./menu.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const isSubmenu = state.context.isSubmenu\n  const isTypingAhead = state.context.isTypingAhead\n  const composite = state.context.composite\n\n  const open = state.hasTag(\"open\")\n\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.anchorPoint ? \"bottom\" : state.context.currentPlacement,\n  })\n\n  function getItemState(props: ItemProps): ItemState {\n    return {\n      disabled: !!props.disabled,\n      highlighted: state.context.highlightedValue === props.value,\n    }\n  }\n\n  function getOptionItemProps(props: OptionItemProps) {\n    const valueText = props.valueText ?? props.value\n    return { ...props, id: props.value, valueText }\n  }\n\n  function getOptionItemState(props: OptionItemProps): OptionItemState {\n    const itemState = getItemState(getOptionItemProps(props))\n    return {\n      ...itemState,\n      checked: !!props.checked,\n    }\n  }\n\n  function getItemProps(props: ItemProps) {\n    const { value: id, closeOnSelect, valueText } = props\n    const itemState = getItemState(props)\n    return normalize.element({\n      ...parts.item.attrs,\n      id,\n      role: \"menuitem\",\n      \"aria-disabled\": itemState.disabled,\n      \"data-disabled\": dataAttr(itemState.disabled),\n      \"data-ownedby\": dom.getContentId(state.context),\n      \"data-highlighted\": dataAttr(itemState.highlighted),\n      \"data-valuetext\": valueText,\n      onDragStart(event) {\n        const isLink = event.currentTarget.matches(\"a[href]\")\n        if (isLink) event.preventDefault()\n      },\n      onPointerMove(event) {\n        if (itemState.disabled) return\n        if (event.pointerType !== \"mouse\") return\n        const target = event.currentTarget\n        if (itemState.highlighted) return\n        send({ type: \"ITEM_POINTERMOVE\", id, target, closeOnSelect })\n      },\n      onPointerLeave(event) {\n        if (itemState.disabled) return\n        if (event.pointerType !== \"mouse\") return\n\n        const mouseMoved = state.previousEvent.type.includes(\"POINTER\")\n        if (!mouseMoved) return\n\n        const target = event.currentTarget\n        send({ type: \"ITEM_POINTERLEAVE\", id, target, closeOnSelect })\n      },\n      onPointerDown(event) {\n        if (itemState.disabled) return\n        const target = event.currentTarget\n        send({ type: \"ITEM_POINTERDOWN\", target, id, closeOnSelect })\n      },\n      onPointerUp(event) {\n        if (isDownloadingEvent(event)) return\n        if (isOpeningInNewTab(event)) return\n        if (itemState.disabled) return\n        if (!isLeftClick(event)) return\n\n        const target = event.currentTarget\n        send({ type: \"ITEM_CLICK\", src: \"pointerup\", target, id, closeOnSelect })\n\n        // Fix issue where links don't get clicked in pointerup on touch devices\n        if (event.pointerType === \"touch\") clickIfLink(target)\n      },\n      onTouchEnd(event) {\n        // prevent clicking elements behind content\n        event.preventDefault()\n        event.stopPropagation()\n      },\n    })\n  }\n\n  return {\n    highlightedValue: state.context.highlightedValue,\n    open: open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return\n      send(nextOpen ? \"OPEN\" : \"CLOSE\")\n    },\n    setHighlightedValue(value) {\n      send({ type: \"HIGHLIGHTED.SET\", id: value })\n    },\n    setParent(parent) {\n      send({ type: \"PARENT.SET\", value: parent, id: parent.state.context.id })\n    },\n    setChild(child) {\n      send({ type: \"CHILD.SET\", value: child, id: child.state.context.id })\n    },\n    reposition(options = {}) {\n      send({ type: \"POSITIONING.SET\", options })\n    },\n\n    contextTriggerProps: normalize.element({\n      ...parts.contextTrigger.attrs,\n      dir: state.context.dir,\n      id: dom.getContextTriggerId(state.context),\n      onPointerDown(event) {\n        if (event.pointerType === \"mouse\") return\n        const evt = getNativeEvent(event)\n        const point = getEventPoint(evt)\n        send({ type: \"CONTEXT_MENU_START\", point })\n      },\n      onPointerCancel(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onPointerMove(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onPointerUp(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onContextMenu(event) {\n        const evt = getNativeEvent(event)\n        const point = getEventPoint(evt)\n        send({ type: \"CONTEXT_MENU\", point })\n        event.preventDefault()\n      },\n      style: {\n        WebkitTouchCallout: \"none\",\n        userSelect: \"none\",\n      },\n    }),\n\n    getTriggerItemProps(childApi) {\n      return mergeProps(getItemProps({ value: childApi.triggerProps.id }), childApi.triggerProps) as T[\"element\"]\n    },\n\n    triggerProps: normalize.button({\n      ...(isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs),\n      \"data-placement\": state.context.currentPlacement,\n      type: \"button\",\n      dir: state.context.dir,\n      id: dom.getTriggerId(state.context),\n      \"data-uid\": state.context.id,\n      \"aria-haspopup\": composite ? \"menu\" : \"dialog\",\n      \"aria-controls\": dom.getContentId(state.context),\n      \"aria-expanded\": open || undefined,\n      \"data-state\": open ? \"open\" : \"closed\",\n      onPointerMove(event) {\n        if (event.pointerType !== \"mouse\") return\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        if (disabled || !isSubmenu) return\n        send({ type: \"TRIGGER_POINTERMOVE\", target: event.currentTarget })\n      },\n      onPointerLeave(event) {\n        if (event.pointerType !== \"mouse\") return\n        const evt = getNativeEvent(event)\n\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        if (disabled || !isSubmenu) return\n\n        const point = getEventPoint(evt)\n        send({ type: \"TRIGGER_POINTERLEAVE\", target: event.currentTarget, point })\n      },\n      onClick(event) {\n        if (dom.isTriggerItem(event.currentTarget)) {\n          send({ type: \"TRIGGER_CLICK\", target: event.currentTarget })\n        }\n      },\n      onPointerDown(event) {\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        const evt = getNativeEvent(event)\n        if (!isLeftClick(evt) || disabled || isContextMenuEvent(event)) return\n        event.preventDefault()\n        if (!dom.isTriggerItem(event.currentTarget)) {\n          send({ type: \"TRIGGER_CLICK\", target: event.currentTarget })\n        }\n      },\n      onBlur() {\n        send(\"TRIGGER_BLUR\")\n      },\n      onFocus() {\n        send(\"TRIGGER_FOCUS\")\n      },\n      onKeyDown(event) {\n        if (event.defaultPrevented) return\n        const keyMap: EventKeyMap = {\n          ArrowDown() {\n            send(\"ARROW_DOWN\")\n          },\n          ArrowUp() {\n            send(\"ARROW_UP\")\n          },\n          Enter() {\n            send({ type: \"ARROW_DOWN\", src: \"enter\" })\n          },\n          Space() {\n            send({ type: \"ARROW_DOWN\", src: \"space\" })\n          },\n        }\n\n        const key = getEventKey(event, state.context)\n        const exec = keyMap[key]\n\n        if (exec) {\n          event.preventDefault()\n          exec(event)\n        }\n      },\n    }),\n\n    indicatorProps: normalize.element({\n      ...parts.indicator.attrs,\n      dir: state.context.dir,\n      \"data-state\": open ? \"open\" : \"closed\",\n    }),\n\n    positionerProps: normalize.element({\n      ...parts.positioner.attrs,\n      dir: state.context.dir,\n      id: dom.getPositionerId(state.context),\n      style: popperStyles.floating,\n    }),\n\n    arrowProps: normalize.element({\n      id: dom.getArrowId(state.context),\n      ...parts.arrow.attrs,\n      dir: state.context.dir,\n      style: popperStyles.arrow,\n    }),\n\n    arrowTipProps: normalize.element({\n      ...parts.arrowTip.attrs,\n      dir: state.context.dir,\n      style: popperStyles.arrowTip,\n    }),\n\n    contentProps: normalize.element({\n      ...parts.content.attrs,\n      id: dom.getContentId(state.context),\n      \"aria-label\": state.context[\"aria-label\"],\n      hidden: !open,\n      \"data-state\": open ? \"open\" : \"closed\",\n      role: composite ? \"menu\" : \"dialog\",\n      tabIndex: 0,\n      dir: state.context.dir,\n      \"aria-activedescendant\": state.context.highlightedValue ?? undefined,\n      \"aria-labelledby\": dom.getTriggerId(state.context),\n      \"data-placement\": state.context.currentPlacement,\n      onPointerEnter(event) {\n        if (event.pointerType !== \"mouse\") return\n        send(\"MENU_POINTERENTER\")\n      },\n      onKeyDown(event) {\n        if (event.defaultPrevented) return\n\n        const evt = getNativeEvent(event)\n        if (!isSelfTarget(evt)) return\n\n        const target = getEventTarget<Element>(evt)\n        const sameMenu = target?.closest(\"[role=menu]\") === event.currentTarget || target === event.currentTarget\n        if (!sameMenu) return\n\n        if (event.key === \"Tab\") {\n          const valid = isValidTabEvent(event)\n          if (!valid) {\n            event.preventDefault()\n            return\n          }\n        }\n\n        const item = dom.getHighlightedItemEl(state.context)\n        const keyMap: EventKeyMap = {\n          ArrowDown() {\n            send(\"ARROW_DOWN\")\n          },\n          ArrowUp() {\n            send(\"ARROW_UP\")\n          },\n          ArrowLeft() {\n            send(\"ARROW_LEFT\")\n          },\n          ArrowRight() {\n            send(\"ARROW_RIGHT\")\n          },\n          Enter() {\n            send(\"ENTER\")\n            clickIfLink(item)\n          },\n          Space(event) {\n            if (isTypingAhead) {\n              send({ type: \"TYPEAHEAD\", key: event.key })\n            } else {\n              keyMap.Enter?.(event)\n            }\n          },\n          Home() {\n            send(\"HOME\")\n          },\n          End() {\n            send(\"END\")\n          },\n        }\n\n        const key = getEventKey(event, { dir: state.context.dir })\n        const exec = keyMap[key]\n\n        if (exec) {\n          exec(event)\n          event.stopPropagation()\n          event.preventDefault()\n          return\n        }\n\n        // typeahead\n        if (!state.context.typeahead) return\n        if (!isPrintableKey(event)) return\n        if (isModifierKey(event)) return\n        if (isEditableElement(target)) return\n\n        send({ type: \"TYPEAHEAD\", key: event.key })\n        event.preventDefault()\n      },\n    }),\n\n    separatorProps: normalize.element({\n      ...parts.separator.attrs,\n      role: \"separator\",\n      dir: state.context.dir,\n      \"aria-orientation\": \"horizontal\",\n    }),\n    getItemState,\n    getItemProps,\n\n    getOptionItemState,\n    getOptionItemProps(props) {\n      const { type, disabled, onCheckedChange, closeOnSelect } = props\n\n      const option = getOptionItemProps(props)\n      const itemState = getOptionItemState(props)\n\n      return {\n        ...getItemProps(option),\n        ...normalize.element({\n          \"data-type\": type,\n          ...parts.item.attrs,\n          dir: state.context.dir,\n          \"data-value\": option.value,\n          role: `menuitem${type}`,\n          \"aria-checked\": !!itemState.checked,\n          \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n          onPointerUp(event) {\n            if (!isLeftClick(event) || disabled) return\n            if (isDownloadingEvent(event)) return\n            if (isOpeningInNewTab(event)) return\n            const target = event.currentTarget\n            send({ type: \"ITEM_CLICK\", src: \"pointerup\", target, option, closeOnSelect })\n            onCheckedChange?.(!itemState.checked)\n          },\n        }),\n      }\n    },\n\n    getItemIndicatorProps(props) {\n      const itemState = getOptionItemState(props)\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n        hidden: !itemState.checked,\n      })\n    },\n\n    getItemTextProps(props) {\n      const itemState = getOptionItemState(props)\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n      })\n    },\n\n    getItemGroupLabelProps(props) {\n      return normalize.element({\n        id: dom.getGroupLabelId(state.context, props.htmlFor),\n        dir: state.context.dir,\n        ...parts.itemGroupLabel.attrs,\n      })\n    },\n\n    getItemGroupProps(props) {\n      return normalize.element({\n        id: dom.getGroupId(state.context, props.id),\n        ...parts.itemGroup.attrs,\n        dir: state.context.dir,\n        \"aria-labelledby\": dom.getGroupLabelId(state.context, props.id),\n        role: \"group\",\n      })\n    },\n  }\n}\n", "import { isHTMLElement, nextById, prevById, queryAll, getByTypeahead, createScope } from \"@zag-js/dom-query\"\nimport { first, last } from \"@zag-js/utils\"\nimport type { MachineContext as Ctx } from \"./menu.types\"\n\nexport const dom = createScope({\n  getTriggerId: (ctx: Ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,\n  getContextTriggerId: (ctx: Ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,\n  getContentId: (ctx: Ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`,\n  getArrowId: (ctx: Ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,\n  getPositionerId: (ctx: Ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,\n  getGroupId: (ctx: Ctx, id: string) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`,\n  getGroupLabelId: (ctx: Ctx, id: string) => ctx.ids?.label?.(id) ?? `menu:${ctx.id}:label:${id}`,\n\n  getContentEl: (ctx: Ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: (ctx: Ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getTriggerEl: (ctx: Ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getHighlightedItemEl: (ctx: Ctx) => (ctx.highlightedValue ? dom.getById(ctx, ctx.highlightedValue) : null),\n  getArrowEl: (ctx: Ctx) => dom.getById(ctx, dom.getArrowId(ctx)),\n\n  getElements: (ctx: Ctx) => {\n    const ownerId = CSS.escape(dom.getContentId(ctx))\n    const selector = `[role^=\"menuitem\"][data-ownedby=${ownerId}]:not([data-disabled])`\n    return queryAll(dom.getContentEl(ctx), selector)\n  },\n  getFirstEl: (ctx: Ctx) => first(dom.getElements(ctx)),\n  getLastEl: (ctx: Ctx) => last(dom.getElements(ctx)),\n  getNextEl: (ctx: Ctx, loop?: boolean) => nextById(dom.getElements(ctx), ctx.highlightedValue!, loop ?? ctx.loopFocus),\n  getPrevEl: (ctx: Ctx, loop?: boolean) => prevById(dom.getElements(ctx), ctx.highlightedValue!, loop ?? ctx.loopFocus),\n\n  getElemByKey: (ctx: Ctx, key: string) =>\n    getByTypeahead(dom.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),\n\n  isTargetDisabled: (v: EventTarget | null) => {\n    return isHTMLElement(v) && (v.dataset.disabled === \"\" || v.hasAttribute(\"disabled\"))\n  },\n  isTriggerItem: (el: HTMLElement | null) => {\n    return !!el?.getAttribute(\"role\")?.startsWith(\"menuitem\") && !!el?.hasAttribute(\"aria-controls\")\n  },\n\n  getOptionFromItemEl(el: HTMLElement) {\n    return {\n      id: el.id,\n      name: el.dataset.name,\n      value: el.dataset.value,\n      valueText: el.dataset.valueText,\n      type: el.dataset.type,\n    }\n  },\n})\n", "import { createMachine, guards, ref } from \"@zag-js/core\"\nimport { trackDismissableElement } from \"@zag-js/dismissable\"\nimport { addDomEvent } from \"@zag-js/dom-event\"\nimport {\n  contains,\n  getByTypeahead,\n  getFirstTabbable,\n  isEditableElement,\n  observeAttributes,\n  raf,\n  scrollIntoView,\n} from \"@zag-js/dom-query\"\nimport { getPlacement, getPlacementSide } from \"@zag-js/popper\"\nimport { getElementPolygon, isPointInPolygon } from \"@zag-js/rect-utils\"\nimport { cast, compact, isEqual } from \"@zag-js/utils\"\nimport { dom } from \"./menu.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./menu.types\"\n\nconst { not, and, or } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"menu\",\n      initial: ctx.open ? \"open\" : \"idle\",\n      context: {\n        highlightedValue: null,\n        loopFocus: false,\n        anchorPoint: null,\n        closeOnSelect: true,\n        typeahead: true,\n        composite: true,\n        ...ctx,\n        positioning: {\n          placement: \"bottom-start\",\n          gutter: 8,\n          ...ctx.positioning,\n        },\n        intentPolygon: null,\n        parent: null,\n        lastHighlightedValue: null,\n        children: cast(ref({})),\n        suspendPointer: false,\n        restoreFocus: true,\n        typeaheadState: getByTypeahead.defaultOptions,\n      },\n\n      computed: {\n        isSubmenu: (ctx) => ctx.parent !== null,\n        isRtl: (ctx) => ctx.dir === \"rtl\",\n        isTypingAhead: (ctx) => ctx.typeaheadState.keysSoFar !== \"\",\n      },\n\n      watch: {\n        isSubmenu: \"setSubmenuPlacement\",\n        anchorPoint: \"reposition\",\n        open: \"toggleVisibility\",\n      },\n\n      on: {\n        \"PARENT.SET\": {\n          actions: \"setParentMenu\",\n        },\n        \"CHILD.SET\": {\n          actions: \"setChildMenu\",\n        },\n        OPEN: [\n          {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\",\n          },\n          {\n            target: \"open\",\n            actions: \"invokeOnOpen\",\n          },\n        ],\n        OPEN_AUTOFOCUS: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"],\n          },\n          {\n            internal: true,\n            target: \"open\",\n            actions: [\"highlightFirstItem\", \"invokeOnOpen\"],\n          },\n        ],\n        CLOSE: [\n          {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\",\n          },\n          {\n            target: \"closed\",\n            actions: \"invokeOnClose\",\n          },\n        ],\n        \"HIGHLIGHTED.RESTORE\": {\n          actions: \"restoreHighlightedItem\",\n        },\n        \"HIGHLIGHTED.SET\": {\n          actions: \"setHighlightedItem\",\n        },\n      },\n\n      states: {\n        idle: {\n          tags: [\"closed\"],\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            CONTEXT_MENU_START: {\n              target: \"opening:contextmenu\",\n              actions: \"setAnchorPoint\",\n            },\n            CONTEXT_MENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n            TRIGGER_FOCUS: {\n              guard: not(\"isSubmenu\"),\n              target: \"closed\",\n            },\n            TRIGGER_POINTERMOVE: {\n              guard: \"isSubmenu\",\n              target: \"opening\",\n            },\n          },\n        },\n\n        \"opening:contextmenu\": {\n          tags: [\"closed\"],\n          after: {\n            LONG_PRESS_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            CONTEXT_MENU_CANCEL: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n          },\n        },\n\n        opening: {\n          tags: [\"closed\"],\n          after: {\n            SUBMENU_OPEN_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            BLUR: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n            TRIGGER_POINTERLEAVE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n          },\n        },\n\n        closing: {\n          tags: [\"open\"],\n          activities: [\"trackPointerMove\", \"trackInteractOutside\"],\n          after: {\n            SUBMENU_CLOSE_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\", \"invokeOnClose\"],\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": {\n              target: \"closed\",\n              actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\"],\n            },\n            // don't invoke on open here since the menu is still open (we're only keeping it open)\n            MENU_POINTERENTER: {\n              target: \"open\",\n              actions: \"clearIntentPolygon\",\n            },\n            POINTER_MOVED_AWAY_FROM_SUBMENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\"],\n              },\n            ],\n          },\n        },\n\n        closed: {\n          tags: [\"closed\"],\n          entry: [\"clearHighlightedItem\", \"focusTrigger\", \"clearAnchorPoint\", \"resumePointer\"],\n          on: {\n            \"CONTROLLED.OPEN\": [\n              {\n                guard: or(\"isOpenAutoFocusEvent\", \"isArrowDownEvent\"),\n                target: \"open\",\n                actions: \"highlightFirstItem\",\n              },\n              {\n                guard: \"isArrowUpEvent\",\n                target: \"open\",\n                actions: \"highlightLastItem\",\n              },\n              {\n                target: \"open\",\n              },\n            ],\n            CONTEXT_MENU_START: {\n              target: \"opening:contextmenu\",\n              actions: \"setAnchorPoint\",\n            },\n            CONTEXT_MENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n            TRIGGER_POINTERMOVE: {\n              guard: \"isTriggerItem\",\n              target: \"opening\",\n            },\n            TRIGGER_BLUR: \"idle\",\n            ARROW_DOWN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: [\"highlightFirstItem\", \"invokeOnOpen\"],\n              },\n            ],\n            ARROW_UP: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: [\"highlightLastItem\", \"invokeOnOpen\"],\n              },\n            ],\n          },\n        },\n\n        open: {\n          tags: [\"open\"],\n          activities: [\"trackInteractOutside\", \"trackPositioning\", \"scrollToHighlightedItem\"],\n          entry: [\"focusMenu\", \"resumePointer\"],\n          on: {\n            \"CONTROLLED.CLOSE\": [\n              {\n                target: \"closed\",\n                guard: \"isArrowLeftEvent\",\n                actions: [\"focusParentMenu\"],\n              },\n              {\n                target: \"closed\",\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: and(not(\"isTriggerItem\"), \"isOpenControlled\"),\n                actions: \"invokeOnClose\",\n              },\n              {\n                guard: not(\"isTriggerItem\"),\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n            ARROW_UP: {\n              actions: [\"highlightPrevItem\", \"focusMenu\"],\n            },\n            ARROW_DOWN: {\n              actions: [\"highlightNextItem\", \"focusMenu\"],\n            },\n            ARROW_LEFT: [\n              {\n                guard: and(\"isSubmenu\", \"isOpenControlled\"),\n                actions: \"invokeOnClose\",\n              },\n              {\n                guard: \"isSubmenu\",\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"invokeOnClose\"],\n              },\n            ],\n            HOME: {\n              actions: [\"highlightFirstItem\", \"focusMenu\"],\n            },\n            END: {\n              actions: [\"highlightLastItem\", \"focusMenu\"],\n            },\n            ARROW_RIGHT: {\n              guard: \"isTriggerItemHighlighted\",\n              actions: \"openSubmenu\",\n            },\n            ENTER: [\n              {\n                guard: \"isTriggerItemHighlighted\",\n                actions: \"openSubmenu\",\n              },\n              // == grouped ==\n              {\n                guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n                actions: [\"clickHighlightedItem\", \"invokeOnClose\"],\n              },\n              {\n                guard: \"closeOnSelect\",\n                target: \"closed\",\n                actions: \"clickHighlightedItem\",\n              },\n              //\n              {\n                actions: \"clickHighlightedItem\",\n              },\n            ],\n            ITEM_POINTERMOVE: [\n              {\n                guard: not(\"suspendPointer\"),\n                actions: [\"setHighlightedItem\", \"focusMenu\"],\n              },\n              {\n                actions: \"setLastHighlightedItem\",\n              },\n            ],\n            ITEM_POINTERLEAVE: {\n              guard: and(not(\"suspendPointer\"), not(\"isTriggerItem\")),\n              actions: \"clearHighlightedItem\",\n            },\n            ITEM_CLICK: [\n              // == grouped ==\n              {\n                guard: and(\n                  not(\"isTriggerItemHighlighted\"),\n                  not(\"isHighlightedItemEditable\"),\n                  \"closeOnSelect\",\n                  \"isOpenControlled\",\n                ),\n                actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"],\n              },\n              {\n                guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\"),\n                target: \"closed\",\n                actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"],\n              },\n              //\n              {\n                guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\")),\n                actions: [\"invokeOnSelect\", \"setOptionState\"],\n              },\n              { actions: \"setHighlightedItem\" },\n            ],\n            TRIGGER_POINTERLEAVE: {\n              target: \"closing\",\n              actions: \"setIntentPolygon\",\n            },\n            ITEM_POINTERDOWN: {\n              actions: \"setHighlightedItem\",\n            },\n            TYPEAHEAD: {\n              actions: \"highlightMatchedItem\",\n            },\n            FOCUS_MENU: {\n              actions: \"focusMenu\",\n            },\n            \"POSITIONING.SET\": {\n              actions: \"reposition\",\n            },\n          },\n        },\n      },\n    },\n    {\n      delays: {\n        LONG_PRESS_DELAY: 700,\n        SUBMENU_OPEN_DELAY: 100,\n        SUBMENU_CLOSE_DELAY: 100,\n      },\n\n      guards: {\n        closeOnSelect: (ctx, evt) => !!(evt?.closeOnSelect ?? ctx.closeOnSelect),\n        // whether the trigger is also a menu item\n        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),\n        // whether the trigger item is the active item\n        isTriggerItemHighlighted: (ctx, evt) => {\n          const target = (evt.target ?? dom.getHighlightedItemEl(ctx)) as HTMLElement | null\n          return !!target?.hasAttribute(\"aria-controls\")\n        },\n        isSubmenu: (ctx) => ctx.isSubmenu,\n        suspendPointer: (ctx) => ctx.suspendPointer,\n        isHighlightedItemEditable: (ctx) => isEditableElement(dom.getHighlightedItemEl(ctx)),\n        isWithinPolygon: (ctx, evt) => {\n          if (!ctx.intentPolygon) return false\n          return isPointInPolygon(ctx.intentPolygon, evt.point)\n        },\n        // guard assertions (for controlled mode)\n        isOpenControlled: (ctx) => !!ctx[\"open.controlled\"],\n        isArrowLeftEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_LEFT\",\n        isArrowUpEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_UP\",\n        isArrowDownEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_DOWN\",\n        isOpenAutoFocusEvent: (_ctx, evt) => evt.previousEvent?.type === \"OPEN_AUTOFOCUS\",\n      },\n\n      activities: {\n        trackPositioning(ctx) {\n          if (ctx.anchorPoint) return\n          ctx.currentPlacement = ctx.positioning.placement\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          return getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            defer: true,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n          })\n        },\n        trackInteractOutside(ctx, _evt, { send }) {\n          const getContentEl = () => dom.getContentEl(ctx)\n          return trackDismissableElement(getContentEl, {\n            defer: true,\n            exclude: [dom.getTriggerEl(ctx)],\n            onInteractOutside: ctx.onInteractOutside,\n            onFocusOutside: ctx.onFocusOutside,\n            onEscapeKeyDown(event) {\n              ctx.onEscapeKeyDown?.(event)\n              if (ctx.isSubmenu) event.preventDefault()\n              closeRootMenu(ctx)\n            },\n            onPointerDownOutside(event) {\n              ctx.restoreFocus = !event.detail.focusable\n              ctx.onPointerDownOutside?.(event)\n            },\n            onDismiss() {\n              send({ type: \"CLOSE\", src: \"interact-outside\" })\n            },\n          })\n        },\n        trackPointerMove(ctx, _evt, { guards, send }) {\n          const { isWithinPolygon } = guards\n\n          // NOTE: we're mutating parent context here. sending events to parent doesn't work\n          ctx.parent!.state.context.suspendPointer = true\n\n          const doc = dom.getDoc(ctx)\n\n          return addDomEvent(doc, \"pointermove\", (e) => {\n            const point = { x: e.clientX, y: e.clientY }\n\n            const isMovingToSubmenu = isWithinPolygon(ctx, { point })\n\n            if (!isMovingToSubmenu) {\n              send(\"POINTER_MOVED_AWAY_FROM_SUBMENU\")\n              // NOTE: we're mutating parent context here. sending events to parent doesn't work\n              ctx.parent!.state.context.suspendPointer = false\n            }\n          })\n        },\n        scrollToHighlightedItem(ctx, _evt, { getState }) {\n          const exec = () => {\n            const state = getState()\n\n            if (state.event.type.startsWith(\"ITEM_POINTER\")) return\n\n            const itemEl = dom.getHighlightedItemEl(ctx)\n            const contentEl = dom.getContentEl(ctx)\n\n            scrollIntoView(itemEl, { rootEl: contentEl, block: \"nearest\" })\n          }\n          raf(() => exec())\n\n          const contentEl = () => dom.getContentEl(ctx)\n          return observeAttributes(contentEl, {\n            defer: true,\n            attributes: [\"aria-activedescendant\"],\n            callback: exec,\n          })\n        },\n      },\n\n      actions: {\n        setAnchorPoint(ctx, evt) {\n          ctx.anchorPoint = evt.point\n        },\n        clearAnchorPoint(ctx) {\n          ctx.anchorPoint = null\n        },\n        setSubmenuPlacement(ctx) {\n          if (!ctx.isSubmenu) return\n          ctx.positioning.placement = ctx.isRtl ? \"left-start\" : \"right-start\"\n          ctx.positioning.gutter = 0\n        },\n        reposition(ctx, evt) {\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          const getAnchorRect = ctx.anchorPoint ? () => ({ width: 0, height: 0, ...ctx.anchorPoint }) : undefined\n          getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            getAnchorRect,\n            ...(evt.options ?? {}),\n            listeners: false,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n          })\n        },\n        setOptionState(_ctx, evt) {\n          if (!evt.option) return\n          const { checked, onCheckedChange, type } = evt.option\n\n          if (type === \"radio\") {\n            onCheckedChange?.(true)\n          } else if (type === \"checkbox\") {\n            onCheckedChange?.(!checked)\n          }\n        },\n        clickHighlightedItem(ctx, _evt, { send }) {\n          const itemEl = dom.getHighlightedItemEl(ctx)\n          if (!itemEl || itemEl.dataset.disabled) return\n          const option = dom.getOptionFromItemEl(itemEl)\n          send({\n            type: \"ITEM_CLICK\",\n            src: \"enter\",\n            target: itemEl,\n            id: option.id,\n            option,\n            closeOnSelect: ctx.closeOnSelect,\n          })\n        },\n        setIntentPolygon(ctx, evt) {\n          const menu = dom.getContentEl(ctx)\n          const placement = ctx.currentPlacement\n\n          if (!menu || !placement) return\n\n          const rect = menu.getBoundingClientRect()\n          const polygon = getElementPolygon(rect, placement)\n          if (!polygon) return\n\n          const rightSide = getPlacementSide(placement) === \"right\"\n          const bleed = rightSide ? -5 : +5\n\n          ctx.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon]\n        },\n        clearIntentPolygon(ctx) {\n          ctx.intentPolygon = null\n        },\n        resumePointer(ctx) {\n          if (!ctx.parent) return\n          ctx.parent.state.context.suspendPointer = false\n        },\n        setHighlightedItem(ctx, evt) {\n          set.highlighted(ctx, evt.id)\n        },\n        clearHighlightedItem(ctx) {\n          set.highlighted(ctx, null)\n        },\n        focusMenu(ctx) {\n          raf(() => {\n            const contentEl = dom.getContentEl(ctx)\n            if (contains(contentEl, dom.getActiveElement(ctx))) return\n            const firstFocusableEl = getFirstTabbable(contentEl, false) || contentEl\n            firstFocusableEl?.focus({ preventScroll: true })\n          })\n        },\n        highlightFirstItem(ctx) {\n          const first = dom.getFirstEl(ctx)\n          if (!first) return\n          set.highlighted(ctx, first.id)\n        },\n        highlightLastItem(ctx) {\n          const last = dom.getLastEl(ctx)\n          if (!last) return\n          set.highlighted(ctx, last.id)\n        },\n        highlightNextItem(ctx, evt) {\n          const next = dom.getNextEl(ctx, evt.loop)\n          set.highlighted(ctx, next?.id ?? null)\n        },\n        highlightPrevItem(ctx, evt) {\n          const prev = dom.getPrevEl(ctx, evt.loop)\n          set.highlighted(ctx, prev?.id ?? null)\n        },\n        invokeOnSelect(ctx) {\n          if (!ctx.highlightedValue) return\n          ctx.onSelect?.({ value: ctx.highlightedValue })\n        },\n        focusTrigger(ctx) {\n          if (ctx.isSubmenu || ctx.anchorPoint || !ctx.restoreFocus) return\n          raf(() => dom.getTriggerEl(ctx)?.focus({ preventScroll: true }))\n        },\n        highlightMatchedItem(ctx, evt) {\n          const node = dom.getElemByKey(ctx, evt.key)\n          if (!node) return\n          set.highlighted(ctx, node.id)\n        },\n        setParentMenu(ctx, evt) {\n          ctx.parent = ref(evt.value)\n        },\n        setChildMenu(ctx, evt) {\n          ctx.children[evt.id] = ref(evt.value)\n        },\n        closeRootMenu(ctx) {\n          closeRootMenu(ctx)\n        },\n        openSubmenu(ctx) {\n          const item = dom.getHighlightedItemEl(ctx)\n          const id = item?.getAttribute(\"data-uid\")\n          const child = id ? ctx.children[id] : null\n          child?.send(\"OPEN_AUTOFOCUS\")\n        },\n        focusParentMenu(ctx) {\n          ctx.parent?.send(\"FOCUS_MENU\")\n        },\n        setLastHighlightedItem(ctx, evt) {\n          ctx.lastHighlightedValue = evt.id\n        },\n        restoreHighlightedItem(ctx) {\n          if (!ctx.lastHighlightedValue) return\n          set.highlighted(ctx, ctx.lastHighlightedValue)\n          ctx.lastHighlightedValue = null\n        },\n        restoreParentHiglightedItem(ctx) {\n          ctx.parent?.send(\"HIGHLIGHTED.RESTORE\")\n        },\n        invokeOnOpen(ctx) {\n          ctx.onOpenChange?.({ open: true })\n        },\n        invokeOnClose(ctx) {\n          ctx.onOpenChange?.({ open: false })\n        },\n        toggleVisibility(ctx, evt, { send }) {\n          send({ type: ctx.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\", previousEvent: evt })\n        },\n      },\n    },\n  )\n}\n\nfunction closeRootMenu(ctx: MachineContext) {\n  let parent = ctx.parent\n  while (parent && parent.state.context.isSubmenu) {\n    parent = parent.state.context.parent\n  }\n  parent?.send(\"CLOSE\")\n}\n\nconst set = {\n  highlighted(ctx: MachineContext, value: string | null) {\n    if (isEqual(ctx.highlightedValue, value)) return\n    ctx.highlightedValue = value\n    ctx.onHighlightChange?.({ highlightedValue: value })\n  },\n}\n", "import { createProps } from \"@zag-js/types\"\nimport { createSplitProps } from \"@zag-js/utils\"\nimport type { ItemGroupLabelProps, ItemGroupProps, ItemProps, OptionItemProps, UserDefinedContext } from \"./menu.types\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"anchorPoint\",\n  \"aria-label\",\n  \"closeOnSelect\",\n  \"dir\",\n  \"getRootNode\",\n  \"highlightedValue\",\n  \"id\",\n  \"ids\",\n  \"loopFocus\",\n  \"onFocusOutside\",\n  \"onInteractOutside\",\n  \"onOpenChange\",\n  \"onPointerDownOutside\",\n  \"onEscapeKeyDown\",\n  \"onSelect\",\n  \"onHighlightChange\",\n  \"open\",\n  \"open.controlled\",\n  \"positioning\",\n  \"typeahead\",\n  \"composite\",\n])\n\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const itemProps = createProps<ItemProps>()([\"closeOnSelect\", \"disabled\", \"value\", \"valueText\"])\nexport const splitItemProps = createSplitProps<ItemProps>(itemProps)\n\nexport const itemGroupLabelProps = createProps<ItemGroupLabelProps>()([\"htmlFor\"])\nexport const splitItemGroupLabelProps = createSplitProps<ItemGroupLabelProps>(itemGroupLabelProps)\n\nexport const itemGroupProps = createProps<ItemGroupProps>()([\"id\"])\nexport const splitItemGroupProps = createSplitProps<ItemGroupProps>(itemGroupProps)\n\nexport const optionItemProps = createProps<OptionItemProps>()([\n  \"disabled\",\n  \"valueText\",\n  \"closeOnSelect\",\n  \"type\",\n  \"value\",\n  \"checked\",\n  \"onCheckedChange\",\n])\n\nexport const splitOptionItemProps = createSplitProps<OptionItemProps>(optionItemProps)\n", "import * as menu from \"@zag-js/menu\";\nimport { normalizeProps } from \"./normalize-props\";\nimport { spreadProps } from \"./spread-props\";\n\nexport const Menu = {\n  mounted() {\n    this.context = { id: this.el.id };\n\n    this.service = menu.machine(this.context);\n    this.api = menu.connect(this.service.state, this.service.send, normalizeProps);\n\n    this.render();\n    this.service.subscribe(() => {\n      this.api = menu.connect(this.service.state, this.service.send, normalizeProps);\n      this.render();\n    });\n\n    this.service.start();\n  },\n\n  updated() {\n    this.render();\n  },\n\n  beforeDestroy() {\n    this.service.stop();\n  },\n\n  labels() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='label']\"));\n  },\n\n  groups() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='group']\"));\n  },\n\n  separators() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='separator']\"));\n  },\n\n  items() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='item']\"));\n  },\n\n  render() {\n    const trigger = this.el.querySelector(\"[data-part='trigger']\");\n    const positioner = this.el.querySelector(\"[data-part='positioner']\");\n    const content = this.el.querySelector(\"[data-part='content']\");\n\n    if (trigger) spreadProps(trigger, this.api.triggerProps);\n    if (positioner) spreadProps(positioner, this.api.positionerProps);\n    if (content) spreadProps(content, this.api.contentProps);\n\n    this.labels().forEach((label) => {\n      spreadProps(label, this.api.getItemGroupLabelProps({ htmlFor: label.dataset.for }));\n    });\n\n    this.groups().forEach((group) => {\n      spreadProps(group, this.api.getItemGroupProps({ id: group.id }));\n    });\n\n    this.separators().forEach((separator) => spreadProps(separator, this.api.separatorProps));\n\n    this.items().forEach((item) => {\n      spreadProps(item, this.api.getItemProps({ value: item.id }));\n    });\n  },\n};\n", "import { Accordion } from \"./accordion\";\nimport { Menu } from \"./menu\";\n\nconst Hooks = {\n  Accordion: Accordion,\n  Menu: Menu,\n};\n\nexport { Accordion, Menu, Hooks };\n"],
  "mappings": "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",
  "names": ["createAnatomy", "name", "parts", "values", "isEmpty", "newName", "prev", "part", "toKebabCase", "value", "v", "dataAttr", "guard", "isHTMLElement", "v", "isDocument", "el", "isWindow", "isNode", "el", "isShadowRoot", "contains", "parent", "child", "isHTMLElement", "getDocument", "isDocument", "isWindow", "getWindow", "el", "isShadowRoot", "isDocument", "isHTMLElement", "isDom", "getPlatform", "pt", "v", "ua", "vn", "isTouchDevice", "isMac", "isSafari", "isApple", "isFirefox", "getEventTarget", "event", "isSelfTarget", "contains", "isOpeningInNewTab", "element", "isAppleDevice", "isApple", "localName", "isDownloadingEvent", "defaultItemToId", "v", "itemById", "id", "itemToId", "item", "indexOfId", "nextById", "loop", "idx", "prevById", "sanitize", "str", "char", "code", "getValueText", "match", "valueText", "query", "wrap", "_", "index", "getByText", "text", "currentId", "items", "getByTypeaheadImpl", "_items", "options", "state", "activeId", "key", "timeout", "search", "next", "cleanup", "update", "value", "getByTypeahead", "isValidTypeaheadEvent", "isHTMLElement", "element", "isFrame", "isVisible", "el", "hasNegativeTabIndex", "focusableSelector", "isFocusable", "element", "focusableSelector", "isVisible", "getTabbables", "container", "includeContainer", "elements", "focusableSelector", "tabbableElements", "isTabbable", "element", "i", "isFrame", "frameBody", "allFrameTabbable", "el", "isFocusable", "hasNegativeTabIndex", "getFirstTabbable", "first", "getTabbableEdges", "container", "includeContainer", "elements", "getTabbables", "first", "last", "isValidTabEvent", "event", "container", "firstTabbable", "lastTabbable", "getTabbableEdges", "doc", "isEditableElement", "el", "isHTMLElement", "win", "getWindow", "OVERFLOW_RE", "isOverflowElement", "el", "win", "getWindow", "overflow", "overflowX", "overflowY", "display", "raf", "fn", "id", "observeAttributesImpl", "node", "options", "attributes", "win", "obs", "changes", "change", "observeAttributes", "nodeOrFn", "defer", "func", "v", "cleanups", "queryAll", "root", "selector", "createScope", "methods", "screen", "ctx", "getDocument", "elem", "id", "value", "valueAsString", "isScrollable", "el", "scrollIntoView", "options", "rootEl", "scrollOptions", "isOverflowElement", "cleanups", "set", "element", "key", "setup", "elementCleanups", "prevCleanup", "cleanup", "nextCleanup", "setStyle", "element", "style", "set", "prevStyle", "fps", "waitForElement", "query", "cb", "el", "isHTMLElement", "timerId", "waitForElements", "queries", "cleanups", "clean", "fn", "addDomEvent", "target", "eventName", "handler", "options", "node", "isPrintableKey", "e", "isLeftClick", "e", "isContextMenuEvent", "isMac", "isModifierKey", "queueBeforeEvent", "element", "type", "cb", "cancelTimer", "callback", "timerId", "callSync", "isLinkElement", "clickIfLink", "click", "isFirefox", "fireCustomEvent", "el", "init", "win", "event", "keyMap", "rtlKeyMap", "getEventKey", "event", "options", "dir", "orientation", "key", "pointFromTouch", "e", "type", "point", "pointFromMouse", "isTouchEvent", "getEventPoint", "getNativeEvent", "event", "first", "v", "last", "add", "v", "items", "remove", "item", "t", "isArrayLike", "value", "isEqual", "a", "b", "keys", "length", "i", "key", "runIfFn", "v", "cast", "noop", "callAll", "fns", "fn", "isFunction", "v", "isNull", "compact", "obj", "isPlainObject", "keys", "key", "filtered", "value", "isPlainObject", "value", "splitProps", "props", "keys", "rest", "result", "keySet", "key", "createSplitProps", "warn", "a", "m", "c", "TRACK_MEMO_SYMBOL", "GET_ORIGINAL_SYMBOL", "getProto", "objectsToTrack", "isObjectToTrack", "obj", "getUntracked", "obj", "isObjectToTrack", "GET_ORIGINAL_SYMBOL", "markToTrack", "mark", "objectsToTrack", "getGlobal", "makeGlobal", "key", "value", "g", "isDev", "isObject", "x", "proxyStateMap", "refSet", "buildProxyFunction", "objectIs", "newProxy", "target", "handler", "canProxy", "defaultHandlePromise", "promise", "snapCache", "createSnapshot", "version", "handlePromise", "cache", "snap", "markToTrack", "snapshot", "proxyCache", "versionHolder", "proxyFunction", "initialObject", "found", "listeners", "notifyUpdate", "op", "nextVersion", "listener", "checkVersion", "ensureVersion", "nextCheckVersion", "propProxyStates", "propProxyState", "propVersion", "createPropListener", "prop", "newOp", "addPropListener", "remove", "removePropListener", "entry", "addListener", "prevRemove", "baseObject", "proxyObject", "prevValue", "deleted", "receiver", "hasPrevValue", "getUntracked", "nextValue", "v", "e", "proxy", "childProxyState", "proxyState", "desc", "subscribe", "callback", "notifyInSync", "ops", "isListenerActive", "removeListener", "ref", "obj", "proxyWithComputed", "computedFns", "computedFn", "get", "set", "newValue", "set", "obj", "key", "val", "klona", "x", "i", "k", "list", "tmp", "str", "clear", "v", "runIfFn", "a", "cast", "noop", "callAll", "fns", "fn", "uuid", "id", "isDev", "isArray", "isObject", "isNumber", "isString", "isFunction", "hasProp", "obj", "prop", "compact", "isPlainObject", "keys", "key", "filtered", "value", "warn", "m", "c", "invariant", "deepMerge", "source", "objects", "target", "structuredClone", "klona", "toEvent", "event", "toArray", "isGuardHelper", "Truthy", "exec", "guardMap", "ctx", "meta", "guard", "or", "conditions", "and", "not", "condition", "stateIn", "values", "_ctx", "_evt", "guards", "determineGuardFn", "guard", "guardMap", "Truthy", "context", "event", "meta", "isString", "value", "isFunction", "isGuardHelper", "determineActionsFn", "values", "createProxy", "config", "computedContext", "cast", "initialContext", "initialTags", "state", "proxy", "proxyWithComputed", "tag", "stateEvents", "globalEvents", "determineDelayFn", "delay", "delaysMap", "isNumber", "valueOrFn", "invariant", "toTarget", "target", "determineTransitionFn", "transitions", "toArray", "transition", "Machine", "options", "__publicField", "noop", "toEvent", "init", "subscribe", "listener", "isObject", "next", "watch", "prev", "snapshot", "cleanup", "key", "fn", "stop", "evt", "to", "id", "runIfFn", "child", "parent", "src", "actor", "ref", "cleanups", "stateNode", "clear", "deepMerge", "compact", "opts", "isTargetless", "changed", "info", "entries", "exits", "isArray", "hasProp", "__delay", "actions", "pickedActions", "action", "warn", "activities", "activity", "uuid", "every", "callbackfn", "picked", "delayOrFn", "interval", "current", "currentState", "_exit", "exitActions", "afterExitActions", "entryActions", "afterActions", "args", "isDev", "msg", "structuredClone", "self", "createMachine", "clsx", "args", "str", "CSS_REGEX", "serialize", "style", "res", "match", "css", "a", "b", "isString", "eventRegex", "mergeProps", "result", "props", "key", "callAll", "createNormalizer", "fn", "createProps", "props", "anatomy", "createAnatomy", "parts", "dom", "createScope", "ctx", "value", "selector", "queryAll", "first", "last", "id", "nextById", "prevById", "connect", "state", "send", "normalize", "focusedValue", "multiple", "setValue", "nextValue", "getItemState", "props", "itemState", "dataAttr", "event", "isSafari", "keyMap", "key", "getEventKey", "exec", "and", "not", "guards", "machine", "userContext", "compact", "createMachine", "evt", "next", "remove", "set", "add", "warn", "invoke", "isEqual", "createProps", "splitProps", "createSplitProps", "itemProps", "splitItemProps", "propMap", "toStyleString", "style", "string", "key", "value", "match", "normalizeProps", "createNormalizer", "props", "acc", "prevAttrsMap", "spreadProps", "node", "attrs", "oldAttrs", "attrKeys", "addEvent", "e", "removeEvent", "onEvents", "attr", "others", "setup", "teardown", "apply", "attrName", "value", "oldValue", "key", "evt", "Accordion", "machine", "connect", "normalizeProps", "service", "spreadProps", "item", "index", "trigger", "content", "min", "max", "round", "floor", "createCoords", "v", "oppositeSideMap", "oppositeAlignmentMap", "clamp", "start", "value", "end", "evaluate", "param", "getSide", "placement", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "getSideAxis", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "length", "mainAlignmentSide", "getOppositePlacement", "getExpandedPlacements", "oppositePlacement", "getOppositeAlignmentPlacement", "getSideList", "side", "isStart", "lr", "rl", "tb", "bt", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "expandPaddingObject", "padding", "getPaddingObject", "rectToClientRect", "rect", "x", "y", "width", "height", "computeCoordsFromPlacement", "_ref", "placement", "rtl", "reference", "floating", "sideAxis", "getSideAxis", "alignmentAxis", "getAlignmentAxis", "alignLength", "getAxisLength", "side", "getSide", "isVertical", "commonX", "commonY", "commonAlign", "coords", "getAlignment", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "rects", "x", "y", "statefulPlacement", "middlewareData", "resetCount", "i", "name", "fn", "nextX", "nextY", "data", "reset", "detectOverflow", "state", "options", "_await$platform$isEle", "elements", "boundary", "rootBoundary", "elementContext", "altBoundary", "padding", "evaluate", "paddingObject", "getPaddingObject", "element", "clippingClientRect", "rectToClientRect", "rect", "offsetParent", "offsetScale", "elementClientRect", "arrow", "axis", "length", "arrowDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "largestPossiblePadding", "minPadding", "min", "maxPadding", "min$1", "max", "center", "offset", "clamp", "shouldAddOffset", "alignmentOffset", "flip", "options", "state", "_middlewareData$arrow", "_middlewareData$flip", "placement", "middlewareData", "rects", "initialPlacement", "platform", "elements", "checkMainAxis", "checkCrossAxis", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment", "detectOverflowOptions", "evaluate", "side", "getSide", "isBasePlacement", "rtl", "fallbackPlacements", "getOppositePlacement", "getExpandedPlacements", "getOppositeAxisPlacements", "placements", "overflow", "detectOverflow", "overflows", "overflowsData", "sides", "getAlignmentSides", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "nextPlacement", "resetPlacement", "d", "a", "b", "_overflowsData$map$so", "acc", "convertValueToCoords", "state", "options", "placement", "platform", "elements", "rtl", "side", "getSide", "alignment", "getAlignment", "isVertical", "getSideAxis", "mainAxisMulti", "crossAxisMulti", "rawValue", "evaluate", "mainAxis", "crossAxis", "alignmentAxis", "offset", "_middlewareData$offse", "_middlewareData$arrow", "x", "y", "middlewareData", "diffCoords", "shift", "checkMainAxis", "checkCrossAxis", "limiter", "_ref", "detectOverflowOptions", "coords", "overflow", "detectOverflow", "getOppositeAxis", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "min", "max", "clamp", "limitedCoords", "limitShift", "rects", "rawOffset", "computedOffset", "len", "limitMin", "limitMax", "_middlewareData$offse2", "isOriginSide", "size", "apply", "isYAxis", "width", "height", "heightSide", "widthSide", "maximumClippingHeight", "maximumClippingWidth", "overflowAvailableHeight", "overflowAvailableWidth", "noShift", "availableHeight", "availableWidth", "xMin", "xMax", "yMin", "yMax", "nextDimensions", "getNodeName", "node", "isNode", "getWindow", "_node$ownerDocument", "getDocumentElement", "_ref", "value", "isElement", "isHTMLElement", "isShadowRoot", "isOverflowElement", "element", "overflow", "overflowX", "overflowY", "display", "getComputedStyle", "isTableElement", "isContainingBlock", "webkit", "isWebKit", "css", "getContainingBlock", "currentNode", "getParentNode", "isLastTraversableNode", "getNodeScroll", "result", "getNearestOverflowAncestor", "parentNode", "getOverflowAncestors", "list", "traverseIframes", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "getCssDimensions", "element", "css", "getComputedStyle", "width", "height", "hasOffset", "isHTMLElement", "offsetWidth", "offsetHeight", "shouldFallback", "round", "unwrapElement", "isElement", "getScale", "domElement", "createCoords", "rect", "$", "x", "y", "noOffsets", "getVisualOffsets", "win", "getWindow", "isWebKit", "shouldAddVisualOffsets", "isFixed", "floatingOffsetParent", "getBoundingClientRect", "includeScale", "isFixedStrategy", "offsetParent", "clientRect", "scale", "visualOffsets", "offsetWin", "currentWin", "currentIFrame", "iframeScale", "iframeRect", "left", "top", "rectToClientRect", "topLayerSelectors", "isTopLayer", "selector", "convertOffsetParentRelativeRectToViewportRelativeRect", "_ref", "elements", "strategy", "documentElement", "getDocumentElement", "topLayer", "scroll", "offsets", "isOffsetParentAnElement", "getNodeName", "isOverflowElement", "getNodeScroll", "offsetRect", "getClientRects", "getWindowScrollBarX", "getDocumentRect", "html", "body", "max", "getViewportRect", "visualViewport", "visualViewportBased", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "hasFixedPositionAncestor", "stopNode", "parentNode", "getParentNode", "isLastTraversableNode", "getClippingElementAncestors", "cache", "cachedResult", "result", "getOverflowAncestors", "el", "currentContainingBlockComputedStyle", "elementIsFixed", "currentNode", "computedStyle", "currentNodeIsContaining", "isContainingBlock", "ancestor", "getClippingRect", "boundary", "rootBoundary", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "min", "getDimensions", "getRectRelativeToOffsetParent", "isStaticPositioned", "getTrueOffsetParent", "polyfill", "getOffsetParent", "svgOffsetParent", "isTableElement", "getContainingBlock", "getElementRects", "data", "getOffsetParentFn", "getDimensionsFn", "floatingDimensions", "isRTL", "platform", "observeMove", "onMove", "io", "timeoutId", "root", "cleanup", "_io", "refresh", "skip", "threshold", "insetTop", "floor", "insetRight", "insetBottom", "insetLeft", "options", "isFirstUpdate", "handleObserve", "entries", "ratio", "autoUpdate", "reference", "floating", "update", "ancestorScroll", "ancestorResize", "elementResize", "layoutShift", "animationFrame", "referenceEl", "ancestors", "cleanupIo", "reobserveFrame", "resizeObserver", "firstEntry", "_resizeObserver", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "_resizeObserver2", "offset", "shift", "flip", "size", "arrow", "limitShift", "computePosition", "reference", "floating", "options", "cache", "mergedOptions", "platform", "platformWithCache", "createDOMRect", "x", "y", "width", "height", "rect", "getDOMRect", "anchorRect", "getAnchorElement", "anchorElement", "getAnchorRect", "isHTMLElement", "anchor", "toVar", "value", "cssVars", "getTransformOrigin", "arrow", "transformOriginMiddleware", "placement", "elements", "middlewareData", "transformOrigin", "floating", "rectMiddleware", "rects", "shiftArrowMiddleware", "arrowEl", "dir", "getPlacementDetails", "placement", "side", "align", "getPlacementSide", "defaultOptions", "roundByDpr", "win", "value", "dpr", "getBoundaryMiddleware", "opts", "runIfFn", "getArrowMiddleware", "arrowElement", "arrow", "getOffsetMiddleware", "isNull", "offset", "arrowOffset", "gutter", "mainAxis", "hasAlign", "shift", "crossAxis", "compact", "getFlipMiddleware", "flip", "getShiftMiddleware", "limitShift", "getSizeMiddleware", "size", "elements", "rects", "availableHeight", "availableWidth", "floating", "referenceWidth", "getAutoUpdateOptions", "getPlacementImpl", "referenceOrVirtual", "reference", "getAnchorElement", "options", "arrowEl", "middleware", "shiftArrowMiddleware", "transformOriginMiddleware", "rectMiddleware", "strategy", "onComplete", "onPositioned", "updatePosition", "pos", "computePosition", "getWindow", "x", "y", "contentEl", "zIndex", "update", "autoUpdateOptions", "cancelAutoUpdate", "autoUpdate", "noop", "getPlacement", "referenceOrFn", "floatingOrFn", "defer", "func", "raf", "v", "cleanups", "fn", "ARROW_FLOATING_STYLE", "getPlacementStyles", "sameWidth", "fitViewport", "cssVars", "getWindowFrames", "win", "frames", "cb", "frame", "event", "listener", "options", "POINTER_OUTSIDE_EVENT", "FOCUS_OUTSIDE_EVENT", "isComposedPathFocusable", "composedPath", "node", "isHTMLElement", "isFocusable", "isPointerEvent", "isEventPointWithin", "rect", "isEventWithinScrollbar", "target", "getEventTarget", "onScrollbarY", "onScrollbarX", "trackInteractOutsideImpl", "exclude", "onFocusOutside", "onPointerDownOutside", "onInteractOutside", "defer", "doc", "getDocument", "getWindow", "isEventOutside", "contains", "clickHandler", "onPointerDown", "handler", "func", "raf", "v", "callAll", "fireCustomEvent", "isContextMenuEvent", "cleanups", "timer", "addDomEvent", "onFocusin", "fn", "trackInteractOutside", "nodeOrFn", "trackEscapeKeydown", "node", "fn", "handleKeyDown", "event", "addDomEvent", "getDocument", "layerStack", "layer", "index", "highestBlockingIndex", "target", "contains", "branch", "num", "originalBodyPointerEvents", "assignPointerEventToLayers", "clearPointerEvent", "disablePointerEventsOutside", "peristentElements", "doc", "cleanups", "persistedCleanup", "waitForElements", "el", "setStyle", "trackDismissableElementImpl", "options", "warn", "onDismiss", "pointerBlocking", "excludeContainers", "debug", "onPointerDownOutside", "getEventTarget", "onFocusOutside", "onEscapeKeyDown", "exclude", "containers", "_containers", "persistentElements", "isHTMLElement", "trackInteractOutside", "trackDismissableElement", "nodeOrFn", "defer", "func", "raf", "v", "isFunction", "createPoint", "x", "y", "createRect", "r", "x", "y", "width", "height", "midX", "midY", "createPoint", "getRectCorners", "v", "top", "createPoint", "right", "bottom", "left", "min", "max", "getElementPolygon", "rectValue", "placement", "rect", "createRect", "top", "right", "left", "bottom", "getRectCorners", "base", "isPointInPolygon", "polygon", "point", "x", "y", "c", "i", "j", "xi", "yi", "xj", "yj", "sign", "abs", "min", "anatomy", "createAnatomy", "parts", "dom", "createScope", "ctx", "id", "selector", "queryAll", "first", "last", "loop", "nextById", "prevById", "key", "getByTypeahead", "v", "isHTMLElement", "el", "connect", "state", "send", "normalize", "isSubmenu", "isTypingAhead", "composite", "open", "popperStyles", "getPlacementStyles", "getItemState", "props", "getOptionItemProps", "valueText", "getOptionItemState", "getItemProps", "closeOnSelect", "itemState", "dataAttr", "event", "target", "isDownloadingEvent", "isOpeningInNewTab", "isLeftClick", "clickIfLink", "nextOpen", "value", "parent", "child", "options", "evt", "getNativeEvent", "point", "getEventPoint", "childApi", "mergeProps", "disabled", "isContextMenuEvent", "keyMap", "getEventKey", "exec", "isSelfTarget", "getEventTarget", "isValidTabEvent", "item", "isPrintableKey", "isModifierKey", "isEditableElement", "type", "onCheckedChange", "option", "not", "and", "or", "guards", "machine", "userContext", "compact", "createMachine", "cast", "ref", "_ctx", "isPointInPolygon", "getPositionerEl", "getPlacement", "data", "_evt", "trackDismissableElement", "closeRootMenu", "isWithinPolygon", "doc", "addDomEvent", "e", "getState", "itemEl", "contentEl", "scrollIntoView", "raf", "observeAttributes", "getAnchorRect", "checked", "menu", "placement", "rect", "polygon", "getElementPolygon", "bleed", "getPlacementSide", "set", "contains", "getFirstTabbable", "next", "prev", "node", "isEqual", "createProps", "splitProps", "createSplitProps", "itemProps", "splitItemProps", "itemGroupLabelProps", "splitItemGroupLabelProps", "itemGroupProps", "splitItemGroupProps", "optionItemProps", "splitOptionItemProps", "Menu", "machine", "connect", "normalizeProps", "trigger", "positioner", "content", "spreadProps", "label", "group", "separator", "item", "Hooks", "Accordion", "Menu"]
}
