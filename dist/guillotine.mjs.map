{
  "version": 3,
  "sources": ["../assets/node_modules/@zag-js/anatomy/src/create-anatomy.ts", "../assets/node_modules/@zag-js/dom-query/src/attrs.ts", "../assets/node_modules/@zag-js/dom-query/src/constants.ts", "../assets/node_modules/@zag-js/dom-query/src/is.ts", "../assets/node_modules/@zag-js/dom-query/src/contains.ts", "../assets/node_modules/@zag-js/dom-query/src/env.ts", "../assets/node_modules/@zag-js/dom-query/src/platform.ts", "../assets/node_modules/@zag-js/dom-query/src/event.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-id.ts", "../assets/node_modules/@zag-js/dom-query/src/sanitize.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-text.ts", "../assets/node_modules/@zag-js/dom-query/src/get-by-typeahead.ts", "../assets/node_modules/@zag-js/dom-query/src/get-computed-style.ts", "../assets/node_modules/@zag-js/dom-query/src/get-parent-node.ts", "../assets/node_modules/@zag-js/dom-query/src/get-scroll-position.ts", "../assets/node_modules/@zag-js/dom-query/src/tabbable.ts", "../assets/node_modules/@zag-js/dom-query/src/initial-focus.ts", "../assets/node_modules/@zag-js/dom-query/src/is-editable-element.ts", "../assets/node_modules/@zag-js/dom-query/src/is-hidden-element.ts", "../assets/node_modules/@zag-js/dom-query/src/is-overflow-element.ts", "../assets/node_modules/@zag-js/dom-query/src/raf.ts", "../assets/node_modules/@zag-js/dom-query/src/observe-attributes.ts", "../assets/node_modules/@zag-js/dom-query/src/observe-children.ts", "../assets/node_modules/@zag-js/dom-query/src/overflow.ts", "../assets/node_modules/@zag-js/dom-query/src/proxy-tab-focus.ts", "../assets/node_modules/@zag-js/dom-query/src/query.ts", "../assets/node_modules/@zag-js/dom-query/src/scope.ts", "../assets/node_modules/@zag-js/dom-query/src/scroll-into-view.ts", "../assets/node_modules/@zag-js/dom-query/src/set.ts", "../assets/node_modules/@zag-js/dom-query/src/visually-hidden.ts", "../assets/node_modules/@zag-js/dom-query/src/wait-for.ts", "../assets/node_modules/@zag-js/dom-event/src/add-dom-event.ts", "../assets/node_modules/@zag-js/dom-event/src/assertion.ts", "../assets/node_modules/@zag-js/dom-event/src/click-link.ts", "../assets/node_modules/@zag-js/dom-event/src/queue-before-event.ts", "../assets/node_modules/@zag-js/dom-event/src/fire-event.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-key.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-point.ts", "../assets/node_modules/@zag-js/dom-event/src/get-event-step.ts", "../assets/node_modules/@zag-js/dom-event/src/get-native-event.ts", "../assets/node_modules/@zag-js/dom-event/src/get-point-value.ts", "../assets/node_modules/@zag-js/dom-event/src/request-pointer-lock.ts", "../assets/node_modules/@zag-js/dom-event/src/track-focus-visible.ts", "../assets/node_modules/@zag-js/dom-event/src/pipe.ts", "../assets/node_modules/@zag-js/dom-event/src/track-pointer-move.ts", "../assets/node_modules/@zag-js/dom-event/src/track-press.ts", "../assets/node_modules/@zag-js/dom-event/src/track-visual-viewport.ts", "../assets/node_modules/@zag-js/utils/src/array.ts", "../assets/node_modules/@zag-js/utils/src/equal.ts", "../assets/node_modules/@zag-js/utils/src/functions.ts", "../assets/node_modules/@zag-js/utils/src/guard.ts", "../assets/node_modules/@zag-js/utils/src/object.ts", "../assets/node_modules/@zag-js/utils/src/split-props.ts", "../assets/node_modules/@zag-js/utils/src/warning.ts", "../assets/node_modules/proxy-compare/dist/index.js", "../assets/node_modules/@zag-js/store/src/global.ts", "../assets/node_modules/@zag-js/store/src/proxy.ts", "../assets/node_modules/@zag-js/store/src/proxy-computed.ts", "../assets/node_modules/klona/full/index.mjs", "../assets/node_modules/@zag-js/core/src/index.ts", "../assets/node_modules/@zag-js/utilities/core/src/array.ts", "../assets/node_modules/@zag-js/utilities/core/src/functions.ts", "../assets/node_modules/@zag-js/utilities/core/src/guard.ts", "../assets/node_modules/@zag-js/utilities/core/src/object.ts", "../assets/node_modules/@zag-js/utilities/core/src/warning.ts", "../assets/node_modules/@zag-js/core/src/deep-merge.ts", "../assets/node_modules/@zag-js/core/src/utils.ts", "../assets/node_modules/@zag-js/core/src/guard-utils.ts", "../assets/node_modules/@zag-js/core/src/machine.ts", "../assets/node_modules/@zag-js/core/src/create-proxy.ts", "../assets/node_modules/@zag-js/core/src/delay-utils.ts", "../assets/node_modules/@zag-js/core/src/transition-utils.ts", "../assets/node_modules/@zag-js/core/src/merge-props.ts", "../assets/node_modules/@zag-js/types/src/prop-types.ts", "../assets/node_modules/@zag-js/types/src/create-props.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.anatomy.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.connect.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.dom.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.machine.ts", "../assets/node_modules/@zag-js/accordion/src/accordion.props.ts", "../assets/js/normalize-props.js", "../assets/js/spread-props.js", "../assets/js/accordion.js", "../assets/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../assets/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../assets/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../assets/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../assets/node_modules/@zag-js/popper/src/get-placement.ts", "../assets/node_modules/@zag-js/popper/src/get-anchor.ts", "../assets/node_modules/@zag-js/popper/src/middleware.ts", "../assets/node_modules/@zag-js/popper/src/placement.ts", "../assets/node_modules/@zag-js/popper/src/get-styles.ts", "../assets/node_modules/@zag-js/interact-outside/src/index.ts", "../assets/node_modules/@zag-js/interact-outside/src/get-window-frames.ts", "../assets/node_modules/@zag-js/dismissable/src/dismissable-layer.ts", "../assets/node_modules/@zag-js/dismissable/src/escape-keydown.ts", "../assets/node_modules/@zag-js/dismissable/src/layer-stack.ts", "../assets/node_modules/@zag-js/dismissable/src/pointer-event-outside.ts", "../assets/node_modules/@zag-js/rect-utils/src/affine-transform.ts", "../assets/node_modules/@zag-js/rect-utils/src/align.ts", "../assets/node_modules/@zag-js/rect-utils/src/clamp.ts", "../assets/node_modules/@zag-js/rect-utils/src/rect.ts", "../assets/node_modules/@zag-js/rect-utils/src/intersection.ts", "../assets/node_modules/@zag-js/rect-utils/src/distance.ts", "../assets/node_modules/@zag-js/rect-utils/src/closest.ts", "../assets/node_modules/@zag-js/rect-utils/src/constrain.ts", "../assets/node_modules/@zag-js/rect-utils/src/contains.ts", "../assets/node_modules/@zag-js/rect-utils/src/equality.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-element.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-points.ts", "../assets/node_modules/@zag-js/rect-utils/src/union.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-range.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-rotation.ts", "../assets/node_modules/@zag-js/rect-utils/src/from-window.ts", "../assets/node_modules/@zag-js/rect-utils/src/operations.ts", "../assets/node_modules/@zag-js/rect-utils/src/polygon.ts", "../assets/node_modules/@zag-js/rect-utils/src/compass.ts", "../assets/node_modules/@zag-js/rect-utils/src/resize.ts", "../assets/node_modules/@zag-js/menu/src/menu.anatomy.ts", "../assets/node_modules/@zag-js/menu/src/menu.connect.ts", "../assets/node_modules/@zag-js/menu/src/menu.dom.ts", "../assets/node_modules/@zag-js/menu/src/menu.machine.ts", "../assets/node_modules/@zag-js/menu/src/menu.props.ts", "../assets/js/menu.js", "../assets/js/index.js"],
  "sourcesContent": ["export interface AnatomyPart {\n  selector: string\n  attrs: Record<\"data-scope\" | \"data-part\", string>\n}\n\nexport type AnatomyInstance<T extends string> = Omit<Anatomy<T>, \"parts\">\n\nexport type AnatomyPartName<T> = T extends AnatomyInstance<infer U> ? U : never\n\nexport interface Anatomy<T extends string> {\n  parts: <U extends string>(...parts: U[]) => AnatomyInstance<U>\n  extendWith: <V extends string>(...parts: V[]) => AnatomyInstance<T | V>\n  build: () => Record<T, AnatomyPart>\n  rename: (newName: string) => Anatomy<T>\n  keys: () => T[]\n}\n\nexport const createAnatomy = <T extends string>(name: string, parts = [] as T[]): Anatomy<T> => ({\n  parts: (...values) => {\n    if (isEmpty(parts)) {\n      return createAnatomy(name, values)\n    }\n    throw new Error(\"createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?\")\n  },\n  extendWith: (...values) => createAnatomy(name, [...parts, ...values]),\n  rename: (newName) => createAnatomy(newName, parts),\n  keys: () => parts,\n  build: () =>\n    [...new Set(parts)].reduce<Record<string, AnatomyPart>>(\n      (prev, part) =>\n        Object.assign(prev, {\n          [part]: {\n            selector: [\n              `&[data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n              `& [data-scope=\"${toKebabCase(name)}\"][data-part=\"${toKebabCase(part)}\"]`,\n            ].join(\", \"),\n            attrs: { \"data-scope\": toKebabCase(name), \"data-part\": toKebabCase(part) },\n          },\n        }),\n      {},\n    ),\n})\n\nconst toKebabCase = (value: string) =>\n  value\n    .replace(/([A-Z])([A-Z])/g, \"$1-$2\")\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/[\\s_]+/g, \"-\")\n    .toLowerCase()\n\nconst isEmpty = <T>(v: T[]): boolean => v.length === 0\n", "import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n", "export const MAX_Z_INDEX = 2147483647\n", "export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => el != null && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  el != null && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n", "import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n", "import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n", "export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/) && !isTouchDevice()\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n", "import { contains } from \"./contains\"\nimport { isApple } from \"./platform\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nexport function getEventTarget<T extends EventTarget>(event: Pick<UIEvent, \"target\" | \"composedPath\">): T | null {\n  return (event.composedPath?.()[0] ?? event.target) as T | null\n}\n\nexport const isSelfTarget = (event: Pick<UIEvent, \"currentTarget\" | \"target\" | \"composedPath\">) => {\n  return contains(event.currentTarget as Node, getEventTarget(event))\n}\n\nexport function isOpeningInNewTab(event: Pick<MouseEvent, \"currentTarget\" | \"metaKey\" | \"ctrlKey\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const isAppleDevice = isApple()\n  if (isAppleDevice && !event.metaKey) return false\n  if (!isAppleDevice && !event.ctrlKey) return false\n\n  const localName = element.localName\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isDownloadingEvent(event: Pick<MouseEvent, \"altKey\" | \"currentTarget\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const localName = element.localName\n  if (!event.altKey) return false\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n", "export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n", "export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n", "import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n", "import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n", "import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n", "import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n", "import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n", "const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nconst isFrame = (element: any): element is HTMLIFrameElement => isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nfunction isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\ntype IncludeContainerType = boolean | \"if-empty\"\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nconst focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n\n/**\n * Returns the focusable elements within the element\n */\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n\n/**\n * Whether this element is focusable\n */\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): [HTMLElement, HTMLElement] | [null, null] {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n", "import { getFirstTabbable, getTabbableEdges } from \"./tabbable\"\n\nexport function getInitialFocus(\n  container: HTMLElement | null,\n  getInitialEl?: () => HTMLElement | null,\n): HTMLElement | undefined {\n  let node: HTMLElement | null | undefined = null\n  node ||= typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl\n  node ||= container?.querySelector<HTMLElement>(\"[data-autofocus],[autofocus]\")\n  node ||= getFirstTabbable(container)\n  return node || container || undefined\n}\n\nexport function isValidTabEvent(event: Pick<KeyboardEvent, \"shiftKey\" | \"currentTarget\">): boolean {\n  const container = event.currentTarget as HTMLElement | null\n  if (!container) return false\n\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container)\n  const doc = container.ownerDocument || document\n\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false\n  if (!firstTabbable && !lastTabbable) return false\n\n  return true\n}\n", "import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n", "export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n", "import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n", "export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveAttributeOptions {\n  attributes: string[]\n  callback(record: MutationRecord): void\n  defer?: boolean\n}\n\nfunction observeAttributesImpl(node: MaybeElement, options: ObserveAttributeOptions) {\n  if (!node) return\n  const { attributes, callback: fn } = options\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n  return () => obs.disconnect()\n}\n\nexport function observeAttributes(nodeOrFn: NodeOrFn, options: ObserveAttributeOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeAttributesImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveChildrenOptions {\n  callback: MutationCallback\n  defer?: boolean\n}\n\nfunction observeChildrenImpl(node: MaybeElement, options: ObserveChildrenOptions) {\n  const { callback: fn } = options\n  if (!node) return\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n  return () => obs.disconnect()\n}\n\nexport function observeChildren(nodeOrFn: NodeOrFn, options: ObserveChildrenOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeChildrenImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n", "import { raf } from \"./raf\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus)\n    } else {\n      elementToFocus.focus()\n    }\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n", "import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const screen = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(screen.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => screen.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => screen.getDoc(ctx).activeElement as HTMLElement | null,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === screen.getActiveElement(ctx),\n    getById: <T extends HTMLElement = HTMLElement>(ctx: ScopeContext, id: string) =>\n      screen.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...screen, ...methods }\n}\n", "import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n", "const cleanups = new WeakMap<Element, Map<string, () => void>>()\n\nexport function set(element: Element, key: string, setup: () => () => void) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, new Map())\n  }\n\n  const elementCleanups = cleanups.get(element)!\n  const prevCleanup = elementCleanups.get(key)\n\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup())\n    return () => {\n      elementCleanups.get(key)?.()\n      elementCleanups.delete(key)\n    }\n  }\n\n  const cleanup = setup()\n\n  const nextCleanup = () => {\n    cleanup()\n    prevCleanup()\n    elementCleanups.delete(key)\n  }\n\n  elementCleanups.set(key, nextCleanup)\n\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup\n    if (!isCurrent) return\n    cleanup()\n    elementCleanups.set(key, prevCleanup)\n  }\n}\n\nexport function setAttribute(element: Element, attr: string, value: string) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr)\n    element.setAttribute(attr, value)\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr)\n      } else {\n        element.setAttribute(attr, previousValue)\n      }\n    }\n  }\n\n  return set(element, attr, setup)\n}\n\nexport function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]) {\n  const setup = () => {\n    const exists = property in element\n    const previousValue = element[property]\n    element[property] = value\n    return () => {\n      if (!exists) {\n        delete element[property]\n      } else {\n        element[property] = previousValue\n      }\n    }\n  }\n\n  return set(element, property, setup)\n}\n\nexport function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!element) return () => {}\n\n  const setup = () => {\n    const prevStyle = element.style.cssText\n    Object.assign(element.style, style)\n    return () => {\n      element.style.cssText = prevStyle\n    }\n  }\n\n  return set(element, \"style\", setup)\n}\n", "export const visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\",\n} as const\n", "import { isHTMLElement } from \"./is\"\n\ntype ElementGetter = () => Element | null\n\nconst fps = 1000 / 60\n\nexport function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void) {\n  const el = query()\n\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el)\n    return () => void 0\n  } else {\n    const timerId = setInterval(() => {\n      const el = query()\n      if (isHTMLElement(el) && el.isConnected) {\n        cb(el)\n        clearInterval(timerId)\n      }\n    }, fps)\n\n    return () => clearInterval(timerId)\n  }\n}\n\nexport function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void) {\n  const cleanups: VoidFunction[] = []\n\n  queries?.forEach((query) => {\n    const clean = waitForElement(query, cb)\n    cleanups.push(clean)\n  })\n\n  return () => {\n    cleanups.forEach((fn) => fn())\n  }\n}\n", "interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n", "import { isMac } from \"@zag-js/dom-query\"\n\nexport function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isMac() && e.ctrlKey && e.button === 0)\n}\n\nexport const isModifierKey = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n", "import { isFirefox } from \"@zag-js/dom-query\"\nimport { queueBeforeEvent } from \"./queue-before-event\"\n\nfunction isLinkElement(element: HTMLElement | null | undefined) {\n  return element?.matches(\"a[href]\") ?? false\n}\n\nexport function clickIfLink(element: HTMLElement | null | undefined) {\n  if (!isLinkElement(element)) return\n  const click = () => element!.click()\n  if (isFirefox()) {\n    queueBeforeEvent(element!, \"keyup\", click)\n  } else {\n    queueMicrotask(click)\n  }\n}\n", "export function queueBeforeEvent(element: Element, type: string, cb: () => void) {\n  const createTimer = (callback: () => void) => {\n    const timerId = requestAnimationFrame(callback)\n    return () => cancelAnimationFrame(timerId)\n  }\n\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true)\n    cb()\n  })\n  const callSync = () => {\n    cancelTimer()\n    cb()\n  }\n\n  element.addEventListener(type, callSync, { once: true, capture: true })\n  return cancelTimer\n}\n", "export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n", "import type { EventKeyOptions } from \"./types\"\n\nconst keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n", "type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: AnyPointerEvent, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n", "const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n", "import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> =\n  JSX.ChangeEvent<any> extends E ? InputEvent : E extends JSX.SyntheticEvent<any, infer T> ? T : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n", "function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n", "import { getWindow, isMac } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { pipe } from \"./pipe\"\n\nexport interface TrackFocusOptions {\n  /**\n   * Callback to be called when the element receives focus and is focus-visible.\n   */\n  onFocus?(e: FocusEvent): void\n  /**\n   * Callback to be called when the element loses focus.\n   */\n  onBlur?(e: FocusEvent): void\n}\n\nconst isValidKey = (e: KeyboardEvent) => {\n  return !(\n    e.metaKey ||\n    (!isMac() && e.altKey) ||\n    e.ctrlKey ||\n    e.key === \"Control\" ||\n    e.key === \"Shift\" ||\n    e.key === \"Meta\"\n  )\n}\n\nexport function trackFocusVisible(node: Element | null, options: TrackFocusOptions) {\n  if (!node) return\n  const { onFocus, onBlur } = options\n\n  const win = getWindow(node)\n\n  let focused = false\n\n  const handleFocus = (e: FocusEvent) => {\n    let isFocusVisible = false\n\n    try {\n      isFocusVisible = node.matches(\":focus-visible\")\n    } catch {\n      isFocusVisible = true\n    }\n\n    if (!isFocusVisible) return\n\n    focused = true\n    onFocus?.(e)\n  }\n\n  const handleBlur = (e: FocusEvent) => {\n    if (!focused) return\n    focused = false\n    onBlur?.(e)\n  }\n\n  const handleKeydown = (e: KeyboardEvent) => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return\n    focused = true\n    const evt = new win.FocusEvent(\"focus\")\n    onFocus?.(evt)\n  }\n\n  return pipe(\n    addDomEvent(node, \"focusin\", handleFocus),\n    addDomEvent(node, \"focusout\", handleBlur),\n    addDomEvent(node, \"keydown\", handleKeydown, true),\n  )\n}\n", "export const pipe =\n  <T>(...fns: Array<(arg: T) => T>) =>\n  (arg: T) =>\n    fns.reduce((acc, fn) => fn(acc), arg)\n\nexport const noop = () => void 0\n", "import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TimestampedPoint extends Point {\n  /**\n   * The time when the point was recorded.\n   */\n  timestamp: number\n}\n\nexport interface PointerMoveDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n  /**\n   * The velocity of the pointer on the x and y axis.\n   */\n  velocity: Point\n}\n\nexport interface PointerMoveHandlers {\n  /**\n   * Called when the pointer is released.\n   */\n  onPointerUp: VoidFunction\n  /**\n   * Called when the pointer moves.\n   */\n  onPointerMove: (details: PointerMoveDetails) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const history: TimestampedPoint[] = []\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n    history.push({ ...point, timestamp: performance.now() })\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n    history.length = 0\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nfunction ms(seconds: number): number {\n  return seconds * 1000\n}\n\nfunction sec(milliseconds: number): number {\n  return milliseconds / 1000\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp)\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y),\n  }\n}\n", "import { contains, getDocument, getEventTarget, getWindow } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\nimport { noop, pipe } from \"./pipe\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TapDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n}\n\nexport interface TrackPressOptions {\n  /**\n   * The element that will be used to track the pointer events.\n   */\n  pointerNode: Element | null\n  /**\n   * The element that will be used to track the keyboard focus events.\n   */\n  keyboardNode?: Element | null\n  /**\n   * A function that determines if the key is valid for the press event.\n   */\n  isValidKey?(event: KeyboardEvent): boolean\n  /**\n   * A function that will be called when the pointer is pressed.\n   */\n  onPress?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed down.\n   */\n  onPressStart?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed up or cancelled.\n   */\n  onPressEnd?(details: TapDetails): void\n}\n\nexport function trackPress(options: TrackPressOptions) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\",\n  } = options\n\n  if (!pointerNode) return noop\n\n  const win = getWindow(pointerNode)\n  const doc = getDocument(pointerNode)\n\n  let removeStartListeners: VoidFunction = noop\n  let removeEndListeners: VoidFunction = noop\n  let removeAccessibleListeners: VoidFunction = noop\n\n  const getInfo = (event: PointerEvent): TapDetails => ({\n    point: getEventPoint(event),\n    event,\n  })\n\n  function startPress(event: PointerEvent) {\n    onPressStart?.(getInfo(event))\n  }\n\n  function cancelPress(event: PointerEvent) {\n    onPressEnd?.(getInfo(event))\n  }\n\n  const startPointerPress = (startEvent: PointerEvent) => {\n    removeEndListeners()\n\n    const endPointerPress = (endEvent: PointerEvent) => {\n      const target = getEventTarget<Element>(endEvent)\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent))\n      } else {\n        onPressEnd?.(getInfo(endEvent))\n      }\n    }\n\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress })\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, { passive: !onPressEnd })\n\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener)\n\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault()\n    }\n\n    startPress(startEvent)\n  }\n\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart })\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress)\n\n  removeStartListeners = pipe(removePointerListener, removeFocusListener)\n\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent: KeyboardEvent) => {\n      if (!isValidKey(keydownEvent)) return\n\n      const handleKeyup = (keyupEvent: KeyboardEvent) => {\n        if (!isValidKey(keyupEvent)) return\n        const evt = new win.PointerEvent(\"pointerup\")\n        const info = getInfo(evt)\n        onPress?.(info)\n        onPressEnd?.(info)\n      }\n\n      removeEndListeners()\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup)\n\n      const evt = new win.PointerEvent(\"pointerdown\")\n      startPress(evt)\n    }\n\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\")\n      cancelPress(evt)\n    }\n\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown)\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur)\n\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener)\n  }\n\n  return function () {\n    removeStartListeners()\n    removeEndListeners()\n    removeAccessibleListeners()\n  }\n}\n", "import { addDomEvent } from \"./add-dom-event\"\n\nexport interface ViewportSize {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "const isArrayLike = (value: any) => value?.constructor.name === \"Array\"\n\nexport const isEqual = (a: any, b: any): boolean => {\n  if (Object.is(a, b)) return true\n\n  if ((a == null && b != null) || (a != null && b == null)) return false\n\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b)\n  }\n\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString()\n  }\n\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return Array.from(a).toString() === Array.from(b).toString()\n  }\n\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false\n\n  const keys = Object.keys(b ?? Object.create(null))\n  const length = keys.length\n\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i])\n    if (!hasKey) return false\n  }\n\n  for (let i = 0; i < length; i++) {\n    const key = keys[i]\n    if (!isEqual(a[key], b[key])) return false\n  }\n\n  return true\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n", "type Dict = Record<string, any>\n\nexport function splitProps<T extends Dict>(props: T, keys: (keyof T)[]) {\n  const rest: Dict = {}\n  const result: Dict = {}\n\n  const keySet = new Set(keys)\n\n  for (const key in props) {\n    if (keySet.has(key)) {\n      result[key] = props[key]\n    } else {\n      rest[key] = props[key]\n    }\n  }\n\n  return [result, rest]\n}\n\nexport const createSplitProps = <T extends Dict>(keys: (keyof T)[]) => {\n  return function split<Props extends T>(props: Props) {\n    return splitProps(props, keys) as [T, Omit<Props, keyof T>]\n  }\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "/* eslint @typescript-eslint/no-explicit-any: off */\n// symbols\nconst TRACK_MEMO_SYMBOL = Symbol();\nconst GET_ORIGINAL_SYMBOL = Symbol();\n// properties\nconst AFFECTED_PROPERTY = 'a';\nconst IS_TARGET_COPIED_PROPERTY = 'f';\nconst PROXY_PROPERTY = 'p';\nconst PROXY_CACHE_PROPERTY = 'c';\nconst TARGET_CACHE_PROPERTY = 't';\nconst NEXT_OBJECT_PROPERTY = 'n';\nconst CHANGED_PROPERTY = 'g';\nconst HAS_KEY_PROPERTY = 'h';\nconst ALL_OWN_KEYS_PROPERTY = 'w';\nconst HAS_OWN_KEY_PROPERTY = 'o';\nconst KEYS_PROPERTY = 'k';\n// function to create a new bare proxy\nlet newProxy = (target, handler) => new Proxy(target, handler);\n// get object prototype\nconst getProto = Object.getPrototypeOf;\nconst objectsToTrack = new WeakMap();\n// check if obj is a plain object or an array\nconst isObjectToTrack = (obj) => obj &&\n    (objectsToTrack.has(obj)\n        ? objectsToTrack.get(obj)\n        : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);\n// check if it is object\nconst isObject = (x) => typeof x === 'object' && x !== null;\n// Properties that are both non-configurable and non-writable will break\n// the proxy get trap when we try to return a recursive/child compare proxy\n// from them. We can avoid this by making a copy of the target object with\n// all descriptors marked as configurable, see `copyTargetObject`.\n// See: https://github.com/dai-shi/proxy-compare/pull/8\nconst needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);\n// Make a copy with all descriptors marked as configurable.\nconst copyTargetObject = (obj) => {\n    if (Array.isArray(obj)) {\n        // Arrays need a special way to copy\n        return Array.from(obj);\n    }\n    // For non-array objects, we create a new object keeping the prototype\n    // with changing all configurable options (otherwise, proxies will complain)\n    const descriptors = Object.getOwnPropertyDescriptors(obj);\n    Object.values(descriptors).forEach((desc) => {\n        desc.configurable = true;\n    });\n    return Object.create(getProto(obj), descriptors);\n};\nconst createProxyHandler = (origObj, isTargetCopied) => {\n    const state = {\n        [IS_TARGET_COPIED_PROPERTY]: isTargetCopied,\n    };\n    let trackObject = false; // for trackMemo\n    const recordUsage = (type, key) => {\n        if (!trackObject) {\n            let used = state[AFFECTED_PROPERTY].get(origObj);\n            if (!used) {\n                used = {};\n                state[AFFECTED_PROPERTY].set(origObj, used);\n            }\n            if (type === ALL_OWN_KEYS_PROPERTY) {\n                used[ALL_OWN_KEYS_PROPERTY] = true;\n            }\n            else {\n                let set = used[type];\n                if (!set) {\n                    set = new Set();\n                    used[type] = set;\n                }\n                set.add(key);\n            }\n        }\n    };\n    const recordObjectAsUsed = () => {\n        trackObject = true;\n        state[AFFECTED_PROPERTY].delete(origObj);\n    };\n    const handler = {\n        get(target, key) {\n            if (key === GET_ORIGINAL_SYMBOL) {\n                return origObj;\n            }\n            recordUsage(KEYS_PROPERTY, key);\n            return createProxy(Reflect.get(target, key), state[AFFECTED_PROPERTY], state[PROXY_CACHE_PROPERTY], state[TARGET_CACHE_PROPERTY]);\n        },\n        has(target, key) {\n            if (key === TRACK_MEMO_SYMBOL) {\n                recordObjectAsUsed();\n                return true;\n            }\n            recordUsage(HAS_KEY_PROPERTY, key);\n            return Reflect.has(target, key);\n        },\n        getOwnPropertyDescriptor(target, key) {\n            recordUsage(HAS_OWN_KEY_PROPERTY, key);\n            return Reflect.getOwnPropertyDescriptor(target, key);\n        },\n        ownKeys(target) {\n            recordUsage(ALL_OWN_KEYS_PROPERTY);\n            return Reflect.ownKeys(target);\n        },\n    };\n    if (isTargetCopied) {\n        handler.set = handler.deleteProperty = () => false;\n    }\n    return [handler, state];\n};\nconst getOriginalObject = (obj) => \n// unwrap proxy\nobj[GET_ORIGINAL_SYMBOL] ||\n    // otherwise\n    obj;\n/**\n * Create a proxy.\n *\n * This function will create a proxy at top level and proxy nested objects as you access them,\n * in order to keep track of which properties were accessed via get/has proxy handlers:\n *\n * NOTE: Printing of WeakMap is hard to inspect and not very readable\n * for this purpose you can use the `affectedToPathList` helper.\n *\n * @param {object} obj - Object that will be wrapped on the proxy.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that will hold the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [proxyCache] -\n * WeakMap that will help keep referential identity for proxies.\n * @returns {Proxy<object>} - Object wrapped in a proxy.\n *\n * @example\n * import { createProxy } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n * const proxy = createProxy(original, affected);\n *\n * proxy.a // Will mark as used and track its value.\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"a\"\n *\n * proxy.d // Will mark \"d\" as accessed to track and proxy itself ({ e: \"3\" }).\n * // This will update the affected WeakMap with original as key\n * // and a Set with \"d\"\n */\nexport const createProxy = (obj, affected, proxyCache, targetCache) => {\n    if (!isObjectToTrack(obj))\n        return obj;\n    let targetAndCopied = targetCache && targetCache.get(obj);\n    if (!targetAndCopied) {\n        const target = getOriginalObject(obj);\n        if (needsToCopyTargetObject(target)) {\n            targetAndCopied = [target, copyTargetObject(target)];\n        }\n        else {\n            targetAndCopied = [target];\n        }\n        targetCache === null || targetCache === void 0 ? void 0 : targetCache.set(obj, targetAndCopied);\n    }\n    const [target, copiedTarget] = targetAndCopied;\n    let handlerAndState = proxyCache && proxyCache.get(target);\n    if (!handlerAndState ||\n        handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {\n        handlerAndState = createProxyHandler(target, !!copiedTarget);\n        handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);\n        if (proxyCache) {\n            proxyCache.set(target, handlerAndState);\n        }\n    }\n    handlerAndState[1][AFFECTED_PROPERTY] = affected;\n    handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;\n    handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache;\n    return handlerAndState[1][PROXY_PROPERTY];\n};\nconst isAllOwnKeysChanged = (prevObj, nextObj) => {\n    const prevKeys = Reflect.ownKeys(prevObj);\n    const nextKeys = Reflect.ownKeys(nextObj);\n    return (prevKeys.length !== nextKeys.length ||\n        prevKeys.some((k, i) => k !== nextKeys[i]));\n};\n/**\n * Compare changes on objects.\n *\n * This will compare the affected properties on tracked objects inside the proxy\n * to check if there were any changes made to it,\n * by default if no property was accessed on the proxy it will attempt to do a\n * reference equality check for the objects provided (Object.is(a, b)). If you access a property\n * on the proxy, then isChanged will only compare the affected properties.\n *\n * @param {object} prevObj - The previous object to compare.\n * @param {object} nextObj - Object to compare with the previous one.\n * @param {WeakMap<object, unknown>} affected -\n * WeakMap that holds the tracking of which properties in the proxied object were accessed.\n * @param {WeakMap<object, unknown>} [cache] -\n * WeakMap that holds a cache of the comparisons for better performance with repetitive comparisons,\n * and to avoid infinite loop with circular structures.\n * @returns {boolean} - Boolean indicating if the affected property on the object has changed.\n *\n * @example\n * import { createProxy, isChanged } from 'proxy-compare';\n *\n * const obj = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(obj, affected);\n *\n * proxy.a\n *\n * isChanged(obj, { a: \"1\" }, affected) // false\n *\n * proxy.a = \"2\"\n *\n * isChanged(obj, { a: \"1\" }, affected) // true\n */\nexport const isChanged = (prevObj, nextObj, affected, cache, isEqual = Object.is) => {\n    if (isEqual(prevObj, nextObj)) {\n        return false;\n    }\n    if (!isObject(prevObj) || !isObject(nextObj))\n        return true;\n    const used = affected.get(getOriginalObject(prevObj));\n    if (!used)\n        return true;\n    if (cache) {\n        const hit = cache.get(prevObj);\n        if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {\n            return hit[CHANGED_PROPERTY];\n        }\n        // for object with cycles\n        cache.set(prevObj, {\n            [NEXT_OBJECT_PROPERTY]: nextObj,\n            [CHANGED_PROPERTY]: false,\n        });\n    }\n    let changed = null;\n    try {\n        for (const key of used[HAS_KEY_PROPERTY] || []) {\n            changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);\n            if (changed)\n                return changed;\n        }\n        if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n            changed = isAllOwnKeysChanged(prevObj, nextObj);\n            if (changed)\n                return changed;\n        }\n        else {\n            for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {\n                const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);\n                const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);\n                changed = hasPrev !== hasNext;\n                if (changed)\n                    return changed;\n            }\n        }\n        for (const key of used[KEYS_PROPERTY] || []) {\n            changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual);\n            if (changed)\n                return changed;\n        }\n        if (changed === null)\n            changed = true;\n        return changed;\n    }\n    finally {\n        if (cache) {\n            cache.set(prevObj, {\n                [NEXT_OBJECT_PROPERTY]: nextObj,\n                [CHANGED_PROPERTY]: changed,\n            });\n        }\n    }\n};\n// explicitly track object with memo\nexport const trackMemo = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return TRACK_MEMO_SYMBOL in obj;\n    }\n    return false;\n};\n/**\n * Unwrap proxy to get the original object.\n *\n * Used to retrieve the original object used to create the proxy instance with `createProxy`.\n *\n * @param {Proxy<object>} obj -  The proxy wrapper of the originial object.\n * @returns {object | null} - Return either the unwrapped object if exists.\n *\n * @example\n * import { createProxy, getUntracked } from 'proxy-compare';\n *\n * const original = { a: \"1\", c: \"2\", d: { e: \"3\" } };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n * const originalFromProxy = getUntracked(proxy)\n *\n * Object.is(original, originalFromProxy) // true\n * isChanged(original, originalFromProxy, affected) // false\n */\nexport const getUntracked = (obj) => {\n    if (isObjectToTrack(obj)) {\n        return obj[GET_ORIGINAL_SYMBOL] || null;\n    }\n    return null;\n};\n/**\n * Mark object to be tracked.\n *\n * This function marks an object that will be passed into `createProxy`\n * as marked to track or not. By default only Array and Object are marked to track,\n * so this is useful for example to mark a class instance to track or to mark a object\n * to be untracked when creating your proxy.\n *\n * @param obj - Object to mark as tracked or not.\n * @param mark - Boolean indicating whether you want to track this object or not.\n * @returns - No return.\n *\n * @example\n * import { createProxy, markToTrack, isChanged } from 'proxy-compare';\n *\n * const nested = { e: \"3\" }\n *\n * markToTrack(nested, false)\n *\n * const original = { a: \"1\", c: \"2\", d: nested };\n * const affected = new WeakMap();\n *\n * const proxy = createProxy(original, affected);\n *\n * proxy.d.e\n *\n * isChanged(original, { d: { e: \"3\" } }, affected) // true\n */\nexport const markToTrack = (obj, mark = true) => {\n    objectsToTrack.set(obj, mark);\n};\n/**\n * Convert `affected` to path list\n *\n * `affected` is a weak map which is not printable.\n * This function is can convert it to printable path list.\n * It's for debugging purpose.\n *\n * @param obj - An object that is used with `createProxy`.\n * @param affected - A weak map that is used with `createProxy`.\n * @param onlyWithValues - An optional boolean to exclude object getters.\n * @returns - An array of paths.\n */\nexport const affectedToPathList = (obj, affected, onlyWithValues) => {\n    const list = [];\n    const seen = new WeakSet();\n    const walk = (x, path) => {\n        var _a, _b, _c;\n        if (seen.has(x)) {\n            // for object with cycles\n            return;\n        }\n        if (isObject(x)) {\n            seen.add(x);\n        }\n        const used = isObject(x) && affected.get(getOriginalObject(x));\n        if (used) {\n            (_a = used[HAS_KEY_PROPERTY]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {\n                const segment = `:has(${String(key)})`;\n                list.push(path ? [...path, segment] : [segment]);\n            });\n            if (used[ALL_OWN_KEYS_PROPERTY] === true) {\n                const segment = ':ownKeys';\n                list.push(path ? [...path, segment] : [segment]);\n            }\n            else {\n                (_b = used[HAS_OWN_KEY_PROPERTY]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {\n                    const segment = `:hasOwn(${String(key)})`;\n                    list.push(path ? [...path, segment] : [segment]);\n                });\n            }\n            (_c = used[KEYS_PROPERTY]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {\n                if (!onlyWithValues ||\n                    'value' in (Object.getOwnPropertyDescriptor(x, key) || {})) {\n                    walk(x[key], path ? [...path, key] : [key]);\n                }\n            });\n        }\n        else if (path) {\n            list.push(path);\n        }\n    };\n    walk(obj);\n    return list;\n};\n/**\n * replace newProxy function.\n *\n * This can be used if you want to use proxy-polyfill.\n * Note that proxy-polyfill can't polyfill everything.\n * Use it at your own risk.\n */\nexport const replaceNewProxy = (fn) => {\n    newProxy = fn;\n};\n", "function getGlobal(): any {\n  if (typeof globalThis !== \"undefined\") return globalThis\n  if (typeof self !== \"undefined\") return self\n  if (typeof window !== \"undefined\") return window\n  if (typeof global !== \"undefined\") return global\n}\n\nexport function makeGlobal<T>(key: string, value: () => T): T {\n  const g = getGlobal()\n  if (!g) return value()\n  g[key] ||= value()\n  return g[key]\n}\n", "// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\nimport { makeGlobal } from \"./global\"\n\nconst isDev = process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\n\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\n\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n    ? T\n    : T extends Promise<any>\n      ? Awaited<T>\n      : {\n          readonly [K in keyof T]: Snapshot<T[K]>\n        }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => new WeakMap<ProxyObject, ProxyState>())\nconst refSet = makeGlobal(\"__zag__refSet\", () => new WeakSet())\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              Object.assign(value, { status: \"fulfilled\", value: v })\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              Object.assign(value, { status: \"rejected\", reason: e })\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): Ref<T> {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n\nexport type Ref<T> = T & AsRef\n", "import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n", "function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n", "export { proxy, ref, snapshot, subscribe, type Ref } from \"@zag-js/store\"\nexport { deepMerge } from \"./deep-merge\"\nexport { choose, guards } from \"./guard-utils\"\nexport * from \"./machine\"\nexport { mergeProps } from \"./merge-props\"\nexport type { ContextFrom, EventFrom, StateFrom } from \"./type-utils\"\nexport type { StateMachine } from \"./types\"\n", "export function toArray<T>(v: T | T[] | undefined | null): T[] {\n  if (!v) return []\n  return Array.isArray(v) ? v : [v]\n}\n\nexport const fromLength = (length: number) => Array.from(Array(length).keys())\n\nexport const first = <T>(v: T[]): T | undefined => v[0]\n\nexport const last = <T>(v: T[]): T | undefined => v[v.length - 1]\n\nexport const isEmpty = <T>(v: T[]): boolean => v.length === 0\n\nexport const has = <T>(v: T[], t: any): boolean => v.indexOf(t) !== -1\n\nexport const add = <T>(v: T[], ...items: T[]): T[] => v.concat(items)\n\nexport const remove = <T>(v: T[], item: T): T[] => v.filter((t) => t !== item)\n\nexport const removeAt = <T>(v: T[], i: number): T[] => v.filter((_, idx) => idx !== i)\n\nexport const addOrRemove = <T>(v: T[], item: T): T[] => {\n  if (has(v, item)) return remove(v, item)\n  return add(v, item)\n}\n\nexport function clear<T>(v: T[]): T[] {\n  while (v.length > 0) v.pop()\n  return v\n}\n\nexport type IndexOptions = {\n  step?: number\n  loop?: boolean\n}\n\nexport function nextIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  const next = idx + step\n  const len = v.length\n  const last = len - 1\n  if (idx === -1) return step > 0 ? 0 : last\n  if (next < 0) return loop ? last : 0\n  if (next >= len) return loop ? 0 : idx > len ? len : idx\n  return next\n}\n\nexport function next<T>(v: T[], idx: number, opts: IndexOptions = {}): T | undefined {\n  return v[nextIndex(v, idx, opts)]\n}\n\nexport function prevIndex<T>(v: T[], idx: number, opts: IndexOptions = {}): number {\n  const { step = 1, loop = true } = opts\n  return nextIndex(v, idx, { step: -step, loop })\n}\n\nexport function prev<T>(v: T[], index: number, opts: IndexOptions = {}): T | undefined {\n  return v[prevIndex(v, index, opts)]\n}\n\nexport const chunk = <T>(v: T[], size: number): T[][] => {\n  const res: T[][] = []\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value])\n    else last(rows)?.push(value)\n    return rows\n  }, res)\n}\n", "export type MaybeFunction<T> = T | (() => T)\n\nexport type Nullable<T> = T | null | undefined\n\nexport const runIfFn = <T>(\n  v: T | undefined,\n  ...a: T extends (...a: any[]) => void ? Parameters<T> : never\n): T extends (...a: any[]) => void ? NonNullable<ReturnType<T>> : NonNullable<T> => {\n  const res = typeof v === \"function\" ? v(...a) : v\n  return res ?? undefined\n}\n\nexport const cast = <T>(v: unknown): T => v as T\n\nexport const noop = () => {}\n\nexport const callAll =\n  <T extends (...a: any[]) => void>(...fns: (T | undefined)[]) =>\n  (...a: Parameters<T>) => {\n    fns.forEach(function (fn) {\n      fn?.(...a)\n    })\n  }\n\nexport const uuid = /*#__PURE__*/ (() => {\n  let id = 0\n  return () => {\n    id++\n    return id.toString(36)\n  }\n})()\n\nexport function match<V extends string | number = string, R = unknown>(\n  key: V,\n  record: Record<V, R | ((...args: any[]) => R)>,\n  ...args: any[]\n): R {\n  if (key in record) {\n    const fn = record[key]\n    return typeof fn === \"function\" ? fn(...args) : fn\n  }\n\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`)\n  Error.captureStackTrace?.(error, match)\n\n  throw error\n}\n\nexport const tryCatch = <R>(fn: () => R, fallback: () => R) => {\n  try {\n    return fn()\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch)\n    }\n    return fallback?.()\n  }\n}\n", "export const isDev = () => process.env.NODE_ENV !== \"production\"\nexport const isArray = (v: any): v is any[] => Array.isArray(v)\nexport const isBoolean = (v: any): v is boolean => v === true || v === false\nexport const isObject = (v: any): v is Record<string, any> => !(v == null || typeof v !== \"object\" || isArray(v))\nexport const isNumber = (v: any): v is number => typeof v === \"number\" && !Number.isNaN(v)\nexport const isString = (v: any): v is string => typeof v === \"string\"\nexport const isFunction = (v: any): v is Function => typeof v === \"function\"\nexport const isNull = (v: any): v is null | undefined => v == null\n\nexport const hasProp = <T extends string>(obj: any, prop: T): obj is Record<T, any> =>\n  Object.prototype.hasOwnProperty.call(obj, prop)\n", "export function compact<T extends Record<string, unknown> | undefined>(obj: T): T {\n  if (!isPlainObject(obj) || obj === undefined) {\n    return obj\n  }\n\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\")\n  const filtered: Partial<T> = {}\n  for (const key of keys) {\n    const value = (obj as any)[key]\n    if (value !== undefined) {\n      filtered[key as keyof T] = compact(value)\n    }\n  }\n  return filtered as T\n}\n\nexport function json(value: any) {\n  return JSON.parse(JSON.stringify(value))\n}\n\nconst isPlainObject = (value: any) => {\n  return value && typeof value === \"object\" && value.constructor === Object\n}\n\nexport function pick<T extends Record<string, any>, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const filtered: Partial<T> = {}\n\n  for (const key of keys) {\n    const value = obj[key]\n    if (value !== undefined) {\n      filtered[key] = value\n    }\n  }\n\n  return filtered as any\n}\n", "export function warn(m: string): void\nexport function warn(c: boolean, m: string): void\nexport function warn(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m)\n  }\n}\n\nexport function invariant(m: string): void\nexport function invariant(c: boolean, m: string): void\nexport function invariant(...a: any[]): void {\n  const m = a.length === 1 ? a[0] : a[1]\n  const c = a.length === 2 ? a[0] : true\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m)\n  }\n}\n", "import { compact, isObject } from \"@zag-js/utils\"\n\nexport function deepMerge<T extends Record<string, any>>(source: T, ...objects: T[]): T {\n  for (const obj of objects) {\n    const target = compact(obj)\n    for (const key in target) {\n      if (isObject(obj[key])) {\n        if (!source[key]) {\n          source[key] = {} as any\n        }\n        deepMerge(source[key], obj[key])\n      } else {\n        source[key] = obj[key]\n      }\n    }\n  }\n  return source\n}\n", "import { isArray, isObject, isString } from \"@zag-js/utils\"\nimport { klona } from \"klona/full\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\nexport function structuredClone<T>(v: T): T {\n  return klona(v)\n}\n\nexport function toEvent<T extends S.EventObject>(event: S.Event<T>): T {\n  const obj = isString(event) ? { type: event } : event\n  return obj as T\n}\n\nexport function toArray<T>(value: T | T[] | undefined): T[] {\n  if (!value) return []\n  return isArray(value) ? value.slice() : [value]\n}\n\nexport function isGuardHelper(value: any): value is { predicate: (guards: Dict) => any } {\n  return isObject(value) && value.predicate != null\n}\n", "import { isFunction, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { isGuardHelper } from \"./utils\"\n\nconst Truthy = () => true\n\n/* -----------------------------------------------------------------------------\n * The following functions are used to determine a guard's truthiness\n * -----------------------------------------------------------------------------*/\n\nfunction exec<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guardMap: Dict,\n  ctx: TContext,\n  event: TEvent,\n  meta: S.GuardMeta<TContext, TState, TEvent>,\n) {\n  return (guard: S.Guard<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      return !!guardMap[guard]?.(ctx, event, meta)\n    }\n    if (isFunction(guard)) {\n      return guard(ctx, event, meta)\n    }\n    return guard.predicate(guardMap)(ctx, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Guard helpers (for combining guards)\n * -----------------------------------------------------------------------------*/\n\nfunction or<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean),\n  }\n}\n\nfunction and<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...conditions: Array<S.Guard<TContext, TState, TEvent>>\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean),\n  }\n}\n\nfunction not<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  condition: S.Guard<TContext, TState, TEvent>,\n): S.GuardHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n      return !exec(guardMap, ctx, event, meta)(condition)\n    },\n  }\n}\n\nfunction stateIn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  ...values: TState[\"value\"][]\n): S.GuardExpression<TContext, TState, TEvent> {\n  return (_ctx, _evt, meta) => meta.state.matches(...values)\n}\n\nexport const guards = { or, and, not, stateIn }\n\n/* -----------------------------------------------------------------------------\n * Action guard helper. Used to determie the action to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function choose<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  actions: Array<{ guard?: S.Guard<TContext, TState, TEvent>; actions: S.PureActions<TContext, TState, TEvent> }>,\n): S.ChooseHelper<TContext, TState, TEvent> {\n  return {\n    predicate: (guardMap: Dict) => (ctx: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) =>\n      actions.find((def) => {\n        const guard = def.guard ?? Truthy\n        return exec(guardMap, ctx, event, meta)(guard)\n      })?.actions,\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the guard to be used\n * -----------------------------------------------------------------------------*/\n\nexport function determineGuardFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  guard: S.Guard<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  guard = guard ?? Truthy\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isString(guard)) {\n      const value = guardMap[guard]\n      return isFunction(value) ? value(context, event, meta) : value\n    }\n\n    if (isGuardHelper(guard)) {\n      return guard.predicate(guardMap)(context, event, meta)\n    }\n\n    return guard?.(context, event, meta)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Function to determine the actions to be taken\n * -----------------------------------------------------------------------------*/\n\nexport function determineActionsFn<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  values: S.Actions<TContext, TState, TEvent> | undefined,\n  guardMap: S.GuardMap<TContext, TState, TEvent>,\n) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    if (isGuardHelper(values)) {\n      return values.predicate(guardMap)(context, event, meta)\n    }\n    return values\n  }\n}\n", "import { ref, snapshot, subscribe } from \"@zag-js/store\"\nimport {\n  cast,\n  clear,\n  compact,\n  hasProp,\n  invariant,\n  isArray,\n  isDev,\n  isObject,\n  isString,\n  noop,\n  runIfFn,\n  uuid,\n  warn,\n} from \"@zag-js/utils\"\nimport { createProxy } from \"./create-proxy\"\nimport { deepMerge } from \"./deep-merge\"\nimport { determineDelayFn } from \"./delay-utils\"\nimport { determineActionsFn, determineGuardFn } from \"./guard-utils\"\nimport { determineTransitionFn } from \"./transition-utils\"\nimport {\n  ActionTypes,\n  MachineStatus,\n  MachineType,\n  type Dict,\n  type StateMachine as S,\n  type VoidFunction,\n  type Writable,\n} from \"./types\"\nimport { structuredClone, toArray, toEvent } from \"./utils\"\n\nexport class Machine<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> {\n  public status: MachineStatus = MachineStatus.NotStarted\n  public readonly state: S.State<TContext, TState, TEvent>\n\n  public initialState: S.StateInfo<TContext, TState, TEvent> | undefined\n  public initialContext: TContext\n\n  public id: string\n\n  public type: MachineType = MachineType.Machine\n\n  // Cleanup function map (per state)\n  private activityEvents = new Map<string, Map<string, VoidFunction>>()\n  private delayedEvents = new Map<string, VoidFunction[]>()\n\n  // state update listeners the user can opt-in for\n  private stateListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private doneListeners = new Set<S.StateListener<TContext, TState, TEvent>>()\n  private contextWatchers = new Set<VoidFunction>()\n\n  // Cleanup functions (for `subscribe`)\n  private removeStateListener: VoidFunction = noop\n\n  // For Parent <==> Spawned Actor relationship\n  private parent?: AnyMachine\n  private children = new Map<string, AnyMachine>()\n\n  // A map of guard, action, delay implementations\n  private guardMap: S.GuardMap<TContext, TState, TEvent>\n  private actionMap: S.ActionMap<TContext, TState, TEvent>\n  private delayMap: S.DelayMap<TContext, TEvent>\n  private activityMap: S.ActivityMap<TContext, TState, TEvent>\n  private sync: boolean\n  public options: S.MachineOptions<TContext, TState, TEvent>\n  public config: S.MachineConfig<TContext, TState, TEvent>\n\n  // Let's get started!\n  constructor(config: S.MachineConfig<TContext, TState, TEvent>, options?: S.MachineOptions<TContext, TState, TEvent>) {\n    // clone the config and options\n    this.config = structuredClone(config)\n    this.options = structuredClone(options ?? {})\n\n    this.id = this.config.id ?? `machine-${uuid()}`\n\n    // maps\n    this.guardMap = this.options?.guards ?? {}\n    this.actionMap = this.options?.actions ?? {}\n    this.delayMap = this.options?.delays ?? {}\n    this.activityMap = this.options?.activities ?? {}\n    this.sync = this.options?.sync ?? false\n\n    // create mutatable state\n    this.state = createProxy(this.config)\n\n    this.initialContext = snapshot(this.state.context)\n  }\n\n  // immutable state value\n  private get stateSnapshot(): S.State<TContext, TState, TEvent> {\n    return cast(snapshot(this.state))\n  }\n\n  public getState(): S.State<TContext, TState, TEvent> {\n    return this.stateSnapshot\n  }\n\n  // immutable context value\n  public get contextSnapshot(): TContext {\n    return this.stateSnapshot.context\n  }\n\n  public _created = () => {\n    // created actions\n    const event = toEvent<TEvent>(ActionTypes.Created)\n    this.executeActions(this.config?.created, event)\n  }\n\n  // Starts the interpreted machine.\n  public start = (init?: S.StateInit<TContext, TState>) => {\n    // reset state back to empty (for SSR, we had to set state.value to initial value)\n    this.state.value = \"\"\n    this.state.tags = []\n\n    // Don't start if it's already running\n    if (this.status === MachineStatus.Running) {\n      return this\n    }\n\n    this.status = MachineStatus.Running\n\n    // subscribe to state changes\n    this.removeStateListener = subscribe(\n      this.state,\n      () => {\n        this.stateListeners.forEach((listener) => {\n          listener(this.stateSnapshot)\n        })\n      },\n      this.sync,\n    )\n\n    this.setupContextWatchers()\n\n    // execute initial actions and activities\n    this.executeActivities(toEvent<TEvent>(ActionTypes.Start), toArray(this.config.activities), ActionTypes.Start)\n    this.executeActions(this.config.entry, toEvent<TEvent>(ActionTypes.Start))\n\n    // start transition\n    const event = toEvent<TEvent>(ActionTypes.Init)\n\n    const target = isObject(init) ? init.value : init\n    const context = isObject(init) ? init.context : undefined\n\n    if (context) {\n      this.setContext(context as Partial<TContext>)\n    }\n\n    // start transition definition\n    const transition = {\n      target: target ?? this.config.initial,\n    }\n\n    const next = this.getNextStateInfo(transition, event)\n    this.initialState = next\n\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return this\n  }\n\n  private setupContextWatchers = () => {\n    const { watch } = this.config\n    if (!watch) return\n\n    let prev = snapshot(this.state.context)\n\n    const cleanup = subscribe(this.state.context, () => {\n      const next = snapshot(this.state.context)\n\n      for (const [key, fn] of Object.entries(watch)) {\n        const isEqual = this.options.compareFns?.[key] ?? Object.is\n        if (isEqual(prev[key], next[key])) continue\n        this.executeActions(fn, this.state.event as TEvent)\n      }\n\n      prev = next\n    })\n\n    this.contextWatchers.add(cleanup)\n  }\n\n  // Stops the interpreted machine\n  stop = () => {\n    // No need to call if already stopped\n    if (this.status === MachineStatus.Stopped) return\n\n    // exit current state\n    this.performExitEffects(this.state.value!, toEvent<TEvent>(ActionTypes.Stop))\n\n    // execute root stop or exit actions\n    this.executeActions(this.config.exit, toEvent<TEvent>(ActionTypes.Stop))\n\n    this.setState(\"\")\n    this.setEvent(ActionTypes.Stop)\n\n    // cleanups\n    this.stopStateListeners()\n    this.stopChildren()\n    this.stopActivities()\n    this.stopDelayedEvents()\n    this.stopContextWatchers()\n\n    this.status = MachineStatus.Stopped\n    return this\n  }\n\n  private stopStateListeners = () => {\n    this.removeStateListener()\n    this.stateListeners.clear()\n  }\n\n  private stopContextWatchers = () => {\n    this.contextWatchers.forEach((fn) => fn())\n    this.contextWatchers.clear()\n  }\n\n  private stopDelayedEvents = () => {\n    this.delayedEvents.forEach((state) => {\n      state.forEach((stop) => stop())\n    })\n    this.delayedEvents.clear()\n  }\n\n  // Cleanup running activities (e.g `setInterval`, invoked callbacks, promises)\n  private stopActivities = (state?: TState[\"value\"]) => {\n    // stop activities for a state\n    if (state) {\n      this.activityEvents.get(state)?.forEach((stop) => stop())\n      this.activityEvents.get(state)?.clear()\n      this.activityEvents.delete(state)\n    } else {\n      // stop every running activity\n      this.activityEvents.forEach((state) => {\n        state.forEach((stop) => stop())\n        state.clear()\n      })\n      this.activityEvents.clear()\n    }\n  }\n\n  /**\n   * Function to send event to spawned child machine or actor\n   */\n  public sendChild = (evt: S.Event<S.AnyEventObject>, to: string | ((ctx: TContext) => string)) => {\n    const event = toEvent(evt)\n    const id = runIfFn(to, this.contextSnapshot)\n    const child = this.children.get(id)\n    if (!child) {\n      invariant(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`)\n    }\n    child!.send(event)\n  }\n\n  /**\n   * Function to stop a running child machine or actor\n   */\n  public stopChild = (id: string) => {\n    if (!this.children.has(id)) {\n      invariant(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`)\n    }\n    this.children.get(id)!.stop()\n    this.children.delete(id)\n  }\n\n  public removeChild = (id: string) => {\n    this.children.delete(id)\n  }\n\n  // Stop and delete spawned actors\n  private stopChildren = () => {\n    this.children.forEach((child) => child.stop())\n    this.children.clear()\n  }\n\n  private setParent = (parent: any) => {\n    this.parent = parent\n  }\n\n  public spawn = <TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject = S.AnyEventObject>(\n    src: MachineSrc<TContext, TState, TEvent>,\n    id?: string,\n  ) => {\n    const actor = runIfFn(src)\n    if (id) actor.id = id\n    actor.type = MachineType.Actor\n    actor.setParent(this)\n    this.children.set(actor.id, cast(actor))\n\n    actor\n      .onDone(() => {\n        this.removeChild(actor.id)\n      })\n      .start()\n\n    return cast<typeof actor>(ref(actor))\n  }\n\n  private stopActivity = (key: string) => {\n    if (!this.state.value) return\n    const cleanups = this.activityEvents.get(this.state.value)\n    cleanups?.get(key)?.() // cleanup\n    cleanups?.delete(key) // remove from map\n  }\n\n  private addActivityCleanup = (state: TState[\"value\"] | null, key: string, cleanup: VoidFunction) => {\n    if (!state) return\n    if (!this.activityEvents.has(state)) {\n      this.activityEvents.set(state, new Map([[key, cleanup]]))\n    } else {\n      this.activityEvents.get(state)?.set(key, cleanup)\n    }\n  }\n\n  private setState = (target: TState[\"value\"] | null) => {\n    this.state.previousValue = this.state.value\n    this.state.value = target\n\n    const stateNode = this.getStateNode(target)\n\n    if (target == null) {\n      // remove all tags\n      clear(this.state.tags)\n    } else {\n      this.state.tags = toArray(stateNode?.tags)\n    }\n  }\n\n  /**\n   * To used within side effects for React or Vue to update context\n   */\n  public setContext = (context: Partial<Writable<TContext>> | undefined) => {\n    if (!context) return\n    deepMerge(this.state.context, compact(context))\n  }\n\n  public setOptions = (options: Partial<S.MachineOptions<TContext, TState, TEvent>>) => {\n    const opts = compact(options)\n    this.actionMap = { ...this.actionMap, ...opts.actions }\n    this.delayMap = { ...this.delayMap, ...opts.delays }\n    this.activityMap = { ...this.activityMap, ...opts.activities }\n    this.guardMap = { ...this.guardMap, ...opts.guards }\n  }\n\n  private getStateNode = (state: TState[\"value\"] | null) => {\n    if (!state) return\n    return this.config.states?.[state]\n  }\n\n  private getNextStateInfo = (\n    transitions: S.Transitions<TContext, TState, TEvent>,\n    event: TEvent,\n  ): S.StateInfo<TContext, TState, TEvent> => {\n    // pick transition\n    const transition = this.determineTransition(transitions, event)\n\n    const isTargetless = !transition?.target\n    const target = transition?.target ?? this.state.value\n    const changed = this.state.value !== target\n\n    const stateNode = this.getStateNode(target)\n    const reenter = !isTargetless && !changed && !transition?.internal\n\n    const info = {\n      reenter,\n      transition,\n      stateNode,\n      target: target!,\n      changed,\n    }\n\n    this.log(\"NextState:\", `[${event.type}]`, this.state.value, \"---->\", info.target)\n\n    return info\n  }\n\n  private getAfterActions = (transition: S.Transitions<TContext, TState, TEvent>, delay?: number) => {\n    let id: ReturnType<typeof globalThis.setTimeout>\n\n    return {\n      entry: () => {\n        id = globalThis.setTimeout(() => {\n          const next = this.getNextStateInfo(transition, this.state.event)\n          this.performStateChangeEffects(this.state.value!, next, this.state.event)\n        }, delay)\n      },\n      exit: () => {\n        globalThis.clearTimeout(id)\n      },\n    }\n  }\n\n  /**\n   * All `after` events leverage `setTimeout` and `clearTimeout`,\n   * we invoke the `clearTimeout` on exit and `setTimeout` on entry.\n   *\n   * To achieve this, we split the `after` defintion into `entry` and `exit`\n   *  functions and append them to the state's `entry` and `exit` actions\n   */\n  private getDelayedEventActions = (state: TState[\"value\"]) => {\n    const stateNode = this.getStateNode(state)\n    const event = this.state.event\n\n    if (!stateNode || !stateNode.after) return\n\n    const entries: VoidFunction[] = []\n    const exits: VoidFunction[] = []\n\n    if (isArray(stateNode.after)) {\n      //\n      const transition = this.determineTransition(stateNode.after, event)\n\n      if (!transition) return\n\n      if (!hasProp(transition, \"delay\")) {\n        throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`)\n      }\n\n      const determineDelay = determineDelayFn((transition as any).delay, this.delayMap)\n      const __delay = determineDelay(this.contextSnapshot, event)\n\n      const actions = this.getAfterActions(transition, __delay)\n\n      entries.push(actions.entry)\n      exits.push(actions.exit)\n\n      return { entries, exits }\n    }\n\n    if (isObject(stateNode.after)) {\n      //\n      for (const delay in stateNode.after) {\n        const transition = stateNode.after[delay]\n\n        const determineDelay = determineDelayFn(delay, this.delayMap)\n        const __delay = determineDelay(this.contextSnapshot, event)\n\n        const actions = this.getAfterActions(transition, __delay)\n\n        entries.push(actions.entry)\n        exits.push(actions.exit)\n      }\n    }\n\n    return { entries, exits }\n  }\n\n  /**\n   * A reference to the instance methods of the machine.\n   * Useful when spawning child machines and managing the communication between them.\n   */\n  private get self(): S.Self<TContext, TState, TEvent> {\n    const self = this\n    return {\n      id: this.id,\n      send: this.send.bind(this),\n      sendParent: this.sendParent.bind(this),\n      sendChild: this.sendChild.bind(this),\n      stop: this.stop.bind(this),\n      stopChild: this.stopChild.bind(this),\n      spawn: this.spawn.bind(this) as any,\n      stopActivity: this.stopActivity.bind(this),\n      get state() {\n        return self.stateSnapshot\n      },\n      get initialContext() {\n        return self.initialContext\n      },\n      get initialState() {\n        return self.initialState?.target ?? \"\"\n      },\n    }\n  }\n\n  private get meta(): S.Meta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n      guards: this.guardMap,\n      send: this.send.bind(this),\n      self: this.self,\n      initialContext: this.initialContext,\n      initialState: this.initialState?.target ?? \"\",\n      getState: () => this.stateSnapshot,\n      getAction: (key) => this.actionMap[key],\n      getGuard: (key) => this.guardMap[key],\n    }\n  }\n\n  private get guardMeta(): S.GuardMeta<TContext, TState, TEvent> {\n    return {\n      state: this.stateSnapshot,\n    }\n  }\n\n  /**\n   * Function to executes defined actions. It can accept actions as string\n   * (referencing `options.actions`) or actual functions.\n   */\n  private executeActions = (actions: S.Actions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    for (const action of toArray(pickedActions)) {\n      const fn = isString(action) ? this.actionMap?.[action] : action\n      warn(\n        isString(action) && !fn,\n        `[@zag-js/core > execute-actions] No implementation found for action: \\`${action}\\``,\n      )\n      fn?.(this.state.context, event, this.meta)\n    }\n  }\n\n  /**\n   * Function to execute running activities and registers\n   * their cleanup function internally (to be called later on when we exit the state)\n   */\n  private executeActivities = (\n    event: TEvent,\n    activities: Array<S.Activity<TContext, TState, TEvent>>,\n    state?: TState[\"value\"],\n  ) => {\n    for (const activity of activities) {\n      const fn = isString(activity) ? this.activityMap?.[activity] : activity\n\n      if (!fn) {\n        warn(`[@zag-js/core > execute-activity] No implementation found for activity: \\`${activity}\\``)\n        continue\n      }\n\n      const cleanup = fn(this.state.context, event, this.meta)\n\n      if (cleanup) {\n        const key = isString(activity) ? activity : activity.name || uuid()\n        this.addActivityCleanup(state ?? this.state.value, key, cleanup)\n      }\n    }\n  }\n\n  /**\n   * Normalizes the `every` definition to transition. `every` can be:\n   * - An array of possible actions to run (we need to pick the first match based on guard)\n   * - An object of intervals and actions\n   */\n  private createEveryActivities = (\n    every: S.StateNode<TContext, TState, TEvent>[\"every\"] | undefined,\n    callbackfn: (activity: S.Activity<TContext, TState, TEvent>) => void,\n  ) => {\n    if (!every) return\n\n    // every: [{ interval: 2000, actions: [...], guard: \"isValid\" },  { interval: 1000, actions: [...] }]\n    if (isArray(every)) {\n      // picked = { interval: string | number | <ref>, actions: [...], guard: ... }\n      const picked = toArray(every).find((transition) => {\n        //\n        const delayOrFn = transition.delay\n        const determineDelay = determineDelayFn(delayOrFn, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        const determineGuard = determineGuardFn(transition.guard, this.guardMap)\n        const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta)\n\n        return guard ?? delay != null\n      })\n\n      if (!picked) return\n\n      const determineDelay = determineDelayFn(picked.delay, this.delayMap)\n      const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n      const activity = () => {\n        const id = globalThis.setInterval(() => {\n          this.executeActions(picked.actions, this.state.event)\n        }, delay)\n        return () => {\n          globalThis.clearInterval(id)\n        }\n      }\n      callbackfn(activity)\n      //\n    } else {\n      // every = { 1000: [fn, fn] }\n      for (const interval in every) {\n        const actions = every?.[interval]\n\n        // interval could be a `ref` not the actual interval value, let's determine the actual value\n        const determineDelay = determineDelayFn(interval, this.delayMap)\n        const delay = determineDelay(this.contextSnapshot, this.state.event)\n\n        // create the activity to run for each `every` reaction\n        const activity = () => {\n          const id = globalThis.setInterval(() => {\n            this.executeActions(actions, this.state.event)\n          }, delay)\n          return () => {\n            globalThis.clearInterval(id)\n          }\n        }\n        callbackfn(activity)\n      }\n    }\n  }\n\n  private setEvent = (event: TEvent | TEvent[\"type\"]) => {\n    this.state.previousEvent = this.state.event\n    this.state.event = ref(toEvent(event))\n  }\n\n  private performExitEffects = (current: TState[\"value\"] | undefined, event: TEvent) => {\n    const currentState = this.state.value!\n\n    // don't clean up root state, it'll get cleaned up on stop()\n    if (currentState === \"\") return\n\n    const stateNode = current ? this.getStateNode(current) : undefined\n\n    // cleanup activities for current state\n    this.stopActivities(currentState)\n\n    // get explicit exit and implicit \"after.exit\" actions for current state\n    const _exit = determineActionsFn(stateNode?.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta)\n    const exitActions = toArray(_exit)\n\n    const afterExitActions = this.delayedEvents.get(currentState)\n\n    if (afterExitActions) {\n      exitActions.push(...afterExitActions)\n    }\n\n    // call all exit actions for current state\n    this.executeActions(exitActions, event)\n  }\n\n  private performEntryEffects = (next: TState[\"value\"], event: TEvent) => {\n    const stateNode = this.getStateNode(next)\n\n    // execute activities for next state\n    const activities = toArray(stateNode?.activities)\n\n    // if `every` is defined, create an activity and append to activities\n    this.createEveryActivities(stateNode?.every, (activity) => {\n      activities.unshift(activity)\n    })\n\n    if (activities.length > 0) {\n      this.executeActivities(event, activities)\n    }\n\n    // get all entry actions\n    const pickedActions = determineActionsFn(stateNode?.entry, this.guardMap)(\n      this.contextSnapshot,\n      event,\n      this.guardMeta,\n    )\n    const entryActions = toArray(pickedActions)\n    const afterActions = this.getDelayedEventActions(next)\n\n    if (stateNode?.after && afterActions) {\n      this.delayedEvents.set(next, afterActions?.exits)\n      entryActions.push(...afterActions.entries)\n    }\n\n    // execute entry actions for next state\n    this.executeActions(entryActions, event)\n\n    if (stateNode?.type === \"final\") {\n      this.state.done = true\n      this.doneListeners.forEach((listener) => {\n        listener(this.stateSnapshot)\n      })\n      this.stop()\n    }\n  }\n\n  private performTransitionEffects = (\n    transitions: S.Transitions<TContext, TState, TEvent> | undefined,\n    event: TEvent,\n  ) => {\n    // execute transition actions\n    const transition = this.determineTransition(transitions, event)\n    this.executeActions(transition?.actions, event)\n  }\n\n  /**\n   * Performs all the requires side-effects or reactions when\n   * we move from state A => state B.\n   *\n   * The Effect order:\n   * Exit actions (current state) => Transition actions  => Go to state => Entry actions (next state)\n   */\n  private performStateChangeEffects = (\n    current: TState[\"value\"] | undefined,\n    next: S.StateInfo<TContext, TState, TEvent>,\n    event: TEvent,\n  ) => {\n    // update event\n    this.setEvent(event)\n\n    const changed = next.changed || next.reenter\n\n    if (changed) {\n      this.performExitEffects(current, event)\n    }\n\n    // execute transition actions\n    this.performTransitionEffects(next.transition, event)\n\n    // go to next state\n    this.setState(next.target)\n\n    if (changed) {\n      this.performEntryEffects(next.target, event)\n    }\n  }\n\n  private determineTransition = (transition: S.Transitions<TContext, TState, TEvent> | undefined, event: TEvent) => {\n    const fn = determineTransitionFn(transition, this.guardMap)\n    return fn?.(this.contextSnapshot, event, this.guardMeta)\n  }\n\n  /**\n   * Function to send event to parent machine from spawned child\n   */\n  public sendParent = (evt: S.Event<S.AnyEventObject>) => {\n    if (!this.parent) {\n      invariant(\"[@zag-js/core > send-parent] Cannot send event to an unknown parent\")\n    }\n    const event = toEvent<S.AnyEventObject>(evt)\n    this.parent?.send(event)\n  }\n\n  private log = (...args: any[]) => {\n    if (isDev() && this.options.debug) {\n      console.log(...args)\n    }\n  }\n\n  /**\n   * Function to send an event to current machine\n   */\n  public send = (evt: S.Event<TEvent>) => {\n    const event = toEvent<TEvent>(evt)\n    this.transition(this.state.value, event)\n  }\n\n  public transition = (state: TState[\"value\"] | S.StateInfo<TContext, TState, TEvent> | null, evt: S.Event<TEvent>) => {\n    const stateNode = isString(state) ? this.getStateNode(state) : state?.stateNode\n\n    const event = toEvent(evt)\n\n    if (!stateNode && !this.config.on) {\n      const msg =\n        this.status === MachineStatus.Stopped\n          ? \"[@zag-js/core > transition] Cannot transition a stopped machine\"\n          : `[@zag-js/core > transition] State does not have a definition for \\`state\\`: ${state}, \\`event\\`: ${event.type}`\n      warn(msg)\n      return\n    }\n\n    const transitions: S.Transitions<TContext, TState, TEvent> =\n      stateNode?.on?.[event.type] ?? this.config.on?.[event.type]\n\n    const next = this.getNextStateInfo(transitions, event)\n    this.performStateChangeEffects(this.state.value!, next, event)\n\n    return next.stateNode\n  }\n\n  subscribe = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n\n    return () => {\n      this.stateListeners.delete(listener)\n    }\n  }\n\n  public onDone = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.doneListeners.add(listener)\n    return this\n  }\n\n  public onTransition = (listener: S.StateListener<TContext, TState, TEvent>) => {\n    this.stateListeners.add(listener)\n    if (this.status === MachineStatus.Running) {\n      listener(this.stateSnapshot)\n    }\n    return this\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"Machine\"\n  }\n}\n\nexport type MachineSrc<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n> = Machine<TContext, TState, TEvent> | (() => Machine<TContext, TState, TEvent>)\n\nexport type AnyMachine = Machine<Dict, S.StateSchema, S.AnyEventObject>\n\nexport const createMachine = <\n  TContext extends Dict,\n  TState extends S.StateSchema = S.StateSchema,\n  TEvent extends S.EventObject = S.AnyEventObject,\n>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n  options?: S.MachineOptions<TContext, TState, TEvent>,\n) => new Machine(config, options)\n\nexport const isMachine = (value: any): value is AnyMachine => {\n  return value instanceof Machine || value?.type === MachineType.Machine\n}\n", "import { proxy, proxyWithComputed } from \"@zag-js/store\"\nimport { cast } from \"@zag-js/utils\"\nimport { ActionTypes, type Dict, type StateMachine as S } from \"./types\"\n\nexport function createProxy<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  config: S.MachineConfig<TContext, TState, TEvent>,\n) {\n  const computedContext: Dict = config.computed ?? cast<S.TComputedContext<TContext>>({})\n  const initialContext = config.context ?? cast<TContext>({})\n  const initialTags = config.initial ? config.states?.[config.initial]?.tags : []\n\n  const state = proxy({\n    value: config.initial ?? \"\",\n    previousValue: \"\",\n    event: cast<Dict>({}),\n    previousEvent: cast<Dict>({}),\n    context: proxyWithComputed(initialContext, computedContext),\n    done: false,\n    tags: (initialTags ?? []) as Array<TState[\"tags\"]>,\n    hasTag(tag: TState[\"tags\"]): boolean {\n      return this.tags.includes(tag)\n    },\n    matches(...value: string[]): boolean {\n      return value.includes(this.value)\n    },\n    can(event: string): boolean {\n      return cast<any>(this).nextEvents.includes(event)\n    },\n    get nextEvents() {\n      const stateEvents = (config.states as Dict)?.[this.value]?.[\"on\"] ?? {}\n      const globalEvents = config?.on ?? {}\n      return Object.keys({ ...stateEvents, ...globalEvents })\n    },\n    get changed() {\n      if (this.event.value === ActionTypes.Init || !this.previousValue) return false\n      return this.value !== this.previousValue\n    },\n  })\n\n  return cast<S.State<TContext, TState, TEvent>>(state)\n}\n", "import { invariant, isFunction, isNumber, isString } from \"@zag-js/utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\n\n/**\n * Delay can be specified as:\n * - a string (reference to `options.delays`)\n * - a number (in ms)\n * - a function that returns a number (in ms)\n *\n * Let's resolve this to a number\n */\nexport function determineDelayFn<TContext extends Dict, TEvent extends S.EventObject>(\n  delay: S.Delay<TContext, TEvent> | undefined,\n  delaysMap: S.DelayMap<TContext, TEvent> | undefined,\n) {\n  return (context: TContext, event: TEvent) => {\n    if (isNumber(delay)) return delay\n\n    if (isFunction(delay)) {\n      return delay(context, event)\n    }\n\n    if (isString(delay)) {\n      const value = Number.parseFloat(delay)\n\n      if (!Number.isNaN(value)) {\n        return value\n      }\n\n      if (delaysMap) {\n        const valueOrFn = delaysMap?.[delay]\n\n        invariant(\n          valueOrFn == null,\n          `[@zag-js/core > determine-delay] Cannot determine delay for \\`${delay}\\`. It doesn't exist in \\`options.delays\\``,\n        )\n\n        return isFunction(valueOrFn) ? valueOrFn(context, event) : valueOrFn\n      }\n    }\n  }\n}\n", "import { isString } from \"@zag-js/utils\"\nimport { determineGuardFn } from \"./guard-utils\"\nimport type { Dict, StateMachine as S } from \"./types\"\nimport { toArray } from \"./utils\"\n\n/**\n * A transition is an object that describes the next state, or/and actions\n * that should run when an event is sent.\n *\n * Transitions can be specified as:\n * - A single string: \"spinning\"\n * - An object with `target`, `actions`, or `guard`: { target: \"spinning\", actions: [...], guard: isValid }\n * - An array of possible transitions. In this case, we'll pick the first matching transition\n * depending on the `guard` specified\n */\n\nexport function toTarget<TContext extends Dict, TState extends S.StateSchema, TEvent extends S.EventObject>(\n  target: S.Transition<TContext, TState, TEvent>,\n): S.TransitionDefinition<TContext, TState, TEvent> {\n  return isString(target) ? { target } : target\n}\n\nexport function determineTransitionFn<\n  TContext extends Dict,\n  TState extends S.StateSchema,\n  TEvent extends S.EventObject,\n>(transitions: S.Transitions<TContext, TState, TEvent> | undefined, guardMap: S.GuardMap<TContext, TState, TEvent>) {\n  return (context: TContext, event: TEvent, meta: S.GuardMeta<TContext, TState, TEvent>) => {\n    return toArray(transitions)\n      .map(toTarget)\n      .find((transition) => {\n        // get condition function\n        const determineGuard = determineGuardFn(transition.guard, guardMap)\n        const guard = determineGuard(context, event, meta)\n        return guard ?? transition.target ?? transition.actions\n      })\n  }\n}\n", "import { callAll, isString } from \"@zag-js/utils\"\n\ninterface Props {\n  [key: string]: any\n}\n\nconst clsx = (...args: (string | undefined)[]) =>\n  args\n    .map((str) => str?.trim?.())\n    .filter(Boolean)\n    .join(\" \")\n\nconst CSS_REGEX = /((?:--)?(?:\\w+-?)+)\\s*:\\s*([^;]*)/g\n\nconst serialize = (style: string): Record<string, string> => {\n  const res: Record<string, string> = {}\n  let match: RegExpExecArray | null\n  while ((match = CSS_REGEX.exec(style))) {\n    res[match[1]!] = match[2]!\n  }\n  return res\n}\n\nconst css = (\n  a: Record<string, string> | string | undefined,\n  b: Record<string, string> | string | undefined,\n): Record<string, string> | string => {\n  if (isString(a)) {\n    if (isString(b)) return `${a};${b}`\n    a = serialize(a)\n  } else if (isString(b)) {\n    b = serialize(b)\n  }\n  return Object.assign({}, a ?? {}, b ?? {})\n}\n\ntype TupleTypes<T extends any[]> = T[number]\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never\n\nconst eventRegex = /^on[A-Z]/\n\nexport function mergeProps<T extends Props>(...args: T[]): UnionToIntersection<TupleTypes<T[]>> {\n  let result: Props = {}\n\n  for (let props of args) {\n    for (let key in result) {\n      if (eventRegex.test(key) && typeof result[key] === \"function\" && typeof props[key] === \"function\") {\n        result[key] = callAll(props[key], result[key])\n        continue\n      }\n\n      if (key === \"className\" || key === \"class\") {\n        result[key] = clsx(result[key], props[key])\n        continue\n      }\n\n      if (key === \"style\") {\n        result[key] = css(result[key], props[key])\n        continue\n      }\n\n      result[key] = props[key] !== undefined ? props[key] : result[key]\n    }\n\n    // Add props from b that are not in a\n    for (let key in props) {\n      if (result[key] === undefined) {\n        result[key] = props[key]\n      }\n    }\n  }\n\n  return result as any\n}\n", "import type { JSX } from \"./jsx\"\n\ntype Dict<T = any> = Record<string, T>\n\ntype DataAttr = {\n  \"data-selected\"?: any\n  \"data-expanded\"?: any\n  \"data-highlighted\"?: any\n  \"data-readonly\"?: any\n  \"data-indeterminate\"?: any\n  \"data-invalid\"?: any\n  \"data-hover\"?: any\n  \"data-active\"?: any\n  \"data-focus\"?: any\n  \"data-disabled\"?: any\n  \"data-open\"?: any\n  \"data-checked\"?: any\n  \"data-pressed\"?: any\n  \"data-complete\"?: any\n  \"data-side\"?: any\n  \"data-align\"?: any\n  \"data-empty\"?: any\n  \"data-placeholder-shown\"?: any\n  \"data-half\"?: any\n  \"data-scope\"?: string\n  \"data-uid\"?: string\n  \"data-name\"?: string\n  \"data-ownedby\"?: string\n  \"data-type\"?: string\n  \"data-valuetext\"?: string\n  \"data-placement\"?: string\n  \"data-controls\"?: string\n  \"data-part\"?: string\n  \"data-label\"?: string\n  \"data-state\"?: string | null\n  \"data-value\"?: string | number\n  \"data-orientation\"?: \"horizontal\" | \"vertical\"\n  \"data-count\"?: number\n  \"data-index\"?: number\n} & {\n  [key in `data-${string}`]?: any\n}\n\nexport type PropTypes<T = Dict> = Record<\n  | \"button\"\n  | \"label\"\n  | \"input\"\n  | \"textarea\"\n  | \"img\"\n  | \"output\"\n  | \"element\"\n  | \"select\"\n  | \"style\"\n  | \"circle\"\n  | \"svg\"\n  | \"path\",\n  T\n>\n\nexport type NormalizeProps<T extends PropTypes> = {\n  [K in keyof T]: (props: K extends keyof JSX.IntrinsicElements ? DataAttr & JSX.IntrinsicElements[K] : never) => T[K]\n} & {\n  element(props: DataAttr & JSX.HTMLAttributes<HTMLElement> & Record<string, any>): T[\"element\"]\n  style: JSX.CSSProperties\n}\n\nexport function createNormalizer<T extends PropTypes>(fn: (props: Dict) => Dict): NormalizeProps<T> {\n  return new Proxy({} as any, {\n    get() {\n      return fn\n    },\n  })\n}\n", "type StrictKeys<K extends (keyof T)[], T> = K extends (keyof T)[]\n  ? [keyof T] extends [K[number]]\n    ? unknown\n    : `Missing required keys: ${Exclude<keyof T, K[number]>}`\n  : never\n\nexport const createProps =\n  <T extends Record<never, never>>() =>\n  <K extends (keyof T)[]>(props: K & StrictKeys<K, T>) =>\n    Array.from(new Set(props))\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"accordion\").parts(\"root\", \"item\", \"itemTrigger\", \"itemContent\", \"itemIndicator\")\nexport const parts = anatomy.build()\n", "import { getEventKey, type EventKeyMap } from \"@zag-js/dom-event\"\nimport { dataAttr, isSafari } from \"@zag-js/dom-query\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./accordion.anatomy\"\nimport { dom } from \"./accordion.dom\"\nimport type { ItemProps, ItemState, MachineApi, Send, State } from \"./accordion.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const focusedValue = state.context.focusedValue\n  const value = state.context.value\n  const multiple = state.context.multiple\n\n  function setValue(value: string[]) {\n    let nextValue = value\n    if (multiple && nextValue.length > 1) {\n      nextValue = [nextValue[0]]\n    }\n    send({ type: \"VALUE.SET\", value: nextValue })\n  }\n\n  function getItemState(props: ItemProps): ItemState {\n    return {\n      expanded: value.includes(props.value),\n      focused: focusedValue === props.value,\n      disabled: Boolean(props.disabled ?? state.context.disabled),\n    }\n  }\n\n  return {\n    focusedValue,\n    value,\n    setValue,\n    getItemState,\n\n    rootProps: normalize.element({\n      ...parts.root.attrs,\n      dir: state.context.dir,\n      id: dom.getRootId(state.context),\n      \"data-orientation\": state.context.orientation,\n    }),\n\n    getItemProps(props: ItemProps) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.item.attrs,\n        dir: state.context.dir,\n        id: dom.getItemId(state.context, props.value),\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemContentProps(props: ItemProps) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.itemContent.attrs,\n        dir: state.context.dir,\n        role: \"region\",\n        id: dom.getItemContentId(state.context, props.value),\n        \"aria-labelledby\": dom.getItemTriggerId(state.context, props.value),\n        hidden: !itemState.expanded,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemIndicatorProps(props) {\n      const itemState = getItemState(props)\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"aria-hidden\": true,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-focus\": dataAttr(itemState.focused),\n        \"data-orientation\": state.context.orientation,\n      })\n    },\n\n    getItemTriggerProps(props: ItemProps) {\n      const { value } = props\n      const itemState = getItemState(props)\n\n      return normalize.button({\n        ...parts.itemTrigger.attrs,\n        type: \"button\",\n        dir: state.context.dir,\n        id: dom.getItemTriggerId(state.context, value),\n        \"aria-controls\": dom.getItemContentId(state.context, value),\n        \"aria-expanded\": itemState.expanded,\n        disabled: itemState.disabled,\n        \"data-orientation\": state.context.orientation,\n        \"aria-disabled\": itemState.disabled,\n        \"data-state\": itemState.expanded ? \"open\" : \"closed\",\n        \"data-ownedby\": dom.getRootId(state.context),\n        onFocus() {\n          if (itemState.disabled) return\n          send({ type: \"TRIGGER.FOCUS\", value })\n        },\n        onBlur() {\n          if (itemState.disabled) return\n          send(\"TRIGGER.BLUR\")\n        },\n        onClick(event) {\n          if (itemState.disabled) return\n          if (isSafari()) {\n            event.currentTarget.focus()\n          }\n          send({ type: \"TRIGGER.CLICK\", value })\n        },\n        onKeyDown(event) {\n          if (event.defaultPrevented) return\n          if (itemState.disabled) return\n\n          const keyMap: EventKeyMap = {\n            ArrowDown() {\n              if (state.context.isHorizontal) return\n              send({ type: \"GOTO.NEXT\", value })\n            },\n            ArrowUp() {\n              if (state.context.isHorizontal) return\n              send({ type: \"GOTO.PREV\", value })\n            },\n            ArrowRight() {\n              if (!state.context.isHorizontal) return\n              send({ type: \"GOTO.NEXT\", value })\n            },\n            ArrowLeft() {\n              if (!state.context.isHorizontal) return\n              send({ type: \"GOTO.PREV\", value })\n            },\n            Home() {\n              send({ type: \"GOTO.FIRST\", value })\n            },\n            End() {\n              send({ type: \"GOTO.LAST\", value })\n            },\n          }\n\n          const key = getEventKey(event, {\n            dir: state.context.dir,\n            orientation: state.context.orientation,\n          })\n\n          const exec = keyMap[key]\n\n          if (exec) {\n            exec(event)\n            event.preventDefault()\n          }\n        },\n      })\n    },\n  }\n}\n", "import { nextById, prevById, queryAll, createScope } from \"@zag-js/dom-query\"\nimport { first, last } from \"@zag-js/utils\"\nimport type { MachineContext as Ctx } from \"./accordion.types\"\n\nexport const dom = createScope({\n  getRootId: (ctx: Ctx) => ctx.ids?.root ?? `accordion:${ctx.id}`,\n  getItemId: (ctx: Ctx, value: string) => ctx.ids?.item?.(value) ?? `accordion:${ctx.id}:item:${value}`,\n  getItemContentId: (ctx: Ctx, value: string) => ctx.ids?.content?.(value) ?? `accordion:${ctx.id}:content:${value}`,\n  getItemTriggerId: (ctx: Ctx, value: string) => ctx.ids?.trigger?.(value) ?? `accordion:${ctx.id}:trigger:${value}`,\n\n  getRootEl: (ctx: Ctx) => dom.getById(ctx, dom.getRootId(ctx)),\n  getTriggers: (ctx: Ctx) => {\n    const ownerId = CSS.escape(dom.getRootId(ctx))\n    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`\n    return queryAll(dom.getRootEl(ctx), selector)\n  },\n\n  getFirstTriggerEl: (ctx: Ctx) => first(dom.getTriggers(ctx)),\n  getLastTriggerEl: (ctx: Ctx) => last(dom.getTriggers(ctx)),\n  getNextTriggerEl: (ctx: Ctx, id: string) => nextById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id)),\n  getPrevTriggerEl: (ctx: Ctx, id: string) => prevById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id)),\n})\n", "import { createMachine, guards } from \"@zag-js/core\"\nimport { add, compact, isEqual, remove, warn } from \"@zag-js/utils\"\nimport { dom } from \"./accordion.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./accordion.types\"\n\nconst { and, not } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"accordion\",\n      initial: \"idle\",\n\n      context: {\n        focusedValue: null,\n        value: [],\n        collapsible: false,\n        multiple: false,\n        orientation: \"vertical\",\n        ...ctx,\n      },\n\n      watch: {\n        value: \"coarseValue\",\n        multiple: \"coarseValue\",\n      },\n\n      created: \"coarseValue\",\n\n      computed: {\n        isHorizontal: (ctx) => ctx.orientation === \"horizontal\",\n      },\n\n      on: {\n        \"VALUE.SET\": {\n          actions: [\"setValue\"],\n        },\n      },\n\n      states: {\n        idle: {\n          on: {\n            \"TRIGGER.FOCUS\": {\n              target: \"focused\",\n              actions: \"setFocusedValue\",\n            },\n          },\n        },\n        focused: {\n          on: {\n            \"GOTO.NEXT\": {\n              actions: \"focusNextTrigger\",\n            },\n            \"GOTO.PREV\": {\n              actions: \"focusPrevTrigger\",\n            },\n            \"TRIGGER.CLICK\": [\n              {\n                guard: and(\"isExpanded\", \"canToggle\"),\n                actions: [\"collapse\"],\n              },\n              {\n                guard: not(\"isExpanded\"),\n                actions: [\"expand\"],\n              },\n            ],\n            \"GOTO.FIRST\": {\n              actions: \"focusFirstTrigger\",\n            },\n            \"GOTO.LAST\": {\n              actions: \"focusLastTrigger\",\n            },\n            \"TRIGGER.BLUR\": {\n              target: \"idle\",\n              actions: \"clearFocusedValue\",\n            },\n          },\n        },\n      },\n    },\n    {\n      guards: {\n        canToggle: (ctx) => !!ctx.collapsible || !!ctx.multiple,\n        isExpanded: (ctx, evt) => ctx.value.includes(evt.value),\n      },\n      actions: {\n        collapse(ctx, evt) {\n          const next = ctx.multiple ? remove(ctx.value, evt.value) : []\n          set.value(ctx, ctx.multiple ? next : [])\n        },\n        expand(ctx, evt) {\n          const next = ctx.multiple ? add(ctx.value, evt.value) : [evt.value]\n          set.value(ctx, next)\n        },\n        focusFirstTrigger(ctx) {\n          dom.getFirstTriggerEl(ctx)?.focus()\n        },\n        focusLastTrigger(ctx) {\n          dom.getLastTriggerEl(ctx)?.focus()\n        },\n        focusNextTrigger(ctx) {\n          if (!ctx.focusedValue) return\n          const triggerEl = dom.getNextTriggerEl(ctx, ctx.focusedValue)\n          triggerEl?.focus()\n        },\n        focusPrevTrigger(ctx) {\n          if (!ctx.focusedValue) return\n          const triggerEl = dom.getPrevTriggerEl(ctx, ctx.focusedValue)\n          triggerEl?.focus()\n        },\n        setFocusedValue(ctx, evt) {\n          set.focusedValue(ctx, evt.value)\n        },\n        clearFocusedValue(ctx) {\n          set.focusedValue(ctx, null)\n        },\n        setValue(ctx, evt) {\n          set.value(ctx, evt.value)\n        },\n        coarseValue(ctx) {\n          if (!ctx.multiple && ctx.value.length > 1) {\n            warn(`The value of accordion should be a single value when multiple is false.`)\n            ctx.value = [ctx.value[0]]\n          }\n        },\n      },\n    },\n  )\n}\n\nconst invoke = {\n  change(ctx: MachineContext) {\n    ctx.onValueChange?.({ value: Array.from(ctx.value) })\n  },\n  focusChange(ctx: MachineContext) {\n    ctx.onFocusChange?.({ value: ctx.focusedValue })\n  },\n}\n\nconst set = {\n  value(ctx: MachineContext, value: string[]) {\n    if (isEqual(ctx.value, value)) return\n    ctx.value = value\n    invoke.change(ctx)\n  },\n  focusedValue(ctx: MachineContext, value: string | null) {\n    if (isEqual(ctx.focusedValue, value)) return\n    ctx.focusedValue = value\n    invoke.focusChange(ctx)\n  },\n}\n", "import { createProps } from \"@zag-js/types\"\nimport type { ItemProps, UserDefinedContext } from \"./accordion.types\"\nimport { createSplitProps } from \"@zag-js/utils\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"collapsible\",\n  \"dir\",\n  \"disabled\",\n  \"getRootNode\",\n  \"id\",\n  \"ids\",\n  \"multiple\",\n  \"onFocusChange\",\n  \"onValueChange\",\n  \"orientation\",\n  \"value\",\n])\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const itemProps = createProps<ItemProps>()([\"value\", \"disabled\"])\nexport const splitItemProps = createSplitProps<ItemProps>(itemProps)\n", "import { createNormalizer } from \"@zag-js/types\";\n\nexport const propMap = {\n  onFocus: \"onFocusin\",\n  onBlur: \"onFocusout\",\n  onChange: \"onInput\",\n  onDoubleClick: \"onDblclick\",\n  htmlFor: \"for\",\n  className: \"class\",\n  defaultValue: \"value\",\n  defaultChecked: \"checked\",\n};\n\nconst toStyleString = (style) => {\n  let string = \"\";\n  for (let key in style) {\n    const value = style[key];\n    if (value === null || value === undefined) continue;\n    if (!key.startsWith(\"--\")) key = key.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n    string += `${key}:${value};`;\n  }\n  return string;\n};\n\nexport const normalizeProps = createNormalizer((props) => {\n  return Object.entries(props).reduce((acc, [key, value]) => {\n    if (value === undefined) return acc;\n\n    if (key in propMap) {\n      key = propMap[key];\n    }\n\n    if (key === \"style\" && typeof value === \"object\") {\n      acc.style = toStyleString(value);\n      return acc;\n    }\n\n    acc[key.toLowerCase()] = value;\n\n    return acc;\n  }, {});\n});\n", "const prevAttrsMap = new WeakMap();\n\nexport function spreadProps(node, attrs) {\n  const oldAttrs = prevAttrsMap.get(node) || {};\n  const attrKeys = Object.keys(attrs);\n\n  const addEvent = (e, f) => {\n    node.addEventListener(e.toLowerCase(), f);\n  };\n\n  const removeEvent = (e, f) => {\n    node.removeEventListener(e.toLowerCase(), f);\n  };\n\n  const onEvents = (attr) => attr.startsWith(\"on\");\n  const others = (attr) => !attr.startsWith(\"on\");\n\n  const setup = (attr) => addEvent(attr.substring(2), attrs[attr]);\n  const teardown = (attr) => removeEvent(attr.substring(2), attrs[attr]);\n\n  const apply = (attrName) => {\n    let value = attrs[attrName];\n\n    const oldValue = oldAttrs[attrName];\n    if (value === oldValue) return;\n\n    if (typeof value === \"boolean\") {\n      value = value || undefined;\n    }\n\n    if (value != null) {\n      if ([\"value\", \"checked\", \"htmlFor\"].includes(attrName)) {\n        node[attrName] = value;\n      } else {\n        node.setAttribute(attrName.toLowerCase(), value);\n      }\n      return;\n    }\n\n    node.removeAttribute(attrName.toLowerCase());\n  };\n\n  for (const key in oldAttrs) {\n    if (attrs[key] == null) {\n      node.removeAttribute(key.toLowerCase());\n    }\n  }\n\n  const oldEvents = Object.keys(oldAttrs).filter(onEvents);\n  oldEvents.forEach((evt) => {\n    removeEvent(evt.substring(2), oldAttrs[evt]);\n  });\n\n  attrKeys.filter(onEvents).forEach(setup);\n  attrKeys.filter(others).forEach(apply);\n\n  prevAttrsMap.set(node, attrs);\n\n  return function cleanup() {\n    attrKeys.filter(onEvents).forEach(teardown);\n  };\n}\n", "import * as accordion from \"@zag-js/accordion\";\nimport { normalizeProps } from \"./normalize-props\";\nimport { spreadProps } from \"./spread-props\";\n\nexport const Accordion = {\n  mounted() {\n    this.context = { id: this.el.id };\n\n    this.service = accordion.machine(this.context);\n    this.api = accordion.connect(this.service.state, this.service.send, normalizeProps);\n\n    this.init();\n  },\n\n  beforeDestroy() {\n    this.service.stop();\n  },\n\n  init() {\n    const service = this.service;\n\n    this.render();\n    service.subscribe(() => {\n      this.api = accordion.connect(service.state, service.send, normalizeProps);\n      this.render();\n    });\n\n    service.start();\n  },\n\n  items() {\n    return Array.from(this.el.querySelectorAll(\"[data-element='item']\"));\n  },\n\n  render() {\n    spreadProps(this.el, this.api.rootProps);\n\n    this.items().forEach((item) => {\n      this.renderItem(item);\n    });\n  },\n\n  renderItem(item) {\n    const index = item.dataset.index;\n    if (!index) throw new Error(\"Expected index to be defined\");\n\n    const trigger = item.querySelector(\"[data-element='trigger']\");\n    const content = item.querySelector(\"[data-element='content']\");\n\n    if (!trigger) throw new Error(\"Expected trigger to be defined\");\n    if (!content) throw new Error(\"Expected content to be defined\");\n\n    spreadProps(item, this.api.getItemProps({ value: index }));\n    spreadProps(trigger, this.api.getItemTriggerProps({ value: index }));\n    spreadProps(content, this.api.getItemContentProps({ value: index }));\n  },\n};\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = currentWin.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = currentWin.frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \u2014\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import type { AutoUpdateOptions, Middleware } from \"@floating-ui/dom\"\nimport { arrow, autoUpdate, computePosition, flip, limitShift, offset, shift, size } from \"@floating-ui/dom\"\nimport { getWindow, raf } from \"@zag-js/dom-query\"\nimport { compact, isNull, noop, runIfFn } from \"@zag-js/utils\"\nimport { getAnchorElement } from \"./get-anchor\"\nimport { rectMiddleware, shiftArrowMiddleware, transformOriginMiddleware } from \"./middleware\"\nimport { getPlacementDetails } from \"./placement\"\nimport type { MaybeElement, MaybeFn, MaybeRectElement, PositioningOptions } from \"./types\"\n\nconst defaultOptions: PositioningOptions = {\n  strategy: \"absolute\",\n  placement: \"bottom\",\n  listeners: true,\n  gutter: 8,\n  flip: true,\n  slide: true,\n  overlap: false,\n  sameWidth: false,\n  fitViewport: false,\n  overflowPadding: 8,\n  arrowPadding: 4,\n}\n\nfunction roundByDpr(win: Window, value: number) {\n  const dpr = win.devicePixelRatio || 1\n  return Math.round(value * dpr) / dpr\n}\n\nfunction getBoundaryMiddleware(opts: PositioningOptions) {\n  return runIfFn(opts.boundary)\n}\n\nfunction getArrowMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (!arrowElement) return\n  return arrow({\n    element: arrowElement,\n    padding: opts.arrowPadding,\n  })\n}\n\nfunction getOffsetMiddleware(arrowElement: HTMLElement | null, opts: PositioningOptions) {\n  if (isNull(opts.offset ?? opts.gutter)) return\n  return offset(({ placement }) => {\n    const arrowOffset = (arrowElement?.clientHeight || 0) / 2\n\n    const gutter = opts.offset?.mainAxis ?? opts.gutter\n    const mainAxis = typeof gutter === \"number\" ? gutter + arrowOffset : gutter ?? arrowOffset\n\n    const { hasAlign } = getPlacementDetails(placement)\n    const shift = !hasAlign ? opts.shift : undefined\n    const crossAxis = opts.offset?.crossAxis ?? shift\n\n    return compact({\n      crossAxis: crossAxis,\n      mainAxis: mainAxis,\n      alignmentAxis: opts.shift,\n    })\n  })\n}\n\nfunction getFlipMiddleware(opts: PositioningOptions) {\n  if (!opts.flip) return\n  return flip({\n    boundary: getBoundaryMiddleware(opts),\n    padding: opts.overflowPadding,\n    fallbackPlacements: opts.flip === true ? undefined : opts.flip,\n  })\n}\n\nfunction getShiftMiddleware(opts: PositioningOptions) {\n  if (!opts.slide && !opts.overlap) return\n  return shift({\n    boundary: getBoundaryMiddleware(opts),\n    mainAxis: opts.slide,\n    crossAxis: opts.overlap,\n    padding: opts.overflowPadding,\n    limiter: limitShift(),\n  })\n}\n\nfunction getSizeMiddleware(opts: PositioningOptions) {\n  return size({\n    padding: opts.overflowPadding,\n    apply({ elements, rects, availableHeight, availableWidth }) {\n      const floating = elements.floating\n\n      const referenceWidth = Math.round(rects.reference.width)\n      availableWidth = Math.floor(availableWidth)\n      availableHeight = Math.floor(availableHeight)\n\n      floating.style.setProperty(\"--reference-width\", `${referenceWidth}px`)\n      floating.style.setProperty(\"--available-width\", `${availableWidth}px`)\n      floating.style.setProperty(\"--available-height\", `${availableHeight}px`)\n    },\n  })\n}\n\nfunction getAutoUpdateOptions(opts?: boolean | AutoUpdateOptions): AutoUpdateOptions {\n  if (!opts) return {}\n  if (opts === true) {\n    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true }\n  }\n  return opts\n}\n\nfunction getPlacementImpl(referenceOrVirtual: MaybeRectElement, floating: MaybeElement, opts: PositioningOptions = {}) {\n  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect)\n  if (!floating || !reference) return\n  const options = Object.assign({}, defaultOptions, opts)\n\n  /* -----------------------------------------------------------------------------\n   * The middleware stack\n   * -----------------------------------------------------------------------------*/\n\n  const arrowEl = floating.querySelector<HTMLElement>(\"[data-part=arrow]\")\n\n  const middleware: (Middleware | undefined)[] = [\n    getOffsetMiddleware(arrowEl, options),\n    getFlipMiddleware(options),\n    getShiftMiddleware(options),\n    getArrowMiddleware(arrowEl, options),\n    shiftArrowMiddleware(arrowEl),\n    transformOriginMiddleware,\n    getSizeMiddleware(options),\n    rectMiddleware,\n  ]\n\n  /* -----------------------------------------------------------------------------\n   * The actual positioning function\n   * -----------------------------------------------------------------------------*/\n\n  const { placement, strategy, onComplete, onPositioned } = options\n\n  const updatePosition = async () => {\n    if (!reference || !floating) return\n\n    const pos = await computePosition(reference, floating, {\n      placement,\n      middleware,\n      strategy,\n    })\n\n    onComplete?.(pos)\n    onPositioned?.({ placed: true })\n\n    const win = getWindow(floating)\n    const x = roundByDpr(win, pos.x)\n    const y = roundByDpr(win, pos.y)\n\n    floating.style.setProperty(\"--x\", `${x}px`)\n    floating.style.setProperty(\"--y\", `${y}px`)\n\n    const contentEl = floating.firstElementChild\n\n    if (contentEl) {\n      const zIndex = win.getComputedStyle(contentEl).zIndex\n      floating.style.setProperty(\"--z-index\", zIndex)\n    }\n  }\n\n  const update = async () => {\n    if (opts.updatePosition) {\n      await opts.updatePosition({ updatePosition })\n      onPositioned?.({ placed: true })\n    } else {\n      await updatePosition()\n    }\n  }\n\n  const autoUpdateOptions = getAutoUpdateOptions(options.listeners)\n  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop\n\n  update()\n\n  return () => {\n    cancelAutoUpdate?.()\n    onPositioned?.({ placed: false })\n  }\n}\n\nexport function getPlacement(\n  referenceOrFn: MaybeFn<MaybeRectElement>,\n  floatingOrFn: MaybeFn<MaybeElement>,\n  opts: PositioningOptions & { defer?: boolean } = {},\n) {\n  const { defer, ...options } = opts\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const reference = typeof referenceOrFn === \"function\" ? referenceOrFn() : referenceOrFn\n      const floating = typeof floatingOrFn === \"function\" ? floatingOrFn() : floatingOrFn\n      cleanups.push(getPlacementImpl(reference, floating, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { isHTMLElement } from \"@zag-js/dom-query\"\nimport type { AnchorRect, MaybeRectElement } from \"./types\"\n\nexport function createDOMRect(x = 0, y = 0, width = 0, height = 0) {\n  if (typeof DOMRect === \"function\") {\n    return new DOMRect(x, y, width, height)\n  }\n  const rect = {\n    x,\n    y,\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n  }\n  return { ...rect, toJSON: () => rect }\n}\n\nfunction getDOMRect(anchorRect?: AnchorRect | null) {\n  if (!anchorRect) return createDOMRect()\n  const { x, y, width, height } = anchorRect\n  return createDOMRect(x, y, width, height)\n}\n\nexport function getAnchorElement(\n  anchorElement: MaybeRectElement,\n  getAnchorRect?: (anchor: MaybeRectElement) => AnchorRect | null,\n) {\n  return {\n    contextElement: isHTMLElement(anchorElement) ? anchorElement : undefined,\n    getBoundingClientRect: () => {\n      const anchor = anchorElement\n      const anchorRect = getAnchorRect?.(anchor)\n      if (anchorRect || !anchor) {\n        return getDOMRect(anchorRect)\n      }\n      return anchor.getBoundingClientRect()\n    },\n  }\n}\n", "import type { Coords, Middleware } from \"@floating-ui/dom\"\nimport type { PlacementSide } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Shared middleware utils\n * -----------------------------------------------------------------------------*/\n\nconst toVar = (value: string) => ({ variable: value, reference: `var(${value})` })\n\nexport const cssVars = {\n  arrowSize: toVar(\"--arrow-size\"),\n  arrowSizeHalf: toVar(\"--arrow-size-half\"),\n  arrowBg: toVar(\"--arrow-background\"),\n  transformOrigin: toVar(\"--transform-origin\"),\n  arrowOffset: toVar(\"--arrow-offset\"),\n}\n\n/* -----------------------------------------------------------------------------\n * Transform Origin Middleware\n * -----------------------------------------------------------------------------*/\n\nconst getTransformOrigin = (arrow?: Partial<Coords>) => ({\n  top: \"bottom center\",\n  \"top-start\": arrow ? `${arrow.x}px bottom` : \"left bottom\",\n  \"top-end\": arrow ? `${arrow.x}px bottom` : \"right bottom\",\n  bottom: \"top center\",\n  \"bottom-start\": arrow ? `${arrow.x}px top` : \"top left\",\n  \"bottom-end\": arrow ? `${arrow.x}px top` : \"top right\",\n  left: \"right center\",\n  \"left-start\": arrow ? `right ${arrow.y}px` : \"right top\",\n  \"left-end\": arrow ? `right ${arrow.y}px` : \"right bottom\",\n  right: \"left center\",\n  \"right-start\": arrow ? `left ${arrow.y}px` : \"left top\",\n  \"right-end\": arrow ? `left ${arrow.y}px` : \"left bottom\",\n})\n\nexport const transformOriginMiddleware: Middleware = {\n  name: \"transformOrigin\",\n  fn({ placement, elements, middlewareData }) {\n    const { arrow } = middlewareData\n    const transformOrigin = getTransformOrigin(arrow)[placement]\n\n    const { floating } = elements\n    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin)\n\n    return {\n      data: { transformOrigin },\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Rect Middleware (to expose the rect data)\n * -----------------------------------------------------------------------------*/\n\nexport const rectMiddleware: Middleware = {\n  name: \"rects\",\n  fn({ rects }) {\n    return {\n      data: rects,\n    }\n  },\n}\n\n/* -----------------------------------------------------------------------------\n * Arrow Middleware\n * -----------------------------------------------------------------------------*/\n\nexport const shiftArrowMiddleware = (arrowEl: HTMLElement | null): Middleware | undefined => {\n  if (!arrowEl) return\n  return {\n    name: \"shiftArrow\",\n    fn({ placement, middlewareData }) {\n      if (!middlewareData.arrow) return {}\n      const { x, y } = middlewareData.arrow\n      const dir = placement.split(\"-\")[0] as PlacementSide\n\n      Object.assign(arrowEl.style, {\n        left: x != null ? `${x}px` : \"\",\n        top: y != null ? `${y}px` : \"\",\n        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`,\n      })\n\n      return {}\n    },\n  }\n}\n", "import type { Placement } from \"@floating-ui/dom\"\nimport type { PlacementAlign, PlacementSide } from \"./types\"\n\nexport function isValidPlacement(v: string): v is Placement {\n  return /^(?:top|bottom|left|right)(?:-(?:start|end))?$/.test(v)\n}\n\nexport function getPlacementDetails(placement: Placement) {\n  const [side, align] = placement.split(\"-\") as [PlacementSide, PlacementAlign | undefined]\n  return { side, align, hasAlign: align != null }\n}\n\nexport function getPlacementSide(placement: Placement): PlacementSide {\n  return placement.split(\"-\")[0] as PlacementSide\n}\n", "import type { Placement } from \"@floating-ui/dom\"\nimport { cssVars } from \"./middleware\"\nimport type { PositioningOptions } from \"./types\"\n\nexport interface GetPlacementStylesOptions {\n  placement?: Placement\n}\n\nconst ARROW_FLOATING_STYLE = {\n  bottom: \"rotate(45deg)\",\n  left: \"rotate(135deg)\",\n  top: \"rotate(225deg)\",\n  right: \"rotate(315deg)\",\n} as const\n\nexport function getPlacementStyles(\n  options: Pick<PositioningOptions, \"placement\" | \"sameWidth\" | \"fitViewport\" | \"strategy\"> = {},\n) {\n  const { placement, sameWidth, fitViewport, strategy = \"absolute\" } = options\n\n  return {\n    arrow: {\n      position: \"absolute\",\n      width: cssVars.arrowSize.reference,\n      height: cssVars.arrowSize.reference,\n      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,\n      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`,\n    } as const,\n\n    arrowTip: {\n      transform: placement ? ARROW_FLOATING_STYLE[placement.split(\"-\")[0]] : undefined,\n      background: cssVars.arrowBg.reference,\n      top: \"0\",\n      left: \"0\",\n      width: \"100%\",\n      height: \"100%\",\n      position: \"absolute\",\n      zIndex: \"inherit\",\n    } as const,\n\n    floating: {\n      position: strategy,\n      isolation: \"isolate\",\n      minWidth: sameWidth ? undefined : \"max-content\",\n      width: sameWidth ? \"var(--reference-width)\" : undefined,\n      maxWidth: fitViewport ? \"var(--available-width)\" : undefined,\n      maxHeight: fitViewport ? \"var(--available-height)\" : undefined,\n      top: \"0px\",\n      left: \"0px\",\n      // move off-screen if placement is not defined\n      transform: placement ? \"translate3d(var(--x), var(--y), 0)\" : \"translate3d(0, -100vh, 0)\",\n      zIndex: \"var(--z-index)\",\n    } as const,\n  }\n}\n", "import { addDomEvent, fireCustomEvent, isContextMenuEvent } from \"@zag-js/dom-event\"\nimport { contains, getDocument, getEventTarget, getWindow, isFocusable, isHTMLElement, raf } from \"@zag-js/dom-query\"\nimport { callAll } from \"@zag-js/utils\"\nimport { getWindowFrames } from \"./get-window-frames\"\n\nexport interface InteractOutsideHandlers {\n  /**\n   * Function called when the pointer is pressed down outside the component\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void\n  /**\n   * Function called when the focus is moved outside the component\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void\n  /**\n   * Function called when an interaction happens outside the component\n   */\n  onInteractOutside?: (event: InteractOutsideEvent) => void\n}\n\nexport interface InteractOutsideOptions extends InteractOutsideHandlers {\n  exclude?: (target: HTMLElement) => boolean\n  defer?: boolean\n}\n\nexport interface EventDetails<T> {\n  originalEvent: T\n  contextmenu: boolean\n  focusable: boolean\n}\n\nconst POINTER_OUTSIDE_EVENT = \"pointerdown.outside\"\nconst FOCUS_OUTSIDE_EVENT = \"focus.outside\"\n\nexport type PointerDownOutsideEvent = CustomEvent<EventDetails<PointerEvent>>\n\nexport type FocusOutsideEvent = CustomEvent<EventDetails<FocusEvent>>\n\nexport type InteractOutsideEvent = PointerDownOutsideEvent | FocusOutsideEvent\n\nexport type MaybeElement = HTMLElement | null | undefined\nexport type NodeOrFn = MaybeElement | (() => MaybeElement)\n\nfunction isComposedPathFocusable(composedPath: EventTarget[]) {\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node)) return true\n  }\n  return false\n}\n\nconst isPointerEvent = (event: Event): event is PointerEvent => \"clientY\" in event\n\nfunction isEventPointWithin(node: MaybeElement, event: Event) {\n  if (!isPointerEvent(event) || !node) return false\n\n  const rect = node.getBoundingClientRect()\n  if (rect.width === 0 || rect.height === 0) return false\n\n  return (\n    rect.top <= event.clientY &&\n    event.clientY <= rect.top + rect.height &&\n    rect.left <= event.clientX &&\n    event.clientX <= rect.left + rect.width\n  )\n}\n\nfunction isEventWithinScrollbar(event: Event): boolean {\n  const target = getEventTarget<HTMLElement>(event)\n  if (!target || !isPointerEvent(event)) return false\n\n  const isScrollableY = target.scrollHeight > target.clientHeight\n  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth\n\n  const isScrollableX = target.scrollWidth > target.clientWidth\n  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight\n\n  return onScrollbarY || onScrollbarX\n}\n\nfunction trackInteractOutsideImpl(node: MaybeElement, options: InteractOutsideOptions) {\n  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options\n\n  if (!node) return\n\n  const doc = getDocument(node)\n  const win = getWindow(node)\n  const frames = getWindowFrames(win)\n\n  function isEventOutside(event: Event): boolean {\n    const target = getEventTarget(event)\n    if (!isHTMLElement(target)) return false\n    if (contains(node, target)) return false\n    if (isEventPointWithin(node, event)) return false\n    if (isEventWithinScrollbar(event)) return false\n    return !exclude?.(target)\n  }\n\n  let clickHandler: VoidFunction\n\n  function onPointerDown(event: PointerEvent) {\n    //\n    function handler() {\n      const func = defer ? raf : (v: any) => v()\n      const composedPath = event.composedPath?.() ?? [event.target]\n      func(() => {\n        if (!node || !isEventOutside(event)) return\n\n        if (onPointerDownOutside || onInteractOutside) {\n          const handler = callAll(onPointerDownOutside, onInteractOutside) as EventListener\n          node.addEventListener(POINTER_OUTSIDE_EVENT, handler, { once: true })\n        }\n\n        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n          bubbles: false,\n          cancelable: true,\n          detail: {\n            originalEvent: event,\n            contextmenu: isContextMenuEvent(event),\n            focusable: isComposedPathFocusable(composedPath),\n          },\n        })\n      })\n    }\n\n    if (event.pointerType === \"touch\") {\n      frames.removeEventListener(\"click\", handler)\n      doc.removeEventListener(\"click\", handler)\n\n      clickHandler = handler\n\n      doc.addEventListener(\"click\", handler, { once: true })\n      frames.addEventListener(\"click\", handler, { once: true })\n    } else {\n      handler()\n    }\n  }\n  const cleanups = new Set<VoidFunction>()\n\n  const timer = setTimeout(() => {\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true))\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true))\n  }, 0)\n\n  function onFocusin(event: FocusEvent) {\n    //\n    const func = defer ? raf : (v: any) => v()\n    func(() => {\n      if (!node || !isEventOutside(event)) return\n\n      if (onFocusOutside || onInteractOutside) {\n        const handler = callAll(onFocusOutside, onInteractOutside) as EventListener\n        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true })\n      }\n\n      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: false,\n          focusable: isFocusable(getEventTarget(event)),\n        },\n      })\n    })\n  }\n\n  cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true))\n  cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true))\n\n  return () => {\n    clearTimeout(timer)\n    if (clickHandler) {\n      frames.removeEventListener(\"click\", clickHandler)\n      doc.removeEventListener(\"click\", clickHandler)\n    }\n    cleanups.forEach((fn) => fn())\n  }\n}\n\nexport function trackInteractOutside(nodeOrFn: NodeOrFn, options: InteractOutsideOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(trackInteractOutsideImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "export function getWindowFrames(win: Window) {\n  const frames = {\n    each(cb: (win: Window) => void) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i]\n        if (frame) cb(frame)\n      }\n    },\n    addEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.addEventListener(event, listener, options)\n        } catch {}\n      })\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options)\n        } catch {}\n      }\n    },\n    removeEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.removeEventListener(event, listener, options)\n        } catch {}\n      })\n    },\n  }\n  return frames\n}\n", "import { contains, getEventTarget, isHTMLElement, raf } from \"@zag-js/dom-query\"\nimport {\n  trackInteractOutside,\n  type FocusOutsideEvent,\n  type InteractOutsideHandlers,\n  type PointerDownOutsideEvent,\n} from \"@zag-js/interact-outside\"\nimport { isFunction, warn, type MaybeFunction } from \"@zag-js/utils\"\nimport { trackEscapeKeydown } from \"./escape-keydown\"\nimport { layerStack, type Layer } from \"./layer-stack\"\nimport { assignPointerEventToLayers, clearPointerEvent, disablePointerEventsOutside } from \"./pointer-event-outside\"\n\ntype MaybeElement = HTMLElement | null\ntype Container = MaybeElement | Array<MaybeElement>\ntype NodeOrFn = MaybeFunction<MaybeElement>\n\nexport interface DismissableElementHandlers extends InteractOutsideHandlers {\n  /**\n   * Function called when the escape key is pressed\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void\n}\n\nexport interface PersistentElementOptions {\n  /**\n   * Returns the persistent elements that:\n   * - should not have pointer-events disabled\n   * - should not trigger the dismiss event\n   */\n  persistentElements?: Array<() => Element | null>\n}\n\nexport interface DismissableElementOptions extends DismissableElementHandlers, PersistentElementOptions {\n  /**\n   * Whether to log debug information\n   */\n  debug?: boolean\n  /**\n   * Whether to block pointer events outside the dismissable element\n   */\n  pointerBlocking?: boolean\n  /**\n   * Function called when the dismissable element is dismissed\n   */\n  onDismiss: VoidFunction\n  /**\n   * Exclude containers from the interact outside event\n   */\n  exclude?: MaybeFunction<Container>\n  /**\n   * Defer the interact outside event to the next frame\n   */\n  defer?: boolean\n}\n\nfunction trackDismissableElementImpl(node: MaybeElement, options: DismissableElementOptions) {\n  if (!node) {\n    warn(\"[@zag-js/dismissable] node is `null` or `undefined`\")\n    return\n  }\n\n  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options\n\n  const layer: Layer = { dismiss: onDismiss, node, pointerBlocking }\n\n  layerStack.add(layer)\n  assignPointerEventToLayers()\n\n  function onPointerDownOutside(event: PointerDownOutsideEvent) {\n    const target = getEventTarget(event.detail.originalEvent)\n    if (layerStack.isBelowPointerBlockingLayer(node!) || layerStack.isInBranch(target)) return\n    options.onPointerDownOutside?.(event)\n    options.onInteractOutside?.(event)\n    if (event.defaultPrevented) return\n    if (debug) {\n      console.log(\"onPointerDownOutside:\", event.detail.originalEvent)\n    }\n    onDismiss?.()\n  }\n\n  function onFocusOutside(event: FocusOutsideEvent) {\n    const target = getEventTarget(event.detail.originalEvent)\n    if (layerStack.isInBranch(target)) return\n    options.onFocusOutside?.(event)\n    options.onInteractOutside?.(event)\n    if (event.defaultPrevented) return\n    if (debug) {\n      console.log(\"onFocusOutside:\", event.detail.originalEvent)\n    }\n    onDismiss?.()\n  }\n\n  function onEscapeKeyDown(event: KeyboardEvent) {\n    if (!layerStack.isTopMost(node!)) return\n    options.onEscapeKeyDown?.(event)\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault()\n      onDismiss()\n    }\n  }\n\n  function exclude(target: Element) {\n    if (!node) return false\n    const containers = typeof excludeContainers === \"function\" ? excludeContainers() : excludeContainers\n    const _containers = Array.isArray(containers) ? containers : [containers]\n    const persistentElements = options.persistentElements?.map((fn) => fn()).filter(isHTMLElement)\n    if (persistentElements) _containers.push(...persistentElements)\n    return _containers.some((node) => contains(node, target)) || layerStack.isInNestedLayer(node, target)\n  }\n\n  const cleanups = [\n    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : undefined,\n    trackEscapeKeydown(node, onEscapeKeyDown),\n    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer }),\n  ]\n\n  return () => {\n    layerStack.remove(node!)\n    // re-assign pointer event to remaining layers\n    assignPointerEventToLayers()\n    // remove pointer event from removed layer\n    clearPointerEvent(node!)\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n\nexport function trackDismissableElement(nodeOrFn: NodeOrFn, options: DismissableElementOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn\n      cleanups.push(trackDismissableElementImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n\nexport function trackDismissableBranch(nodeOrFn: NodeOrFn, options: { defer?: boolean } = {}) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n\n  cleanups.push(\n    func(() => {\n      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn\n      if (!node) {\n        warn(\"[@zag-js/dismissable] branch node is `null` or `undefined`\")\n        return\n      }\n      layerStack.addBranch(node)\n      cleanups.push(() => {\n        layerStack.removeBranch(node)\n      })\n    }),\n  )\n\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n", "import { addDomEvent } from \"@zag-js/dom-event\"\nimport { getDocument } from \"@zag-js/dom-query\"\n\nexport function trackEscapeKeydown(node: HTMLElement, fn?: (event: KeyboardEvent) => void) {\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (event.key !== \"Escape\") return\n    if (event.isComposing) return\n    fn?.(event)\n  }\n\n  return addDomEvent(getDocument(node), \"keydown\", handleKeyDown, { capture: true })\n}\n", "import { contains } from \"@zag-js/dom-query\"\n\nexport interface Layer {\n  dismiss: VoidFunction\n  node: HTMLElement\n  pointerBlocking?: boolean\n}\n\nexport const layerStack = {\n  layers: [] as Layer[],\n  branches: [] as HTMLElement[],\n  count(): number {\n    return this.layers.length\n  },\n  pointerBlockingLayers(): Layer[] {\n    return this.layers.filter((layer) => layer.pointerBlocking)\n  },\n  topMostPointerBlockingLayer(): Layer | undefined {\n    return [...this.pointerBlockingLayers()].slice(-1)[0]\n  },\n  hasPointerBlockingLayer(): boolean {\n    return this.pointerBlockingLayers().length > 0\n  },\n  isBelowPointerBlockingLayer(node: HTMLElement) {\n    const index = this.indexOf(node)\n    const highestBlockingIndex = this.topMostPointerBlockingLayer()\n      ? this.indexOf(this.topMostPointerBlockingLayer()?.node)\n      : -1\n    return index < highestBlockingIndex\n  },\n  isTopMost(node: HTMLElement | null) {\n    const layer = this.layers[this.count() - 1]\n    return layer?.node === node\n  },\n  getNestedLayers(node: HTMLElement) {\n    return Array.from(this.layers).slice(this.indexOf(node) + 1)\n  },\n  isInNestedLayer(node: HTMLElement, target: HTMLElement | EventTarget | null) {\n    return this.getNestedLayers(node).some((layer) => contains(layer.node, target))\n  },\n  isInBranch(target: HTMLElement | EventTarget | null) {\n    return Array.from(this.branches).some((branch) => contains(branch, target))\n  },\n  add(layer: Layer) {\n    const num = this.layers.push(layer)\n    layer.node.style.setProperty(\"--layer-index\", `${num}`)\n  },\n  addBranch(node: HTMLElement) {\n    this.branches.push(node)\n  },\n  remove(node: HTMLElement) {\n    const index = this.indexOf(node)\n    if (index < 0) return\n\n    // dismiss nested layers\n    if (index < this.count() - 1) {\n      const _layers = this.getNestedLayers(node)\n      _layers.forEach((layer) => layer.dismiss())\n    }\n    // remove this layer\n    this.layers.splice(index, 1)\n    node.style.removeProperty(\"--layer-index\")\n  },\n  removeBranch(node: HTMLElement) {\n    const index = this.branches.indexOf(node)\n    if (index >= 0) this.branches.splice(index, 1)\n  },\n  indexOf(node: HTMLElement | undefined) {\n    return this.layers.findIndex((layer) => layer.node === node)\n  },\n  dismiss(node: HTMLElement) {\n    this.layers[this.indexOf(node)]?.dismiss()\n  },\n  clear() {\n    this.remove(this.layers[0].node)\n  },\n}\n", "import { getDocument, setStyle, waitForElements } from \"@zag-js/dom-query\"\nimport { layerStack } from \"./layer-stack\"\n\nlet originalBodyPointerEvents: string\n\nexport function assignPointerEventToLayers() {\n  layerStack.layers.forEach(({ node }) => {\n    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? \"none\" : \"auto\"\n  })\n}\n\nexport function clearPointerEvent(node: HTMLElement) {\n  node.style.pointerEvents = \"\"\n}\n\nexport function disablePointerEventsOutside(node: HTMLElement, peristentElements?: Array<() => Element | null>) {\n  const doc = getDocument(node)\n\n  const cleanups: VoidFunction[] = []\n\n  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute(\"data-inert\")) {\n    originalBodyPointerEvents = document.body.style.pointerEvents\n    queueMicrotask(() => {\n      doc.body.style.pointerEvents = \"none\"\n      doc.body.setAttribute(\"data-inert\", \"\")\n    })\n  }\n\n  if (peristentElements) {\n    const persistedCleanup = waitForElements(peristentElements, (el) => {\n      cleanups.push(setStyle(el, { pointerEvents: \"auto\" }))\n    })\n    cleanups.push(persistedCleanup)\n  }\n\n  return () => {\n    if (layerStack.hasPointerBlockingLayer()) return\n    queueMicrotask(() => {\n      doc.body.style.pointerEvents = originalBodyPointerEvents\n      doc.body.removeAttribute(\"data-inert\")\n      if (doc.body.style.length === 0) doc.body.removeAttribute(\"style\")\n    })\n    cleanups.forEach((fn) => fn())\n  }\n}\n", "import type { Point } from \"./types\"\n\nexport class AffineTransform {\n  m00: number\n  m01: number\n  m02: number\n  m10: number\n  m11: number\n  m12: number\n\n  constructor([m00, m01, m02, m10, m11, m12]: Iterable<number> = [0, 0, 0, 0, 0, 0]) {\n    this.m00 = m00\n    this.m01 = m01\n    this.m02 = m02\n    this.m10 = m10\n    this.m11 = m11\n    this.m12 = m12\n  }\n\n  applyTo(point: Point): Point {\n    const { x, y } = point\n    const { m00, m01, m02, m10, m11, m12 } = this\n\n    return {\n      x: m00 * x + m01 * y + m02,\n      y: m10 * x + m11 * y + m12,\n    }\n  }\n\n  prepend(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      this.m00 * other.m00 + this.m01 * other.m10, // m00\n      this.m00 * other.m01 + this.m01 * other.m11, // m01\n      this.m00 * other.m02 + this.m01 * other.m12 + this.m02, // m02\n      this.m10 * other.m00 + this.m11 * other.m10, // m10\n      this.m10 * other.m01 + this.m11 * other.m11, // m11\n      this.m10 * other.m02 + this.m11 * other.m12 + this.m12, // m12\n    ])\n  }\n\n  append(other: AffineTransform): AffineTransform {\n    return new AffineTransform([\n      other.m00 * this.m00 + other.m01 * this.m10, // m00\n      other.m00 * this.m01 + other.m01 * this.m11, // m01\n      other.m00 * this.m02 + other.m01 * this.m12 + other.m02, // m02\n      other.m10 * this.m00 + other.m11 * this.m10, // m10\n      other.m10 * this.m01 + other.m11 * this.m11, // m11\n      other.m10 * this.m02 + other.m11 * this.m12 + other.m12, // m12\n    ])\n  }\n\n  get determinant() {\n    return this.m00 * this.m11 - this.m01 * this.m10\n  }\n\n  get isInvertible() {\n    const det = this.determinant\n\n    return isFinite(det) && isFinite(this.m02) && isFinite(this.m12) && det !== 0\n  }\n\n  invert() {\n    const det = this.determinant\n\n    return new AffineTransform([\n      this.m11 / det, // m00\n      -this.m01 / det, // m01\n      (this.m01 * this.m12 - this.m11 * this.m02) / det, // m02\n      -this.m10 / det, // m10\n      this.m00 / det, // m11\n      (this.m10 * this.m02 - this.m00 * this.m12) / det, // m12\n    ])\n  }\n\n  get array(): number[] {\n    return [this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, 0, 0, 1]\n  }\n\n  get float32Array(): Float32Array {\n    return new Float32Array(this.array)\n  }\n\n  // Static\n\n  static get identity(): AffineTransform {\n    return new AffineTransform([1, 0, 0, 0, 1, 0])\n  }\n\n  static rotate(theta: number, origin?: Point): AffineTransform {\n    const rotation = new AffineTransform([Math.cos(theta), -Math.sin(theta), 0, Math.sin(theta), Math.cos(theta), 0])\n\n    if (origin && (origin.x !== 0 || origin.y !== 0)) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        rotation,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return rotation\n  }\n\n  rotate: (typeof AffineTransform)[\"rotate\"] = (...args) => {\n    return this.prepend(AffineTransform.rotate(...args))\n  }\n\n  static scale(sx: number, sy: number = sx, origin: Point = { x: 0, y: 0 }): AffineTransform {\n    const scale = new AffineTransform([sx, 0, 0, 0, sy, 0])\n\n    if (origin.x !== 0 || origin.y !== 0) {\n      return AffineTransform.multiply(\n        AffineTransform.translate(origin.x, origin.y),\n        scale,\n        AffineTransform.translate(-origin.x, -origin.y),\n      )\n    }\n\n    return scale\n  }\n\n  scale: (typeof AffineTransform)[\"scale\"] = (...args) => {\n    return this.prepend(AffineTransform.scale(...args))\n  }\n\n  static translate(tx: number, ty: number): AffineTransform {\n    return new AffineTransform([1, 0, tx, 0, 1, ty])\n  }\n\n  translate: (typeof AffineTransform)[\"translate\"] = (...args) => {\n    return this.prepend(AffineTransform.translate(...args))\n  }\n\n  static multiply(...[first, ...rest]: AffineTransform[]): AffineTransform {\n    if (!first) return AffineTransform.identity\n    return rest.reduce((result, item) => result.prepend(item), first)\n  }\n\n  get a() {\n    return this.m00\n  }\n\n  get b() {\n    return this.m10\n  }\n\n  get c() {\n    return this.m01\n  }\n\n  get d() {\n    return this.m11\n  }\n\n  get tx() {\n    return this.m02\n  }\n\n  get ty() {\n    return this.m12\n  }\n\n  get scaleComponents(): Point {\n    return { x: this.a, y: this.d }\n  }\n\n  get translationComponents(): Point {\n    return { x: this.tx, y: this.ty }\n  }\n\n  get skewComponents(): Point {\n    return { x: this.c, y: this.b }\n  }\n\n  toString() {\n    return `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.tx}, ${this.ty})`\n  }\n}\n", "import type { AlignOptions, HAlign, Rect, VAlign } from \"./types\"\n\nfunction hAlign(a: Rect, ref: Rect, h: HAlign): Rect {\n  let x = ref.minX\n  if (h === \"left-inside\") x = ref.minX\n  if (h === \"left-outside\") x = ref.minX - ref.width\n  if (h === \"right-inside\") x = ref.maxX - ref.width\n  if (h === \"right-outside\") x = ref.maxX\n  if (h === \"center\") x = ref.midX - ref.width / 2\n  return { ...a, x }\n}\n\nfunction vAlign(a: Rect, ref: Rect, v: VAlign): Rect {\n  let y = ref.minY\n  if (v === \"top-inside\") y = ref.minY\n  if (v === \"top-outside\") y = ref.minY - a.height\n  if (v === \"bottom-inside\") y = ref.maxY - a.height\n  if (v === \"bottom-outside\") y = ref.maxY\n  if (v === \"center\") y = ref.midY - a.height / 2\n  return { ...a, y }\n}\n\nexport function alignRect(a: Rect, ref: Rect, options: AlignOptions): Rect {\n  const { h, v } = options\n  return vAlign(hAlign(a, ref, h), ref, v)\n}\n", "import type { Point, RectInit, Size } from \"./types\"\n\nconst clamp = (value: number, min: number, max: number) => Math.min(Math.max(value, min), max)\n\nexport const clampPoint = (position: Point, size: Size, boundaryRect: RectInit) => {\n  const x = clamp(position.x, boundaryRect.x, boundaryRect.x + boundaryRect.width - size.width)\n  const y = clamp(position.y, boundaryRect.y, boundaryRect.y + boundaryRect.height - size.height)\n  return { x, y }\n}\n\nconst defaultMinSize: Size = {\n  width: 0,\n  height: 0,\n}\n\nconst defaultMaxSize: Size = {\n  width: Infinity,\n  height: Infinity,\n}\n\nexport const clampSize = (size: Size, minSize = defaultMinSize, maxSize = defaultMaxSize) => {\n  return {\n    width: Math.min(Math.max(size.width, minSize!.width), maxSize!.width),\n    height: Math.min(Math.max(size.height, minSize!.height), maxSize!.height),\n  }\n}\n", "import type { Point, Rect, RectEdge, RectInit } from \"./types\"\n\n/* -----------------------------------------------------------------------------\n * Point\n * -----------------------------------------------------------------------------*/\n\nexport const createPoint = (x: number, y: number) => ({ x, y })\n\nexport const subtractPoints = (a: Point, b: Point) => createPoint(a.x - b.x, a.y - b.y)\nexport const addPoints = (a: Point, b: Point) => createPoint(a.x + b.x, a.y + b.y)\n\nexport function isPoint(v: any): v is Point {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\")\n}\n\n/* -----------------------------------------------------------------------------\n * Rect\n * -----------------------------------------------------------------------------*/\n\nexport function createRect(r: RectInit): Rect {\n  const { x, y, width, height } = r\n  const midX = x + width / 2\n  const midY = y + height / 2\n  return {\n    x,\n    y,\n    width,\n    height,\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n    midX,\n    midY,\n    center: createPoint(midX, midY),\n  }\n}\n\nexport function isRect(v: any): v is Rect {\n  return Reflect.has(v, \"x\") && Reflect.has(v, \"y\") && Reflect.has(v, \"width\") && Reflect.has(v, \"height\")\n}\n\nexport function getRectCenters(v: Rect) {\n  const top = createPoint(v.midX, v.minY)\n  const right = createPoint(v.maxX, v.midY)\n  const bottom = createPoint(v.midX, v.maxY)\n  const left = createPoint(v.minX, v.midY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectCorners(v: Rect) {\n  const top = createPoint(v.minX, v.minY)\n  const right = createPoint(v.maxX, v.minY)\n  const bottom = createPoint(v.maxX, v.maxY)\n  const left = createPoint(v.minX, v.maxY)\n  return { top, right, bottom, left }\n}\n\nexport function getRectEdges(v: Rect) {\n  const c = getRectCorners(v)\n  const top: RectEdge = [c.top, c.right]\n  const right: RectEdge = [c.right, c.bottom]\n  const bottom: RectEdge = [c.left, c.bottom]\n  const left: RectEdge = [c.top, c.left]\n  return { top, right, bottom, left }\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect, RectSide } from \"./types\"\n\n/**\n * Checks if a Rect intersects another Rect\n */\nexport function intersects(a: Rect, b: Rect): boolean {\n  return a.x < b.maxX && a.y < b.maxY && a.maxX > b.x && a.maxY > b.y\n}\n\n/**\n * Returns a new Rect that represents the intersection between two Rects\n */\nexport function intersection(a: Rect, b: Rect): Rect {\n  const x = Math.max(a.x, b.x)\n  const y = Math.max(a.y, b.y)\n  const x2 = Math.min(a.x + a.width, b.x + b.width)\n  const y2 = Math.min(a.y + a.height, b.y + b.height)\n  return createRect({ x, y, width: x2 - x, height: y2 - y })\n}\n\n/**\n * Returns whether two rects collide along each edge\n */\nexport function collisions(a: Rect, b: Rect): Record<RectSide, boolean> {\n  return {\n    top: a.minY <= b.minY,\n    right: a.maxX >= b.maxX,\n    bottom: a.maxY >= b.maxY,\n    left: a.minX <= b.minX,\n  }\n}\n", "import { intersects } from \"./intersection\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport interface DistanceValue extends Point {\n  value: number\n}\n\nexport function distance(a: Point, b: Point = { x: 0, y: 0 }): number {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2))\n}\n\nexport function distanceFromPoint(r: Rect, p: Point): DistanceValue {\n  let x = 0\n  let y = 0\n\n  if (p.x < r.x) x = r.x - p.x\n  else if (p.x > r.maxX) x = p.x - r.maxX\n\n  if (p.y < r.y) y = r.y - p.y\n  else if (p.y > r.maxY) y = p.y - r.maxY\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceFromRect(a: Rect, b: Rect): DistanceValue {\n  if (intersects(a, b)) return { x: 0, y: 0, value: 0 }\n  const left = a.x < b.x ? a : b\n  const right = b.x < a.x ? a : b\n  const upper = a.y < b.y ? a : b\n  const lower = b.y < a.y ? a : b\n  let x = left.x === right.x ? 0 : right.x - left.maxX\n  x = Math.max(0, x)\n  let y = upper.y === lower.y ? 0 : lower.y - upper.maxY\n  y = Math.max(0, y)\n  return { x, y, value: distance({ x, y }) }\n}\n\nexport function distanceBtwEdges(a: Rect, b: Rect): Record<RectSide, number> {\n  return {\n    left: b.x - a.x,\n    top: b.y - a.y,\n    right: a.maxX - b.maxX,\n    bottom: a.maxY - b.maxY,\n  }\n}\n", "import { distance } from \"./distance\"\nimport type { Point, Rect, RectSide } from \"./types\"\n\nexport function closest(...pts: Point[]) {\n  return (a: Point): Point => {\n    const ds = pts.map((b) => distance(b, a))\n    const c = Math.min.apply(Math, ds)\n    return pts[ds.indexOf(c)]\n  }\n}\n\nexport function closestSideToRect(ref: Rect, r: Rect): RectSide {\n  if (r.maxX <= ref.minX) return \"left\"\n  if (r.minX >= ref.maxX) return \"right\"\n  if (r.maxY <= ref.minY) return \"top\"\n  if (r.minY >= ref.maxY) return \"bottom\"\n  return \"left\"\n}\n\nexport function closestSideToPoint(ref: Rect, p: Point): RectSide {\n  const { x, y } = p\n\n  const dl = x - ref.minX\n  const dr = ref.maxX - x\n  const dt = y - ref.minY\n  const db = ref.maxY - y\n\n  let closest = dl\n  let side: RectSide = \"left\"\n\n  if (dr < closest) {\n    closest = dr\n    side = \"right\"\n  }\n  if (dt < closest) {\n    closest = dt\n    side = \"top\"\n  }\n  if (db < closest) {\n    side = \"bottom\"\n  }\n\n  return side\n}\n", "import type { RectInit } from \"./types\"\n\n// given a rect and a boundary, return a new rect that is constrained within the boundary\n// resize or reposition the rect so that it fits within the boundary\nexport const constrainRect = (rect: RectInit, boundary: RectInit): RectInit => {\n  const left = Math.max(boundary.x, Math.min(rect.x, boundary.x + boundary.width - rect.width))\n  const top = Math.max(boundary.y, Math.min(rect.y, boundary.y + boundary.height - rect.height))\n\n  return {\n    x: left,\n    y: top,\n    width: Math.min(rect.width, boundary.width),\n    height: Math.min(rect.height, boundary.height),\n  }\n}\n", "import { getRectCorners, isRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function containsPoint(r: Rect, p: Point): boolean {\n  return r.minX <= p.x && p.x <= r.maxX && r.minY <= p.y && p.y <= r.maxY\n}\n\nexport function containsRect(a: Rect, b: Rect): boolean {\n  return Object.values(getRectCorners(b)).every((c) => containsPoint(a, c))\n}\n\nexport function contains(r: Rect, v: Rect | Point): boolean {\n  return isRect(v) ? containsRect(r, v) : containsPoint(r, v)\n}\n", "import type { Point, RectInit, Size } from \"./types\"\n\nexport const isSizeEqual = (a: Size, b: Size) => {\n  return a.width === b.width && a.height === b.height\n}\n\nexport const isPointEqual = (a: Point, b: Point) => {\n  return a.x === b.x && a.y === b.y\n}\n\nexport const isRectEqual = (a: RectInit, b: RectInit) => {\n  return isPointEqual(a, b) && isSizeEqual(a, b)\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nconst styleCache = new WeakMap<HTMLElement, any>()\n\nfunction getCacheComputedStyle(el: HTMLElement) {\n  if (!styleCache.has(el)) {\n    const win = el.ownerDocument.defaultView || window\n    styleCache.set(el, win.getComputedStyle(el))\n  }\n  return styleCache.get(el)\n}\n\nexport function getElementRect(el: HTMLElement, opts: ElementRectOptions = {}): Rect {\n  return createRect(getClientRect(el, opts))\n}\n\nexport type ElementRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n  /**\n   * Whether to exclude the element's borders from the calculation.\n   */\n  excludeBorders?: boolean\n}\n\nfunction getClientRect(el: HTMLElement, opts: ElementRectOptions = {}) {\n  const { excludeScrollbar = false, excludeBorders = false } = opts\n\n  const { x, y, width, height } = el.getBoundingClientRect()\n  const r = { x, y, width, height }\n\n  const style = getCacheComputedStyle(el)\n\n  const { borderLeftWidth, borderTopWidth, borderRightWidth, borderBottomWidth } = style\n\n  const borderXWidth = sum(borderLeftWidth, borderRightWidth)\n  const borderYWidth = sum(borderTopWidth, borderBottomWidth)\n\n  if (excludeBorders) {\n    r.width -= borderXWidth\n    r.height -= borderYWidth\n    r.x += px(borderLeftWidth)\n    r.y += px(borderTopWidth)\n  }\n\n  if (excludeScrollbar) {\n    const scrollbarWidth = el.offsetWidth - el.clientWidth - borderXWidth\n    const scrollbarHeight = el.offsetHeight - el.clientHeight - borderYWidth\n    r.width -= scrollbarWidth\n    r.height -= scrollbarHeight\n  }\n\n  return r\n}\n\nconst px = (v: string) => parseFloat(v.replace(\"px\", \"\"))\n\nconst sum = (...vals: string[]) => vals.reduce((sum, v) => sum + (v ? px(v) : 0), 0)\n", "import { createRect } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function getRectFromPoints(...pts: Point[]): Rect {\n  const xs = pts.map((p) => p.x)\n  const ys = pts.map((p) => p.y)\n\n  const x = Math.min(...xs)\n  const y = Math.min(...ys)\n\n  const width = Math.max(...xs) - x\n  const height = Math.max(...ys) - y\n\n  return createRect({ x, y, width, height })\n}\n", "import { getRectFromPoints } from \"./from-points\"\nimport type { Rect } from \"./types\"\n\nconst { min, max } = Math\n\nexport function union(...rs: Rect[]): Rect {\n  const pMin = {\n    x: min(...rs.map((r) => r.minX)),\n    y: min(...rs.map((r) => r.minY)),\n  }\n  const pMax = {\n    x: max(...rs.map((r) => r.maxX)),\n    y: max(...rs.map((r) => r.maxY)),\n  }\n  return getRectFromPoints(pMin, pMax)\n}\n", "import { createRect } from \"./rect\"\nimport { getElementRect } from \"./from-element\"\nimport { union } from \"./union\"\nimport type { Rect } from \"./types\"\n\nexport function fromRange(range: Range): Rect {\n  let rs: Rect[] = []\n  const rects = Array.from(range.getClientRects())\n\n  if (rects.length) {\n    rs = rs.concat(rects.map(createRect))\n    return union.apply(undefined, rs)\n  }\n\n  let start: Node | ParentNode | null = range.startContainer\n\n  if (start.nodeType === Node.TEXT_NODE) {\n    start = start.parentNode\n  }\n\n  if (start instanceof HTMLElement) {\n    const r = getElementRect(start)\n    rs.push({ ...r, x: r.maxX, width: 0 })\n  }\n\n  return union.apply(undefined, rs)\n}\n", "import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, Rect } from \"./types\"\n\nexport function toRad(d: number) {\n  return ((d % 360) * Math.PI) / 180\n}\n\nexport function rotate(a: Point, d: number, c: Point): Point {\n  const r = toRad(d)\n\n  const sin = Math.sin(r)\n  const cos = Math.cos(r)\n\n  const x = a.x - c.x\n  const y = a.y - c.y\n\n  return {\n    x: c.x + x * cos - y * sin,\n    y: c.y + x * sin + y * cos,\n  }\n}\n\nexport function getRotationRect(r: Rect, deg: number): Rect {\n  const rr = Object.values(getRectCorners(r)).map((p) => rotate(p, deg, r.center))\n\n  const xs = rr.map((p) => p.x)\n  const ys = rr.map((p) => p.y)\n\n  const minX = Math.min(...xs)\n  const minY = Math.min(...ys)\n\n  const maxX = Math.max(...xs)\n  const maxY = Math.max(...ys)\n\n  return createRect({\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  })\n}\n", "import { createRect } from \"./rect\"\nimport type { Rect } from \"./types\"\n\nexport type WindowRectOptions = {\n  /**\n   * Whether to exclude the element's scrollbar size from the calculation.\n   */\n  excludeScrollbar?: boolean\n}\n\n/**\n * Creates a rectange from window object\n */\nexport function getWindowRect(win: Window, opts: WindowRectOptions = {}): Rect {\n  return createRect(getViewportRect(win, opts))\n}\n\n/**\n * Get the rect of the window with the option to exclude the scrollbar\n */\nexport function getViewportRect(win: Window, opts: WindowRectOptions) {\n  const { excludeScrollbar = false } = opts\n  const { innerWidth, innerHeight, document: doc, visualViewport } = win\n  const width = visualViewport?.width || innerWidth\n  const height = visualViewport?.height || innerHeight\n  const rect = { x: 0, y: 0, width, height }\n  if (excludeScrollbar) {\n    const scrollbarWidth = innerWidth - doc.documentElement.clientWidth\n    const scrollbarHeight = innerHeight - doc.documentElement.clientHeight\n    rect.width -= scrollbarWidth\n    rect.height -= scrollbarHeight\n  }\n  return rect\n}\n", "import { createRect } from \"./rect\"\nimport type { Point, Rect, RectInset, SymmetricRectInset } from \"./types\"\n\nexport const isSymmetric = (v: any): v is SymmetricRectInset => \"dx\" in v || \"dy\" in v\n\nexport function inset(r: Rect, i: RectInset | SymmetricRectInset): Rect {\n  const v = isSymmetric(i) ? { left: i.dx, right: i.dx, top: i.dy, bottom: i.dy } : i\n  const { top = 0, right = 0, bottom = 0, left = 0 } = v\n  return createRect({\n    x: r.x + left,\n    y: r.y + top,\n    width: r.width - left - right,\n    height: r.height - top - bottom,\n  })\n}\n\nexport function expand(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shrink(r: Rect, v: number | SymmetricRectInset): Rect {\n  const value = typeof v === \"number\" ? { dx: -v, dy: -v } : v\n  return inset(r, value)\n}\n\nexport function shift(r: Rect, o: Partial<Point>): Rect {\n  const { x = 0, y = 0 } = o\n  return createRect({\n    x: r.x + x,\n    y: r.y + y,\n    width: r.width,\n    height: r.height,\n  })\n}\n", "import { createRect, getRectCorners } from \"./rect\"\nimport type { Point, RectInit } from \"./types\"\n\nexport function getElementPolygon(rectValue: RectInit, placement: string) {\n  const rect = createRect(rectValue)\n  const { top, right, left, bottom } = getRectCorners(rect)\n  const [base] = placement.split(\"-\")\n\n  return {\n    top: [left, top, right, bottom],\n    right: [top, right, bottom, left],\n    bottom: [top, left, bottom, right],\n    left: [right, top, left, bottom],\n  }[base]\n}\n\nexport function isPointInPolygon(polygon: Point[], point: Point) {\n  const { x, y } = point\n  let c = false\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x\n    const yi = polygon[i].y\n    const xj = polygon[j].x\n    const yj = polygon[j].y\n\n    if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n      c = !c\n    }\n  }\n  return c\n}\n\nfunction createPolygonElement() {\n  const id = \"debug-polygon\"\n  const existingPolygon = document.getElementById(id)\n  if (existingPolygon) {\n    return existingPolygon\n  }\n  const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  Object.assign(svg.style, {\n    top: \"0\",\n    left: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    opacity: \"0.15\",\n    position: \"fixed\",\n    pointerEvents: \"none\",\n    fill: \"red\",\n  })\n\n  const polygon = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\")\n  polygon.setAttribute(\"id\", id)\n  polygon.setAttribute(\"points\", \"0,0 0,0\")\n  svg.appendChild(polygon)\n  document.body.appendChild(svg)\n  return polygon\n}\n\nexport function debugPolygon(polygon: Point[]) {\n  const el = createPolygonElement()\n  const points = polygon.map((point) => `${point.x},${point.y}`).join(\" \")\n  el.setAttribute(\"points\", points)\n  return () => {\n    el.remove()\n  }\n}\n", "import type { Point } from \"./types\"\n\nexport type CompassDirection = \"n\" | \"ne\" | \"e\" | \"se\" | \"s\" | \"sw\" | \"w\" | \"nw\"\n\nexport const compassDirectionMap: Record<CompassDirection, Point> = {\n  n: { x: 0.5, y: 0 },\n  ne: { x: 1, y: 0 },\n  e: { x: 1, y: 0.5 },\n  se: { x: 1, y: 1 },\n  s: { x: 0.5, y: 1 },\n  sw: { x: 0, y: 1 },\n  w: { x: 0, y: 0.5 },\n  nw: { x: 0, y: 0 },\n}\n\nexport const oppositeDirectionMap: Record<CompassDirection, CompassDirection> = {\n  n: \"s\",\n  ne: \"sw\",\n  e: \"w\",\n  se: \"nw\",\n  s: \"n\",\n  sw: \"ne\",\n  w: \"e\",\n  nw: \"se\",\n}\n", "import { AffineTransform } from \"./affine-transform\"\nimport { compassDirectionMap, oppositeDirectionMap, type CompassDirection } from \"./compass\"\nimport type { Point, Rect, RectInit, ScalingOptions } from \"./types\"\n\nconst { sign, abs, min } = Math\n\nfunction getRectExtentPoint(rect: Rect, direction: CompassDirection) {\n  const { minX, minY, maxX, maxY, midX, midY } = rect\n  const x = direction.includes(\"w\") ? minX : direction.includes(\"e\") ? maxX : midX\n  const y = direction.includes(\"n\") ? minY : direction.includes(\"s\") ? maxY : midY\n  return { x, y }\n}\n\nfunction getOppositeDirection(direction: CompassDirection) {\n  return oppositeDirectionMap[direction]\n}\n\nexport function resizeRect(rect: Rect, offset: Point, direction: CompassDirection, opts: ScalingOptions) {\n  const { scalingOriginMode, lockAspectRatio } = opts\n\n  const extent = getRectExtentPoint(rect, direction)\n\n  const oppositeDirection = getOppositeDirection(direction)\n  const oppositeExtent = getRectExtentPoint(rect, oppositeDirection)\n\n  if (scalingOriginMode === \"center\") {\n    offset = { x: offset.x * 2, y: offset.y * 2 }\n  }\n\n  const newExtent = {\n    x: extent.x + offset.x,\n    y: extent.y + offset.y,\n  }\n\n  const multiplier = {\n    x: compassDirectionMap[direction].x * 2 - 1,\n    y: compassDirectionMap[direction].y * 2 - 1,\n  }\n\n  const newSize = {\n    width: newExtent.x - oppositeExtent.x,\n    height: newExtent.y - oppositeExtent.y,\n  }\n\n  const scaleX = (multiplier.x * newSize.width) / rect.width\n  const scaleY = (multiplier.y * newSize.height) / rect.height\n\n  const largestMagnitude = abs(scaleX) > abs(scaleY) ? scaleX : scaleY\n\n  const scale = lockAspectRatio\n    ? { x: largestMagnitude, y: largestMagnitude }\n    : {\n        x: extent.x === oppositeExtent.x ? 1 : scaleX,\n        y: extent.y === oppositeExtent.y ? 1 : scaleY,\n      }\n\n  if (extent.y === oppositeExtent.y) {\n    scale.y = abs(scale.y)\n  } else if (sign(scale.y) !== sign(scaleY)) {\n    scale.y *= -1\n  }\n\n  if (extent.x === oppositeExtent.x) {\n    scale.x = abs(scale.x)\n  } else if (sign(scale.x) !== sign(scaleX)) {\n    scale.x *= -1\n  }\n\n  switch (scalingOriginMode) {\n    case \"extent\":\n      return transformRect(rect, AffineTransform.scale(scale.x, scale.y, oppositeExtent), false)\n    case \"center\":\n      return transformRect(\n        rect,\n        AffineTransform.scale(scale.x, scale.y, {\n          x: rect.midX,\n          y: rect.midY,\n        }),\n        false,\n      )\n  }\n}\n\nfunction createRectFromPoints(initialPoint: Point, finalPoint: Point, normalized: boolean = true): RectInit {\n  if (normalized) {\n    return {\n      x: min(finalPoint.x, initialPoint.x),\n      y: min(finalPoint.y, initialPoint.y),\n      width: abs(finalPoint.x - initialPoint.x),\n      height: abs(finalPoint.y - initialPoint.y),\n    }\n  }\n\n  return {\n    x: initialPoint.x,\n    y: initialPoint.y,\n    width: finalPoint.x - initialPoint.x,\n    height: finalPoint.y - initialPoint.y,\n  }\n}\n\nfunction transformRect(rect: Rect, transform: AffineTransform, normalized = true): RectInit {\n  const p1 = transform.applyTo({ x: rect.minX, y: rect.minY })\n  const p2 = transform.applyTo({ x: rect.maxX, y: rect.maxY })\n  return createRectFromPoints(p1, p2, normalized)\n}\n", "import { createAnatomy } from \"@zag-js/anatomy\"\n\nexport const anatomy = createAnatomy(\"menu\").parts(\n  \"arrow\",\n  \"arrowTip\",\n  \"content\",\n  \"contextTrigger\",\n  \"indicator\",\n  \"item\",\n  \"itemGroup\",\n  \"itemGroupLabel\",\n  \"itemIndicator\",\n  \"itemText\",\n  \"positioner\",\n  \"separator\",\n  \"trigger\",\n  \"triggerItem\",\n)\nexport const parts = anatomy.build()\n", "import { mergeProps } from \"@zag-js/core\"\nimport {\n  clickIfLink,\n  getEventKey,\n  getEventPoint,\n  getNativeEvent,\n  isContextMenuEvent,\n  isLeftClick,\n  isModifierKey,\n  isPrintableKey,\n  type EventKeyMap,\n} from \"@zag-js/dom-event\"\nimport {\n  dataAttr,\n  getEventTarget,\n  isDownloadingEvent,\n  isEditableElement,\n  isOpeningInNewTab,\n  isSelfTarget,\n  isValidTabEvent,\n} from \"@zag-js/dom-query\"\nimport { getPlacementStyles } from \"@zag-js/popper\"\nimport type { NormalizeProps, PropTypes } from \"@zag-js/types\"\nimport { parts } from \"./menu.anatomy\"\nimport { dom } from \"./menu.dom\"\nimport type { ItemProps, ItemState, MachineApi, OptionItemProps, OptionItemState, Send, State } from \"./menu.types\"\n\nexport function connect<T extends PropTypes>(state: State, send: Send, normalize: NormalizeProps<T>): MachineApi<T> {\n  const isSubmenu = state.context.isSubmenu\n  const isTypingAhead = state.context.isTypingAhead\n  const composite = state.context.composite\n\n  const open = state.hasTag(\"open\")\n\n  const popperStyles = getPlacementStyles({\n    ...state.context.positioning,\n    placement: state.context.anchorPoint ? \"bottom\" : state.context.currentPlacement,\n  })\n\n  function getItemState(props: ItemProps): ItemState {\n    return {\n      disabled: !!props.disabled,\n      highlighted: state.context.highlightedValue === props.value,\n    }\n  }\n\n  function getOptionItemProps(props: OptionItemProps) {\n    const valueText = props.valueText ?? props.value\n    return { ...props, id: props.value, valueText }\n  }\n\n  function getOptionItemState(props: OptionItemProps): OptionItemState {\n    const itemState = getItemState(getOptionItemProps(props))\n    return {\n      ...itemState,\n      checked: !!props.checked,\n    }\n  }\n\n  function getItemProps(props: ItemProps) {\n    const { value: id, closeOnSelect, valueText } = props\n    const itemState = getItemState(props)\n    return normalize.element({\n      ...parts.item.attrs,\n      id,\n      role: \"menuitem\",\n      \"aria-disabled\": itemState.disabled,\n      \"data-disabled\": dataAttr(itemState.disabled),\n      \"data-ownedby\": dom.getContentId(state.context),\n      \"data-highlighted\": dataAttr(itemState.highlighted),\n      \"data-valuetext\": valueText,\n      onDragStart(event) {\n        const isLink = event.currentTarget.matches(\"a[href]\")\n        if (isLink) event.preventDefault()\n      },\n      onPointerMove(event) {\n        if (itemState.disabled) return\n        if (event.pointerType !== \"mouse\") return\n        const target = event.currentTarget\n        if (itemState.highlighted) return\n        send({ type: \"ITEM_POINTERMOVE\", id, target, closeOnSelect })\n      },\n      onPointerLeave(event) {\n        if (itemState.disabled) return\n        if (event.pointerType !== \"mouse\") return\n\n        const mouseMoved = state.previousEvent.type.includes(\"POINTER\")\n        if (!mouseMoved) return\n\n        const target = event.currentTarget\n        send({ type: \"ITEM_POINTERLEAVE\", id, target, closeOnSelect })\n      },\n      onPointerDown(event) {\n        if (itemState.disabled) return\n        const target = event.currentTarget\n        send({ type: \"ITEM_POINTERDOWN\", target, id, closeOnSelect })\n      },\n      onPointerUp(event) {\n        if (isDownloadingEvent(event)) return\n        if (isOpeningInNewTab(event)) return\n        if (itemState.disabled) return\n        if (!isLeftClick(event)) return\n\n        const target = event.currentTarget\n        send({ type: \"ITEM_CLICK\", src: \"pointerup\", target, id, closeOnSelect })\n\n        // Fix issue where links don't get clicked in pointerup on touch devices\n        if (event.pointerType === \"touch\") clickIfLink(target)\n      },\n      onTouchEnd(event) {\n        // prevent clicking elements behind content\n        event.preventDefault()\n        event.stopPropagation()\n      },\n    })\n  }\n\n  return {\n    highlightedValue: state.context.highlightedValue,\n    open: open,\n    setOpen(nextOpen) {\n      if (nextOpen === open) return\n      send(nextOpen ? \"OPEN\" : \"CLOSE\")\n    },\n    setHighlightedValue(value) {\n      send({ type: \"HIGHLIGHTED.SET\", id: value })\n    },\n    setParent(parent) {\n      send({ type: \"PARENT.SET\", value: parent, id: parent.state.context.id })\n    },\n    setChild(child) {\n      send({ type: \"CHILD.SET\", value: child, id: child.state.context.id })\n    },\n    reposition(options = {}) {\n      send({ type: \"POSITIONING.SET\", options })\n    },\n\n    contextTriggerProps: normalize.element({\n      ...parts.contextTrigger.attrs,\n      dir: state.context.dir,\n      id: dom.getContextTriggerId(state.context),\n      onPointerDown(event) {\n        if (event.pointerType === \"mouse\") return\n        const evt = getNativeEvent(event)\n        const point = getEventPoint(evt)\n        send({ type: \"CONTEXT_MENU_START\", point })\n      },\n      onPointerCancel(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onPointerMove(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onPointerUp(event) {\n        if (event.pointerType === \"mouse\") return\n        send(\"CONTEXT_MENU_CANCEL\")\n      },\n      onContextMenu(event) {\n        const evt = getNativeEvent(event)\n        const point = getEventPoint(evt)\n        send({ type: \"CONTEXT_MENU\", point })\n        event.preventDefault()\n      },\n      style: {\n        WebkitTouchCallout: \"none\",\n        userSelect: \"none\",\n      },\n    }),\n\n    getTriggerItemProps(childApi) {\n      return mergeProps(getItemProps({ value: childApi.triggerProps.id }), childApi.triggerProps) as T[\"element\"]\n    },\n\n    triggerProps: normalize.button({\n      ...(isSubmenu ? parts.triggerItem.attrs : parts.trigger.attrs),\n      \"data-placement\": state.context.currentPlacement,\n      type: \"button\",\n      dir: state.context.dir,\n      id: dom.getTriggerId(state.context),\n      \"data-uid\": state.context.id,\n      \"aria-haspopup\": composite ? \"menu\" : \"dialog\",\n      \"aria-controls\": dom.getContentId(state.context),\n      \"aria-expanded\": open || undefined,\n      \"data-state\": open ? \"open\" : \"closed\",\n      onPointerMove(event) {\n        if (event.pointerType !== \"mouse\") return\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        if (disabled || !isSubmenu) return\n        send({ type: \"TRIGGER_POINTERMOVE\", target: event.currentTarget })\n      },\n      onPointerLeave(event) {\n        if (event.pointerType !== \"mouse\") return\n        const evt = getNativeEvent(event)\n\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        if (disabled || !isSubmenu) return\n\n        const point = getEventPoint(evt)\n        send({ type: \"TRIGGER_POINTERLEAVE\", target: event.currentTarget, point })\n      },\n      onClick(event) {\n        if (dom.isTriggerItem(event.currentTarget)) {\n          send({ type: \"TRIGGER_CLICK\", target: event.currentTarget })\n        }\n      },\n      onPointerDown(event) {\n        const disabled = dom.isTargetDisabled(event.currentTarget)\n        const evt = getNativeEvent(event)\n        if (!isLeftClick(evt) || disabled || isContextMenuEvent(event)) return\n        event.preventDefault()\n        if (!dom.isTriggerItem(event.currentTarget)) {\n          send({ type: \"TRIGGER_CLICK\", target: event.currentTarget })\n        }\n      },\n      onBlur() {\n        send(\"TRIGGER_BLUR\")\n      },\n      onFocus() {\n        send(\"TRIGGER_FOCUS\")\n      },\n      onKeyDown(event) {\n        if (event.defaultPrevented) return\n        const keyMap: EventKeyMap = {\n          ArrowDown() {\n            send(\"ARROW_DOWN\")\n          },\n          ArrowUp() {\n            send(\"ARROW_UP\")\n          },\n          Enter() {\n            send({ type: \"ARROW_DOWN\", src: \"enter\" })\n          },\n          Space() {\n            send({ type: \"ARROW_DOWN\", src: \"space\" })\n          },\n        }\n\n        const key = getEventKey(event, state.context)\n        const exec = keyMap[key]\n\n        if (exec) {\n          event.preventDefault()\n          exec(event)\n        }\n      },\n    }),\n\n    indicatorProps: normalize.element({\n      ...parts.indicator.attrs,\n      dir: state.context.dir,\n      \"data-state\": open ? \"open\" : \"closed\",\n    }),\n\n    positionerProps: normalize.element({\n      ...parts.positioner.attrs,\n      dir: state.context.dir,\n      id: dom.getPositionerId(state.context),\n      style: popperStyles.floating,\n    }),\n\n    arrowProps: normalize.element({\n      id: dom.getArrowId(state.context),\n      ...parts.arrow.attrs,\n      dir: state.context.dir,\n      style: popperStyles.arrow,\n    }),\n\n    arrowTipProps: normalize.element({\n      ...parts.arrowTip.attrs,\n      dir: state.context.dir,\n      style: popperStyles.arrowTip,\n    }),\n\n    contentProps: normalize.element({\n      ...parts.content.attrs,\n      id: dom.getContentId(state.context),\n      \"aria-label\": state.context[\"aria-label\"],\n      hidden: !open,\n      \"data-state\": open ? \"open\" : \"closed\",\n      role: composite ? \"menu\" : \"dialog\",\n      tabIndex: 0,\n      dir: state.context.dir,\n      \"aria-activedescendant\": state.context.highlightedValue ?? undefined,\n      \"aria-labelledby\": dom.getTriggerId(state.context),\n      \"data-placement\": state.context.currentPlacement,\n      onPointerEnter(event) {\n        if (event.pointerType !== \"mouse\") return\n        send(\"MENU_POINTERENTER\")\n      },\n      onKeyDown(event) {\n        if (event.defaultPrevented) return\n\n        const evt = getNativeEvent(event)\n        if (!isSelfTarget(evt)) return\n\n        const target = getEventTarget<Element>(evt)\n        const sameMenu = target?.closest(\"[role=menu]\") === event.currentTarget || target === event.currentTarget\n        if (!sameMenu) return\n\n        if (event.key === \"Tab\") {\n          const valid = isValidTabEvent(event)\n          if (!valid) {\n            event.preventDefault()\n            return\n          }\n        }\n\n        const item = dom.getHighlightedItemEl(state.context)\n        const keyMap: EventKeyMap = {\n          ArrowDown() {\n            send(\"ARROW_DOWN\")\n          },\n          ArrowUp() {\n            send(\"ARROW_UP\")\n          },\n          ArrowLeft() {\n            send(\"ARROW_LEFT\")\n          },\n          ArrowRight() {\n            send(\"ARROW_RIGHT\")\n          },\n          Enter() {\n            send(\"ENTER\")\n            clickIfLink(item)\n          },\n          Space(event) {\n            if (isTypingAhead) {\n              send({ type: \"TYPEAHEAD\", key: event.key })\n            } else {\n              keyMap.Enter?.(event)\n            }\n          },\n          Home() {\n            send(\"HOME\")\n          },\n          End() {\n            send(\"END\")\n          },\n        }\n\n        const key = getEventKey(event, { dir: state.context.dir })\n        const exec = keyMap[key]\n\n        if (exec) {\n          exec(event)\n          event.stopPropagation()\n          event.preventDefault()\n          return\n        }\n\n        // typeahead\n        if (!state.context.typeahead) return\n        if (!isPrintableKey(event)) return\n        if (isModifierKey(event)) return\n        if (isEditableElement(target)) return\n\n        send({ type: \"TYPEAHEAD\", key: event.key })\n        event.preventDefault()\n      },\n    }),\n\n    separatorProps: normalize.element({\n      ...parts.separator.attrs,\n      role: \"separator\",\n      dir: state.context.dir,\n      \"aria-orientation\": \"horizontal\",\n    }),\n    getItemState,\n    getItemProps,\n\n    getOptionItemState,\n    getOptionItemProps(props) {\n      const { type, disabled, onCheckedChange, closeOnSelect } = props\n\n      const option = getOptionItemProps(props)\n      const itemState = getOptionItemState(props)\n\n      return {\n        ...getItemProps(option),\n        ...normalize.element({\n          \"data-type\": type,\n          ...parts.item.attrs,\n          dir: state.context.dir,\n          \"data-value\": option.value,\n          role: `menuitem${type}`,\n          \"aria-checked\": !!itemState.checked,\n          \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n          onPointerUp(event) {\n            if (!isLeftClick(event) || disabled) return\n            if (isDownloadingEvent(event)) return\n            if (isOpeningInNewTab(event)) return\n            const target = event.currentTarget\n            send({ type: \"ITEM_CLICK\", src: \"pointerup\", target, option, closeOnSelect })\n            onCheckedChange?.(!itemState.checked)\n          },\n        }),\n      }\n    },\n\n    getItemIndicatorProps(props) {\n      const itemState = getOptionItemState(props)\n      return normalize.element({\n        ...parts.itemIndicator.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n        hidden: !itemState.checked,\n      })\n    },\n\n    getItemTextProps(props) {\n      const itemState = getOptionItemState(props)\n      return normalize.element({\n        ...parts.itemText.attrs,\n        dir: state.context.dir,\n        \"data-disabled\": dataAttr(itemState.disabled),\n        \"data-highlighted\": dataAttr(itemState.highlighted),\n        \"data-state\": itemState.checked ? \"checked\" : \"unchecked\",\n      })\n    },\n\n    getItemGroupLabelProps(props) {\n      return normalize.element({\n        id: dom.getGroupLabelId(state.context, props.htmlFor),\n        dir: state.context.dir,\n        ...parts.itemGroupLabel.attrs,\n      })\n    },\n\n    getItemGroupProps(props) {\n      return normalize.element({\n        id: dom.getGroupId(state.context, props.id),\n        ...parts.itemGroup.attrs,\n        dir: state.context.dir,\n        \"aria-labelledby\": dom.getGroupLabelId(state.context, props.id),\n        role: \"group\",\n      })\n    },\n  }\n}\n", "import { isHTMLElement, nextById, prevById, queryAll, getByTypeahead, createScope } from \"@zag-js/dom-query\"\nimport { first, last } from \"@zag-js/utils\"\nimport type { MachineContext as Ctx } from \"./menu.types\"\n\nexport const dom = createScope({\n  getTriggerId: (ctx: Ctx) => ctx.ids?.trigger ?? `menu:${ctx.id}:trigger`,\n  getContextTriggerId: (ctx: Ctx) => ctx.ids?.contextTrigger ?? `menu:${ctx.id}:ctx-trigger`,\n  getContentId: (ctx: Ctx) => ctx.ids?.content ?? `menu:${ctx.id}:content`,\n  getArrowId: (ctx: Ctx) => ctx.ids?.arrow ?? `menu:${ctx.id}:arrow`,\n  getPositionerId: (ctx: Ctx) => ctx.ids?.positioner ?? `menu:${ctx.id}:popper`,\n  getGroupId: (ctx: Ctx, id: string) => ctx.ids?.group?.(id) ?? `menu:${ctx.id}:group:${id}`,\n  getGroupLabelId: (ctx: Ctx, id: string) => ctx.ids?.label?.(id) ?? `menu:${ctx.id}:label:${id}`,\n\n  getContentEl: (ctx: Ctx) => dom.getById(ctx, dom.getContentId(ctx)),\n  getPositionerEl: (ctx: Ctx) => dom.getById(ctx, dom.getPositionerId(ctx)),\n  getTriggerEl: (ctx: Ctx) => dom.getById(ctx, dom.getTriggerId(ctx)),\n  getHighlightedItemEl: (ctx: Ctx) => (ctx.highlightedValue ? dom.getById(ctx, ctx.highlightedValue) : null),\n  getArrowEl: (ctx: Ctx) => dom.getById(ctx, dom.getArrowId(ctx)),\n\n  getElements: (ctx: Ctx) => {\n    const ownerId = CSS.escape(dom.getContentId(ctx))\n    const selector = `[role^=\"menuitem\"][data-ownedby=${ownerId}]:not([data-disabled])`\n    return queryAll(dom.getContentEl(ctx), selector)\n  },\n  getFirstEl: (ctx: Ctx) => first(dom.getElements(ctx)),\n  getLastEl: (ctx: Ctx) => last(dom.getElements(ctx)),\n  getNextEl: (ctx: Ctx, loop?: boolean) => nextById(dom.getElements(ctx), ctx.highlightedValue!, loop ?? ctx.loopFocus),\n  getPrevEl: (ctx: Ctx, loop?: boolean) => prevById(dom.getElements(ctx), ctx.highlightedValue!, loop ?? ctx.loopFocus),\n\n  getElemByKey: (ctx: Ctx, key: string) =>\n    getByTypeahead(dom.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),\n\n  isTargetDisabled: (v: EventTarget | null) => {\n    return isHTMLElement(v) && (v.dataset.disabled === \"\" || v.hasAttribute(\"disabled\"))\n  },\n  isTriggerItem: (el: HTMLElement | null) => {\n    return !!el?.getAttribute(\"role\")?.startsWith(\"menuitem\") && !!el?.hasAttribute(\"aria-controls\")\n  },\n\n  getOptionFromItemEl(el: HTMLElement) {\n    return {\n      id: el.id,\n      name: el.dataset.name,\n      value: el.dataset.value,\n      valueText: el.dataset.valueText,\n      type: el.dataset.type,\n    }\n  },\n})\n", "import { createMachine, guards, ref } from \"@zag-js/core\"\nimport { trackDismissableElement } from \"@zag-js/dismissable\"\nimport { addDomEvent } from \"@zag-js/dom-event\"\nimport {\n  contains,\n  getByTypeahead,\n  getFirstTabbable,\n  isEditableElement,\n  observeAttributes,\n  raf,\n  scrollIntoView,\n} from \"@zag-js/dom-query\"\nimport { getPlacement, getPlacementSide } from \"@zag-js/popper\"\nimport { getElementPolygon, isPointInPolygon } from \"@zag-js/rect-utils\"\nimport { cast, compact, isEqual } from \"@zag-js/utils\"\nimport { dom } from \"./menu.dom\"\nimport type { MachineContext, MachineState, UserDefinedContext } from \"./menu.types\"\n\nconst { not, and, or } = guards\n\nexport function machine(userContext: UserDefinedContext) {\n  const ctx = compact(userContext)\n  return createMachine<MachineContext, MachineState>(\n    {\n      id: \"menu\",\n      initial: ctx.open ? \"open\" : \"idle\",\n      context: {\n        highlightedValue: null,\n        loopFocus: false,\n        anchorPoint: null,\n        closeOnSelect: true,\n        typeahead: true,\n        composite: true,\n        ...ctx,\n        positioning: {\n          placement: \"bottom-start\",\n          gutter: 8,\n          ...ctx.positioning,\n        },\n        intentPolygon: null,\n        parent: null,\n        lastHighlightedValue: null,\n        children: cast(ref({})),\n        suspendPointer: false,\n        restoreFocus: true,\n        typeaheadState: getByTypeahead.defaultOptions,\n      },\n\n      computed: {\n        isSubmenu: (ctx) => ctx.parent !== null,\n        isRtl: (ctx) => ctx.dir === \"rtl\",\n        isTypingAhead: (ctx) => ctx.typeaheadState.keysSoFar !== \"\",\n      },\n\n      watch: {\n        isSubmenu: \"setSubmenuPlacement\",\n        anchorPoint: \"reposition\",\n        open: \"toggleVisibility\",\n      },\n\n      on: {\n        \"PARENT.SET\": {\n          actions: \"setParentMenu\",\n        },\n        \"CHILD.SET\": {\n          actions: \"setChildMenu\",\n        },\n        OPEN: [\n          {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnOpen\",\n          },\n          {\n            target: \"open\",\n            actions: \"invokeOnOpen\",\n          },\n        ],\n        OPEN_AUTOFOCUS: [\n          {\n            guard: \"isOpenControlled\",\n            actions: [\"invokeOnOpen\"],\n          },\n          {\n            internal: true,\n            target: \"open\",\n            actions: [\"highlightFirstItem\", \"invokeOnOpen\"],\n          },\n        ],\n        CLOSE: [\n          {\n            guard: \"isOpenControlled\",\n            actions: \"invokeOnClose\",\n          },\n          {\n            target: \"closed\",\n            actions: \"invokeOnClose\",\n          },\n        ],\n        \"HIGHLIGHTED.RESTORE\": {\n          actions: \"restoreHighlightedItem\",\n        },\n        \"HIGHLIGHTED.SET\": {\n          actions: \"setHighlightedItem\",\n        },\n      },\n\n      states: {\n        idle: {\n          tags: [\"closed\"],\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            CONTEXT_MENU_START: {\n              target: \"opening:contextmenu\",\n              actions: \"setAnchorPoint\",\n            },\n            CONTEXT_MENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n            TRIGGER_FOCUS: {\n              guard: not(\"isSubmenu\"),\n              target: \"closed\",\n            },\n            TRIGGER_POINTERMOVE: {\n              guard: \"isSubmenu\",\n              target: \"opening\",\n            },\n          },\n        },\n\n        \"opening:contextmenu\": {\n          tags: [\"closed\"],\n          after: {\n            LONG_PRESS_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            CONTEXT_MENU_CANCEL: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n          },\n        },\n\n        opening: {\n          tags: [\"closed\"],\n          after: {\n            SUBMENU_OPEN_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": \"closed\",\n            BLUR: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n            TRIGGER_POINTERLEAVE: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n          },\n        },\n\n        closing: {\n          tags: [\"open\"],\n          activities: [\"trackPointerMove\", \"trackInteractOutside\"],\n          after: {\n            SUBMENU_CLOSE_DELAY: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"invokeOnClose\"],\n              },\n              {\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\", \"invokeOnClose\"],\n              },\n            ],\n          },\n          on: {\n            \"CONTROLLED.OPEN\": \"open\",\n            \"CONTROLLED.CLOSE\": {\n              target: \"closed\",\n              actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\"],\n            },\n            // don't invoke on open here since the menu is still open (we're only keeping it open)\n            MENU_POINTERENTER: {\n              target: \"open\",\n              actions: \"clearIntentPolygon\",\n            },\n            POINTER_MOVED_AWAY_FROM_SUBMENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnClose\",\n              },\n              {\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"restoreParentHiglightedItem\"],\n              },\n            ],\n          },\n        },\n\n        closed: {\n          tags: [\"closed\"],\n          entry: [\"clearHighlightedItem\", \"focusTrigger\", \"clearAnchorPoint\", \"resumePointer\"],\n          on: {\n            \"CONTROLLED.OPEN\": [\n              {\n                guard: or(\"isOpenAutoFocusEvent\", \"isArrowDownEvent\"),\n                target: \"open\",\n                actions: \"highlightFirstItem\",\n              },\n              {\n                guard: \"isArrowUpEvent\",\n                target: \"open\",\n                actions: \"highlightLastItem\",\n              },\n              {\n                target: \"open\",\n              },\n            ],\n            CONTEXT_MENU_START: {\n              target: \"opening:contextmenu\",\n              actions: \"setAnchorPoint\",\n            },\n            CONTEXT_MENU: [\n              {\n                guard: \"isOpenControlled\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n              {\n                target: \"open\",\n                actions: [\"setAnchorPoint\", \"invokeOnOpen\"],\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: \"invokeOnOpen\",\n              },\n            ],\n            TRIGGER_POINTERMOVE: {\n              guard: \"isTriggerItem\",\n              target: \"opening\",\n            },\n            TRIGGER_BLUR: \"idle\",\n            ARROW_DOWN: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: [\"highlightFirstItem\", \"invokeOnOpen\"],\n              },\n            ],\n            ARROW_UP: [\n              {\n                guard: \"isOpenControlled\",\n                actions: \"invokeOnOpen\",\n              },\n              {\n                target: \"open\",\n                actions: [\"highlightLastItem\", \"invokeOnOpen\"],\n              },\n            ],\n          },\n        },\n\n        open: {\n          tags: [\"open\"],\n          activities: [\"trackInteractOutside\", \"trackPositioning\", \"scrollToHighlightedItem\"],\n          entry: [\"focusMenu\", \"resumePointer\"],\n          on: {\n            \"CONTROLLED.CLOSE\": [\n              {\n                target: \"closed\",\n                guard: \"isArrowLeftEvent\",\n                actions: [\"focusParentMenu\"],\n              },\n              {\n                target: \"closed\",\n              },\n            ],\n            TRIGGER_CLICK: [\n              {\n                guard: and(not(\"isTriggerItem\"), \"isOpenControlled\"),\n                actions: \"invokeOnClose\",\n              },\n              {\n                guard: not(\"isTriggerItem\"),\n                target: \"closed\",\n                actions: \"invokeOnClose\",\n              },\n            ],\n            ARROW_UP: {\n              actions: [\"highlightPrevItem\", \"focusMenu\"],\n            },\n            ARROW_DOWN: {\n              actions: [\"highlightNextItem\", \"focusMenu\"],\n            },\n            ARROW_LEFT: [\n              {\n                guard: and(\"isSubmenu\", \"isOpenControlled\"),\n                actions: \"invokeOnClose\",\n              },\n              {\n                guard: \"isSubmenu\",\n                target: \"closed\",\n                actions: [\"focusParentMenu\", \"invokeOnClose\"],\n              },\n            ],\n            HOME: {\n              actions: [\"highlightFirstItem\", \"focusMenu\"],\n            },\n            END: {\n              actions: [\"highlightLastItem\", \"focusMenu\"],\n            },\n            ARROW_RIGHT: {\n              guard: \"isTriggerItemHighlighted\",\n              actions: \"openSubmenu\",\n            },\n            ENTER: [\n              {\n                guard: \"isTriggerItemHighlighted\",\n                actions: \"openSubmenu\",\n              },\n              // == grouped ==\n              {\n                guard: and(\"closeOnSelect\", \"isOpenControlled\"),\n                actions: [\"clickHighlightedItem\", \"invokeOnClose\"],\n              },\n              {\n                guard: \"closeOnSelect\",\n                target: \"closed\",\n                actions: \"clickHighlightedItem\",\n              },\n              //\n              {\n                actions: \"clickHighlightedItem\",\n              },\n            ],\n            ITEM_POINTERMOVE: [\n              {\n                guard: not(\"suspendPointer\"),\n                actions: [\"setHighlightedItem\", \"focusMenu\"],\n              },\n              {\n                actions: \"setLastHighlightedItem\",\n              },\n            ],\n            ITEM_POINTERLEAVE: {\n              guard: and(not(\"suspendPointer\"), not(\"isTriggerItem\")),\n              actions: \"clearHighlightedItem\",\n            },\n            ITEM_CLICK: [\n              // == grouped ==\n              {\n                guard: and(\n                  not(\"isTriggerItemHighlighted\"),\n                  not(\"isHighlightedItemEditable\"),\n                  \"closeOnSelect\",\n                  \"isOpenControlled\",\n                ),\n                actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"],\n              },\n              {\n                guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\"), \"closeOnSelect\"),\n                target: \"closed\",\n                actions: [\"invokeOnSelect\", \"setOptionState\", \"closeRootMenu\", \"invokeOnClose\"],\n              },\n              //\n              {\n                guard: and(not(\"isTriggerItemHighlighted\"), not(\"isHighlightedItemEditable\")),\n                actions: [\"invokeOnSelect\", \"setOptionState\"],\n              },\n              { actions: \"setHighlightedItem\" },\n            ],\n            TRIGGER_POINTERLEAVE: {\n              target: \"closing\",\n              actions: \"setIntentPolygon\",\n            },\n            ITEM_POINTERDOWN: {\n              actions: \"setHighlightedItem\",\n            },\n            TYPEAHEAD: {\n              actions: \"highlightMatchedItem\",\n            },\n            FOCUS_MENU: {\n              actions: \"focusMenu\",\n            },\n            \"POSITIONING.SET\": {\n              actions: \"reposition\",\n            },\n          },\n        },\n      },\n    },\n    {\n      delays: {\n        LONG_PRESS_DELAY: 700,\n        SUBMENU_OPEN_DELAY: 100,\n        SUBMENU_CLOSE_DELAY: 100,\n      },\n\n      guards: {\n        closeOnSelect: (ctx, evt) => !!(evt?.closeOnSelect ?? ctx.closeOnSelect),\n        // whether the trigger is also a menu item\n        isTriggerItem: (_ctx, evt) => dom.isTriggerItem(evt.target),\n        // whether the trigger item is the active item\n        isTriggerItemHighlighted: (ctx, evt) => {\n          const target = (evt.target ?? dom.getHighlightedItemEl(ctx)) as HTMLElement | null\n          return !!target?.hasAttribute(\"aria-controls\")\n        },\n        isSubmenu: (ctx) => ctx.isSubmenu,\n        suspendPointer: (ctx) => ctx.suspendPointer,\n        isHighlightedItemEditable: (ctx) => isEditableElement(dom.getHighlightedItemEl(ctx)),\n        isWithinPolygon: (ctx, evt) => {\n          if (!ctx.intentPolygon) return false\n          return isPointInPolygon(ctx.intentPolygon, evt.point)\n        },\n        // guard assertions (for controlled mode)\n        isOpenControlled: (ctx) => !!ctx[\"open.controlled\"],\n        isArrowLeftEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_LEFT\",\n        isArrowUpEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_UP\",\n        isArrowDownEvent: (_ctx, evt) => evt.previousEvent?.type === \"ARROW_DOWN\",\n        isOpenAutoFocusEvent: (_ctx, evt) => evt.previousEvent?.type === \"OPEN_AUTOFOCUS\",\n      },\n\n      activities: {\n        trackPositioning(ctx) {\n          if (ctx.anchorPoint) return\n          ctx.currentPlacement = ctx.positioning.placement\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          return getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            defer: true,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n          })\n        },\n        trackInteractOutside(ctx, _evt, { send }) {\n          const getContentEl = () => dom.getContentEl(ctx)\n          return trackDismissableElement(getContentEl, {\n            defer: true,\n            exclude: [dom.getTriggerEl(ctx)],\n            onInteractOutside: ctx.onInteractOutside,\n            onFocusOutside: ctx.onFocusOutside,\n            onEscapeKeyDown(event) {\n              ctx.onEscapeKeyDown?.(event)\n              if (ctx.isSubmenu) event.preventDefault()\n              closeRootMenu(ctx)\n            },\n            onPointerDownOutside(event) {\n              ctx.restoreFocus = !event.detail.focusable\n              ctx.onPointerDownOutside?.(event)\n            },\n            onDismiss() {\n              send({ type: \"CLOSE\", src: \"interact-outside\" })\n            },\n          })\n        },\n        trackPointerMove(ctx, _evt, { guards, send }) {\n          const { isWithinPolygon } = guards\n\n          // NOTE: we're mutating parent context here. sending events to parent doesn't work\n          ctx.parent!.state.context.suspendPointer = true\n\n          const doc = dom.getDoc(ctx)\n\n          return addDomEvent(doc, \"pointermove\", (e) => {\n            const point = { x: e.clientX, y: e.clientY }\n\n            const isMovingToSubmenu = isWithinPolygon(ctx, { point })\n\n            if (!isMovingToSubmenu) {\n              send(\"POINTER_MOVED_AWAY_FROM_SUBMENU\")\n              // NOTE: we're mutating parent context here. sending events to parent doesn't work\n              ctx.parent!.state.context.suspendPointer = false\n            }\n          })\n        },\n        scrollToHighlightedItem(ctx, _evt, { getState }) {\n          const exec = () => {\n            const state = getState()\n\n            if (state.event.type.startsWith(\"ITEM_POINTER\")) return\n\n            const itemEl = dom.getHighlightedItemEl(ctx)\n            const contentEl = dom.getContentEl(ctx)\n\n            scrollIntoView(itemEl, { rootEl: contentEl, block: \"nearest\" })\n          }\n          raf(() => exec())\n\n          const contentEl = () => dom.getContentEl(ctx)\n          return observeAttributes(contentEl, {\n            defer: true,\n            attributes: [\"aria-activedescendant\"],\n            callback: exec,\n          })\n        },\n      },\n\n      actions: {\n        setAnchorPoint(ctx, evt) {\n          ctx.anchorPoint = evt.point\n        },\n        clearAnchorPoint(ctx) {\n          ctx.anchorPoint = null\n        },\n        setSubmenuPlacement(ctx) {\n          if (!ctx.isSubmenu) return\n          ctx.positioning.placement = ctx.isRtl ? \"left-start\" : \"right-start\"\n          ctx.positioning.gutter = 0\n        },\n        reposition(ctx, evt) {\n          const getPositionerEl = () => dom.getPositionerEl(ctx)\n          const getAnchorRect = ctx.anchorPoint ? () => ({ width: 0, height: 0, ...ctx.anchorPoint }) : undefined\n          getPlacement(dom.getTriggerEl(ctx), getPositionerEl, {\n            ...ctx.positioning,\n            getAnchorRect,\n            ...(evt.options ?? {}),\n            listeners: false,\n            onComplete(data) {\n              ctx.currentPlacement = data.placement\n            },\n          })\n        },\n        setOptionState(_ctx, evt) {\n          if (!evt.option) return\n          const { checked, onCheckedChange, type } = evt.option\n\n          if (type === \"radio\") {\n            onCheckedChange?.(true)\n          } else if (type === \"checkbox\") {\n            onCheckedChange?.(!checked)\n          }\n        },\n        clickHighlightedItem(ctx, _evt, { send }) {\n          const itemEl = dom.getHighlightedItemEl(ctx)\n          if (!itemEl || itemEl.dataset.disabled) return\n          const option = dom.getOptionFromItemEl(itemEl)\n          send({\n            type: \"ITEM_CLICK\",\n            src: \"enter\",\n            target: itemEl,\n            id: option.id,\n            option,\n            closeOnSelect: ctx.closeOnSelect,\n          })\n        },\n        setIntentPolygon(ctx, evt) {\n          const menu = dom.getContentEl(ctx)\n          const placement = ctx.currentPlacement\n\n          if (!menu || !placement) return\n\n          const rect = menu.getBoundingClientRect()\n          const polygon = getElementPolygon(rect, placement)\n          if (!polygon) return\n\n          const rightSide = getPlacementSide(placement) === \"right\"\n          const bleed = rightSide ? -5 : +5\n\n          ctx.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon]\n        },\n        clearIntentPolygon(ctx) {\n          ctx.intentPolygon = null\n        },\n        resumePointer(ctx) {\n          if (!ctx.parent) return\n          ctx.parent.state.context.suspendPointer = false\n        },\n        setHighlightedItem(ctx, evt) {\n          set.highlighted(ctx, evt.id)\n        },\n        clearHighlightedItem(ctx) {\n          set.highlighted(ctx, null)\n        },\n        focusMenu(ctx) {\n          raf(() => {\n            const contentEl = dom.getContentEl(ctx)\n            if (contains(contentEl, dom.getActiveElement(ctx))) return\n            const firstFocusableEl = getFirstTabbable(contentEl, false) || contentEl\n            firstFocusableEl?.focus({ preventScroll: true })\n          })\n        },\n        highlightFirstItem(ctx) {\n          const first = dom.getFirstEl(ctx)\n          if (!first) return\n          set.highlighted(ctx, first.id)\n        },\n        highlightLastItem(ctx) {\n          const last = dom.getLastEl(ctx)\n          if (!last) return\n          set.highlighted(ctx, last.id)\n        },\n        highlightNextItem(ctx, evt) {\n          const next = dom.getNextEl(ctx, evt.loop)\n          set.highlighted(ctx, next?.id ?? null)\n        },\n        highlightPrevItem(ctx, evt) {\n          const prev = dom.getPrevEl(ctx, evt.loop)\n          set.highlighted(ctx, prev?.id ?? null)\n        },\n        invokeOnSelect(ctx) {\n          if (!ctx.highlightedValue) return\n          ctx.onSelect?.({ value: ctx.highlightedValue })\n        },\n        focusTrigger(ctx) {\n          if (ctx.isSubmenu || ctx.anchorPoint || !ctx.restoreFocus) return\n          raf(() => dom.getTriggerEl(ctx)?.focus({ preventScroll: true }))\n        },\n        highlightMatchedItem(ctx, evt) {\n          const node = dom.getElemByKey(ctx, evt.key)\n          if (!node) return\n          set.highlighted(ctx, node.id)\n        },\n        setParentMenu(ctx, evt) {\n          ctx.parent = ref(evt.value)\n        },\n        setChildMenu(ctx, evt) {\n          ctx.children[evt.id] = ref(evt.value)\n        },\n        closeRootMenu(ctx) {\n          closeRootMenu(ctx)\n        },\n        openSubmenu(ctx) {\n          const item = dom.getHighlightedItemEl(ctx)\n          const id = item?.getAttribute(\"data-uid\")\n          const child = id ? ctx.children[id] : null\n          child?.send(\"OPEN_AUTOFOCUS\")\n        },\n        focusParentMenu(ctx) {\n          ctx.parent?.send(\"FOCUS_MENU\")\n        },\n        setLastHighlightedItem(ctx, evt) {\n          ctx.lastHighlightedValue = evt.id\n        },\n        restoreHighlightedItem(ctx) {\n          if (!ctx.lastHighlightedValue) return\n          set.highlighted(ctx, ctx.lastHighlightedValue)\n          ctx.lastHighlightedValue = null\n        },\n        restoreParentHiglightedItem(ctx) {\n          ctx.parent?.send(\"HIGHLIGHTED.RESTORE\")\n        },\n        invokeOnOpen(ctx) {\n          ctx.onOpenChange?.({ open: true })\n        },\n        invokeOnClose(ctx) {\n          ctx.onOpenChange?.({ open: false })\n        },\n        toggleVisibility(ctx, evt, { send }) {\n          send({ type: ctx.open ? \"CONTROLLED.OPEN\" : \"CONTROLLED.CLOSE\", previousEvent: evt })\n        },\n      },\n    },\n  )\n}\n\nfunction closeRootMenu(ctx: MachineContext) {\n  let parent = ctx.parent\n  while (parent && parent.state.context.isSubmenu) {\n    parent = parent.state.context.parent\n  }\n  parent?.send(\"CLOSE\")\n}\n\nconst set = {\n  highlighted(ctx: MachineContext, value: string | null) {\n    if (isEqual(ctx.highlightedValue, value)) return\n    ctx.highlightedValue = value\n    ctx.onHighlightChange?.({ highlightedValue: value })\n  },\n}\n", "import { createProps } from \"@zag-js/types\"\nimport { createSplitProps } from \"@zag-js/utils\"\nimport type { ItemGroupLabelProps, ItemGroupProps, ItemProps, OptionItemProps, UserDefinedContext } from \"./menu.types\"\n\nexport const props = createProps<UserDefinedContext>()([\n  \"anchorPoint\",\n  \"aria-label\",\n  \"closeOnSelect\",\n  \"dir\",\n  \"getRootNode\",\n  \"highlightedValue\",\n  \"id\",\n  \"ids\",\n  \"loopFocus\",\n  \"onFocusOutside\",\n  \"onInteractOutside\",\n  \"onOpenChange\",\n  \"onPointerDownOutside\",\n  \"onEscapeKeyDown\",\n  \"onSelect\",\n  \"onHighlightChange\",\n  \"open\",\n  \"open.controlled\",\n  \"positioning\",\n  \"typeahead\",\n  \"composite\",\n])\n\nexport const splitProps = createSplitProps<Partial<UserDefinedContext>>(props)\n\nexport const itemProps = createProps<ItemProps>()([\"closeOnSelect\", \"disabled\", \"value\", \"valueText\"])\nexport const splitItemProps = createSplitProps<ItemProps>(itemProps)\n\nexport const itemGroupLabelProps = createProps<ItemGroupLabelProps>()([\"htmlFor\"])\nexport const splitItemGroupLabelProps = createSplitProps<ItemGroupLabelProps>(itemGroupLabelProps)\n\nexport const itemGroupProps = createProps<ItemGroupProps>()([\"id\"])\nexport const splitItemGroupProps = createSplitProps<ItemGroupProps>(itemGroupProps)\n\nexport const optionItemProps = createProps<OptionItemProps>()([\n  \"disabled\",\n  \"valueText\",\n  \"closeOnSelect\",\n  \"type\",\n  \"value\",\n  \"checked\",\n  \"onCheckedChange\",\n])\n\nexport const splitOptionItemProps = createSplitProps<OptionItemProps>(optionItemProps)\n", "import * as menu from \"@zag-js/menu\";\nimport { normalizeProps } from \"./normalize-props\";\nimport { spreadProps } from \"./spread-props\";\n\nexport const Menu = {\n  mounted() {\n    this.context = { id: this.el.id };\n\n    this.service = menu.machine(this.context);\n    this.api = menu.connect(this.service.state, this.service.send, normalizeProps);\n\n    this.init();\n  },\n\n  beforeDestroy() {\n    this.service.stop();\n  },\n\n  init() {\n    const service = this.service;\n\n    this.render();\n    service.subscribe(() => {\n      this.api = menu.connect(service.state, service.send, normalizeProps);\n      this.render();\n    });\n\n    service.start();\n  },\n\n  labels() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='label']\"));\n  },\n\n  groups() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='group']\"));\n  },\n\n  items() {\n    return Array.from(this.el.querySelectorAll(\"[data-part='item']\"));\n  },\n\n  render() {\n    const trigger = this.el.querySelector(\"[data-part='trigger']\");\n    const positioner = this.el.querySelector(\"[data-part='positioner']\");\n    const content = this.el.querySelector(\"[data-part='content']\");\n\n    if (trigger) spreadProps(trigger, this.api.triggerProps);\n    if (positioner) spreadProps(positioner, this.api.positionerProps);\n    if (content) spreadProps(content, this.api.contentProps);\n\n    this.labels().forEach((label) => {\n      this.renderLabel(label);\n    });\n\n    this.groups().forEach((group) => {\n      this.renderGroup(group);\n    });\n\n    this.items().forEach((item) => {\n      this.renderItem(item);\n    });\n  },\n\n  renderLabel(label) {\n    spreadProps(label, this.api.getItemGroupLabelProps({ htmlFor: label.dataset.for }));\n  },\n  renderGroup(group) {\n    spreadProps(group, this.api.getItemGroupProps({ id: group.id }));\n  },\n  renderItem(item) {\n    spreadProps(item, this.api.getItemProps({ value: item.id }));\n  },\n};\n", "import { Accordion } from \"./accordion\";\nimport { Menu } from \"./menu\";\n\nexport { Accordion } from \"./accordion\";\nexport { Menu } from \"./menu\";\n\nexport const Hooks = {\n  Accordion: Accordion,\n  Menu: Menu,\n};\n"],
  "mappings": "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",
  "names": ["parts", "query", "isHTMLElement", "first", "first", "last", "cleanups", "query", "el", "cleanups", "props", "proxyFunction", "remove", "set", "set", "runIfFn", "cast", "noop", "callAll", "isDev", "isObject", "isFunction", "compact", "isPlainObject", "warn", "isFunction", "cast", "noop", "isObject", "isEqual", "state", "runIfFn", "cleanups", "compact", "options", "warn", "determineDelay", "delay", "isDev", "self", "match", "props", "callAll", "props", "value", "props", "keyMap", "exec", "and", "not", "ctx", "set", "splitProps", "match", "props", "platform", "max", "offset", "platform", "placements", "sides", "side", "placement", "overflow", "platform", "x", "y", "min", "max", "offset", "isNode", "getWindow", "isHTMLElement", "isShadowRoot", "isOverflowElement", "css", "css", "isHTMLElement", "getWindow", "isOverflowElement", "offset", "shift", "flip", "size", "arrow", "limitShift", "computePosition", "arrow", "arrow", "offset", "shift", "flip", "limitShift", "size", "computePosition", "cleanups", "handler", "cleanups", "getDocument", "cleanups", "node", "contains", "min", "max", "min", "anatomy", "parts", "dom", "connect", "props", "keyMap", "exec", "event", "not", "and", "or", "machine", "getByTypeahead", "ctx", "isEditableElement", "guards", "contentEl", "set", "first", "last", "splitProps", "itemProps", "splitItemProps", "machine", "connect"]
}
